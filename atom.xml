<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>智的前端之路</title>
  <subtitle>若有智，事可为</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.imeetyou.net/"/>
  <updated>2017-04-11T02:19:12.000Z</updated>
  <id>http://www.imeetyou.net/</id>
  
  <author>
    <name>KINGZHI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>call()、apply()、bind()的用法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-call-apply-bind.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-call-apply-bind.html</id>
    <published>2017-04-11T04:26:09.000Z</published>
    <updated>2017-04-11T02:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在javascript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中， 作为参数传入另外一个函数等。</p>
<h2 id="bind、call、apply"><a href="#bind、call、apply" class="headerlink" title="bind、call、apply"></a>bind、call、apply</h2><p>每一个函数都包含一个 prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。 每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p>
<h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p>call() 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法.</p>
<blockquote>
<p>注意：该方法的作用和 apply() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</div><div class="line"></div><div class="line">fun.apply(thisArg[, argsArray])</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>apply 与 call() 非常相似，不同之处在于提供参数的方式。</p>
<p>apply 使用参数数组而不是一组参数列表，apply 可以使用数组字面量（array literal），</p>
<p>如：fun.apply(this, [‘eat’, ‘bananas’])，或数组对象，</p>
<p>如：fun.apply(this, new Array(‘eat’, ‘bananas’))。</p>
<h3 id="使用call方法调用函数并且指定上下文的’this’"><a href="#使用call方法调用函数并且指定上下文的’this’" class="headerlink" title="使用call方法调用函数并且指定上下文的’this’"></a>使用call方法调用函数并且指定上下文的’this’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function greet() &#123;</div><div class="line">  var arr = [this.person, &apos;is age&apos;, this.age].join(&apos; &apos;);</div><div class="line">  console.log(arr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var i = &#123;</div><div class="line">  person: &quot;wang&quot;,</div><div class="line">  age: 20</div><div class="line">&#125;</div><div class="line"></div><div class="line">greet.call(i); // 这里的 this 会绑定到 i 对象上。</div></pre></td></tr></table></figure>
<h3 id="使用call方法调用匿名函数"><a href="#使用call方法调用匿名函数" class="headerlink" title="使用call方法调用匿名函数"></a>使用call方法调用匿名函数</h3><p>在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var animals = [</div><div class="line">  &#123;species: &apos;Lion&apos;, name: &apos;King&apos;&#125;,</div><div class="line">  &#123;species: &apos;Whale&apos;, name: &apos;Fail&apos;&#125;</div><div class="line">];</div><div class="line"></div><div class="line">for (var i = 0; i &lt; animals.length; i++) &#123;</div><div class="line">  (function (i) &#123;</div><div class="line">    this.print = function () &#123;</div><div class="line">      console.log(&apos;#&apos; + i  + &apos; &apos; + this.species + &apos;: &apos; + this.name);</div><div class="line">    &#125;</div><div class="line">    this.print();</div><div class="line">  &#125;).call(animals[i], i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用apply和内置函数"><a href="#使用apply和内置函数" class="headerlink" title="使用apply和内置函数"></a>使用apply和内置函数</h3><p>聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。在接下里的例子中我们会使用Math.max/Math.min来找出一个数组中的最大/最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var numbers = [5, 6, 2, 3, 7];</div><div class="line"></div><div class="line">var max = Math.max.apply(null, numbers); /* This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) */</div><div class="line">var min = Math.min.apply(null, numbers);</div><div class="line"></div><div class="line">max = -Infinity, min = +Infinity;</div><div class="line"></div><div class="line">for (var i = 0; i &lt; numbers.length; i++) &#123;</div><div class="line">  if (numbers[i] &gt; max)</div><div class="line">    max = numbers[i];</div><div class="line">  if (numbers[i] &lt; min)</div><div class="line">    min = numbers[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2><p><code>bind()</code> 方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
<p><code>bind()</code>是在ES5中新增的方法，从名字可以看出，这个方法的主要作用就是将函数绑定到某个对象。</p>
<h3 id="创建绑定函数"><a href="#创建绑定函数" class="headerlink" title="创建绑定函数"></a>创建绑定函数</h3><p>bind() 最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。</p>
<p>经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，希望方法中的 this 是原来的对象。（比如在回调中传入这个方法。）如果不做特殊处理的话，一般会丢失原来的对象。从原来的函数和原来的对象创建一个绑定函数，则能很漂亮地解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var x = 9;</div><div class="line">var obj = &#123;</div><div class="line">	x: 81,</div><div class="line">    getX: function() &#123;</div><div class="line">		return this.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.getX(); // 返回 81</div><div class="line"></div><div class="line">var b = obj.getX;</div><div class="line">b() // 返回 9, 在这种情况下，&quot;this&quot;指向全局作用域</div><div class="line"></div><div class="line">// 创建一个新函数，将&quot;this&quot;绑定到obj对象</div><div class="line">// 新手可能会被全局的x变量和obj里的属性x所迷惑</div><div class="line">var bindX = b.bind(obj);</div><div class="line">bindX(); // 返回 81</div></pre></td></tr></table></figure>
<p>当在函数f()上调用bind()方法并后传入一个对象o作为参数，这个方法将返回一个新函数： （以函数调用的方式）调用新的函数将会把原始的函数f()作为o的方法来调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function f(y) &#123;</div><div class="line">  return this.x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var o = &#123;</div><div class="line">  x: 1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var g = f.bind(o);  // 通过调用 g(x) 来调用 o.f(x)</div><div class="line">g(2); // 3</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考引用资料</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">MDN JavaScript 参考文档</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在javascript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中， 作为参数传入另外一个函数等。&lt;/p&gt;
&lt;h2 id=&quot;bind、call、apply&quot;&gt;&lt;a href=&quot;#bind、call、apply&quot; class=&quot;headerlink&quot; title=&quot;bind、call、apply&quot;&gt;&lt;/a&gt;bind、call、apply&lt;/h2&gt;&lt;p&gt;每一个函数都包含一个 prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。 每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。&lt;/p&gt;
&lt;h2 id=&quot;Function-prototype-call&quot;&gt;&lt;a href=&quot;#Function-prototype-call&quot; class=&quot;headerlink&quot; title=&quot;Function.prototype.call()&quot;&gt;&lt;/a&gt;Function.prototype.call()&lt;/h2&gt;&lt;p&gt;call() 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：该方法的作用和 apply() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fun.call(thisArg[, arg1[, arg2[, ...]]])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fun.apply(thisArg[, argsArray])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="call" scheme="http://www.imeetyou.net/tags/call/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式(Flyweight)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-flyweight.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-flyweight.html</id>
    <published>2017-04-07T04:36:39.000Z</published>
    <updated>2017-04-07T08:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。</p>
<p>享元模式可以避免大量非常相似类的开销，在程序设计中，有时需要生产大量细粒度的类实例来表示数据，如果能发现这些实例除了几个参数以外，开销基本相同的话，就可以大幅度较少需要实例化的类的数量。如果能把那些参数移动到类实例的外面，在方法调用的时候将他们传递进来，就可以通过共享大幅度第减少单个实例的数目。</p>
<p>那么如果在JavaScript中应用享元模式呢？有两种方式：</p>
<ul>
<li>第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；</li>
<li>第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄</li>
</ul>
<a id="more"></a>
<h2 id="享元与数据层"><a href="#享元与数据层" class="headerlink" title="享元与数据层"></a>享元与数据层</h2><p>享元模式要求将对象的属性划分为内部状态与外部状态(状态在这里通常指属性)。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。</p>
<ul>
<li>内部状态存储于对象内部。</li>
<li>内部状态可以被一些对象共享。</li>
<li>内部状态独立于具体的场景，通常不会改变。</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li>
</ul>
<p>说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式，Flyweight的内部状态是用来共享的，Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><strong>如下场景：</strong></p>
<p>图书馆有很多书，设计一个管理系统管理所有的借书信息</p>
<p>假定每个书的内容有：<code>title</code>、<code>author</code>、<code>id</code>、<code>site</code></p>
<p>每本书被借出时间、借书人、归还日期、是否可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">checkoutDate</div><div class="line">checkoutMember</div><div class="line">dueReturnDate</div><div class="line">availability</div></pre></td></tr></table></figure>
<p>我们可以将数据分成内部和外部两种数据，和book对象相关的数据（title, author 等）可以归结为内部属性，而（checkoutMember, dueReturnDate等）可以归结为外部属性。这样，如下代码就可以在同一本书里共享同一个对象了，因为不管谁借的书，只要书是同一本书，基本信息是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 内部公共属性</div><div class="line">var Book = function(title, author, id, ISBN) &#123;</div><div class="line">    this.title = title;</div><div class="line">    this.author = author;</div><div class="line">    this.id = id;</div><div class="line">    this.ISBN = ISBN</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定义基本工厂"><a href="#定义基本工厂" class="headerlink" title="定义基本工厂"></a>定义基本工厂</h3><p>让我们来定义一个基本工厂，用来检查之前是否创建该book的对象，如果有就返回，没有就重新创建并存储以便后面可以继续访问，这确保我们为每一种书只创建一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// book工厂</div><div class="line">var BookFactory = (function()&#123;</div><div class="line">    var existingBooks = &#123;&#125;;</div><div class="line">    return &#123;</div><div class="line">        createBook: function(title, author, id, ISBN) &#123;</div><div class="line">           // 查找之前是否创建</div><div class="line">           var existingBook = existingBooks[ISBN];</div><div class="line">           if (existingBook) &#123;</div><div class="line">                   return existingBook;</div><div class="line">               &#125; else &#123;</div><div class="line">               // 如果没有，就创建一个，然后保存</div><div class="line">               var book = new Book(title, author, id, ISBN);</div><div class="line">               existingBooks[ISBN] =  book;</div><div class="line">               return book;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="管理外部状态"><a href="#管理外部状态" class="headerlink" title="管理外部状态"></a>管理外部状态</h3><p>外部状态，相对就简单了，除了我们封装好的book，其它都需要在这里管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var BookRecord = (function() &#123;</div><div class="line">    var bookRecordDatabase = &#123;&#125;;</div><div class="line">    return &#123;</div><div class="line">        addBook: function(title, author, id, ISBN, checkoutDate, checkoutMember, dueReturnDate, availability) &#123;</div><div class="line">            var book = BookFactory.createBook(title, author, id, ISBN);</div><div class="line">            bookRecordDatabase[id] = &#123;</div><div class="line">               checkoutMember: checkoutMember,</div><div class="line">               checkoutDate: checkoutDate,</div><div class="line">               dueReturnDate: dueReturnDate,</div><div class="line">               availability: availability,</div><div class="line">               book: book</div><div class="line">           &#125;;</div><div class="line">           console.log(bookRecordDatabase);</div><div class="line">       &#125;,</div><div class="line">       updateCheckoutStatus: function(bookID, newStatus, checkoutDate, checkoutMember, newReturnDate)&#123;</div><div class="line">            var record = bookRecordDatabase[bookID];</div><div class="line">            record.availability = newStatus;</div><div class="line">            record.checkoutDate = checkoutDate;</div><div class="line">            record.checkoutMember = checkoutMember;</div><div class="line">            record.dueReturnDate = newReturnDate;</div><div class="line">       &#125;,</div><div class="line">       extendCheckoutPeriod: function(bookID, newReturnDate) &#123;</div><div class="line">           bookRecordDatabase[bookID].dueReturnDate = newReturnDate;</div><div class="line">       &#125;,</div><div class="line">       isPastDue: function(bookID) &#123;</div><div class="line">           var currentDate = new Date();</div><div class="line">           return currentDate.getTime() &gt; Date.parse(bookRecordDatabase[bookID].dueReturnDate);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>通过这种方式，我们做到了将同一种图书的相同信息保存在一个bookmanager对象里，而且只保存一份；相比之前的代码，就可以发现节约了很多内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样。在一个存在<br>大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。&lt;/p&gt;
&lt;p&gt;享元模式可以避免大量非常相似类的开销，在程序设计中，有时需要生产大量细粒度的类实例来表示数据，如果能发现这些实例除了几个参数以外，开销基本相同的话，就可以大幅度较少需要实例化的类的数量。如果能把那些参数移动到类实例的外面，在方法调用的时候将他们传递进来，就可以通过共享大幅度第减少单个实例的数目。&lt;/p&gt;
&lt;p&gt;那么如果在JavaScript中应用享元模式呢？有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；&lt;/li&gt;
&lt;li&gt;第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板模式(TemplateMethod)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-template.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-template.html</id>
    <published>2017-04-06T09:56:39.000Z</published>
    <updated>2017-04-06T07:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这不代表继承在 JavaScript 里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型 prototype 来变相地实现继承。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板方法模式是一种只需使用继承就可以实现的非常简单的模式。</p>
<p><strong>模板方法模式由两部分结构组成：</strong></p>
<ul>
<li>第一部分是抽象父类，</li>
<li>第二部分是具体的实现子类。</li>
</ul>
<p>通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="Coffee-or-Tea"><a href="#Coffee-or-Tea" class="headerlink" title="Coffee or Tea"></a>Coffee or Tea</h3><p>咖啡与茶是一个经典的例子，经常用来讲解模板方法模式</p>
<p>泡茶和泡咖啡有同样的步骤，比如烧开水（boilWater）、冲泡（brew）、倒在杯子里（pourInCup），加小料（addCondiments）等等。</p>
<p>但每种饮料冲泡的方法以及所加的小料不一样，所以我们可以利用模板方法实现这个主要步骤</p>
<p>首先先来定义抽象步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Beverage = function()&#123;&#125;;</div><div class="line">Beverage.prototype.boilWater = function()&#123;</div><div class="line">	 console.log( &apos;把水煮沸&apos; );</div><div class="line">&#125;;</div><div class="line">Beverage.prototype.brew = function()&#123;&#125;; // 空方法，应该由子类重写</div><div class="line">Beverage.prototype.pourInCup = function()&#123;&#125;; // 空方法，应该由子类重写</div><div class="line">Beverage.prototype.addCondiments = function()&#123;&#125;; // 空方法，应该由子类重写</div><div class="line">Beverage.prototype.init = function()&#123;</div><div class="line">	this.boilWater();</div><div class="line">	this.brew();</div><div class="line">	this.pourInCup();</div><div class="line">	this.addCondiments();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来我们要创建咖啡类和茶类，并让它们继承抽象类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 冲咖啡</div><div class="line">var Coffee = function()&#123;&#125;;</div><div class="line">Coffee.prototype = new Beverage();</div><div class="line">Coffee.prototype.brew = function() &#123;</div><div class="line">	console.log( &apos;用沸水冲泡咖啡&apos; );</div><div class="line">&#125;</div><div class="line">Coffee.prototype.pourInCup = function() &#123;</div><div class="line">	console.log( &apos;把咖啡倒进杯子&apos; );</div><div class="line">&#125;</div><div class="line">Coffee.prototype.addCondiments = function() &#123;</div><div class="line">	console.log( &apos;加糖和牛奶&apos; );</div><div class="line">&#125;</div><div class="line">var Coffee = new Coffee();</div><div class="line">Coffee.init();</div><div class="line"></div><div class="line">// 冲茶叶</div><div class="line">var Tea = function()&#123;&#125;;</div><div class="line">Tea.prototype = new Beverage();</div><div class="line">Tea.prototype.brew = function() &#123;</div><div class="line">	console.log( &apos;用沸水冲泡茶叶&apos; );</div><div class="line">&#125;</div><div class="line">Tea.prototype.pourInCup = function() &#123;</div><div class="line">	console.log( &apos;把茶倒进杯子&apos; );</div><div class="line">&#125;</div><div class="line">Tea.prototype.addCondiments = function() &#123;</div><div class="line">	console.log( &apos;加柠檬&apos; );</div><div class="line">&#125;</div><div class="line">var Tea = new Tea();</div><div class="line">Tea.init();</div></pre></td></tr></table></figure>
<p>那么在上面的例子中，到底谁才是所谓的模板方法呢?答案是 <code>Beverage.prototype.init</code>。</p>
<p><code>Beverage.prototype.init</code> 被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在 <code>Beverage.prototype.init</code> 方法中，算法内的每一个步骤都清楚地展示在我们眼前。</p>
<h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><p>我们要引入一个新的设计原则——著名的“好莱坞原则”。</p>
<p>好莱坞原则简单来说就是：“别找我们，我们来找你”，是一种反向的控制结构，指的是父类调用一个类的操作。</p>
<p>在这一原则的指导下，模板方法模式就是允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件。</p>
<p>在好莱坞原则的指导之下，下面这段代码可以达到和使用继承一样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">var Beverage = function(param) &#123;</div><div class="line"></div><div class="line">	var boilWater = function() &#123;</div><div class="line">		console.log( &apos;0 把水煮沸&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var brew = param.brew || function() &#123;</div><div class="line">		throw new Error( &apos;必须传递 brew 方法&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var pourInCup = param.pourInCup || function() &#123;</div><div class="line">		throw new Error( &apos;必须传递 pourInCup 方法&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var addCondiments = param.addCondiments || function() &#123;</div><div class="line">		throw new Error( &apos;必须传递 addCondiments 方法&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var F = function()&#123;&#125;;</div><div class="line"></div><div class="line">	F.prototype.init = function()&#123;</div><div class="line">		boilWater();</div><div class="line">	    brew();</div><div class="line">		pourInCup();</div><div class="line">		addCondiments();</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	return F;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Coffee = Beverage(&#123;</div><div class="line">	brew: function() &#123;</div><div class="line">		console.log( &apos;1 用沸水冲泡咖啡&apos; );</div><div class="line">	&#125;,</div><div class="line">	pourInCup: function() &#123;</div><div class="line">		console.log( &apos;2 把咖啡倒进杯子&apos; );</div><div class="line">	&#125;,</div><div class="line">	addCondiments: function() &#123;</div><div class="line">		console.log( &apos;3 加糖和牛奶&apos; );</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var coffee = new Coffee();</div><div class="line">coffee.init();</div><div class="line"></div><div class="line">var Tea = Beverage(&#123;</div><div class="line">	brew: function() &#123;</div><div class="line">		console.log( &apos;1 用沸水浸泡茶叶&apos; );</div><div class="line">	&#125;,</div><div class="line">	pourInCup: function()&#123;</div><div class="line">		console.log( &apos;2 把茶倒进杯子&apos; );</div><div class="line">	&#125;,</div><div class="line">	addCondiments: function() &#123;</div><div class="line">		console.log( &apos;3 加柠檬&apos; );</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var tea = new Tea();</div><div class="line">tea.init();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板方法应用于下列情况：</p>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码</li>
<li>控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展</li>
</ul>
<p>和策略模式不同，模板方法使用继承来改变算法的一部分，而策略模式使用委托来改变整个算法。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这不代表继承在 JavaScript 里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型 prototype 来变相地实现继承。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;模板方法模式是一种只需使用继承就可以实现的非常简单的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式由两部分结构组成：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分是抽象父类，&lt;/li&gt;
&lt;li&gt;第二部分是具体的实现子类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之发布/订阅模式(Publish/Subscribe)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-publish-subscribe.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-publish-subscribe.html</id>
    <published>2017-04-05T04:36:29.000Z</published>
    <updated>2017-04-05T08:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>发布/订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布/订阅模式</p>
<h2 id="遍地的发布订阅现象"><a href="#遍地的发布订阅现象" class="headerlink" title="遍地的发布订阅现象"></a>遍地的发布订阅现象</h2><p>如今的信息化时代，发布/订阅模式的应用可以说非常广泛，比如微信公众号就是典型的发布/订阅模式，公众号发布一条信息，所有的订阅者都会收到。</p>
<p>有人可能也会想到经常收到的各种广告短信信息（有的可能是被动订阅），其实发送短信通知或广告也是一个典型的发布/订阅模式。</p>
<p>发布/订阅模式可以广泛用于异步编程中，代替传递回掉函数的方案，比如，我们可以订阅 ajax 请求的 error、succ 等事件。</p>
<p>另外发表订阅让两个对象松耦合在一起，不必了解彼此细节，当有新的订阅者出现时，发布者的代码不需要任何修改。同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<p>使用发布订阅模式的好处：</p>
<ul>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li>
<li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li>
<li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="自定义发表订阅"><a href="#自定义发表订阅" class="headerlink" title="自定义发表订阅"></a>自定义发表订阅</h3><p>我们来尝试一个自定义的发布订阅模式，那么如何实现发布订阅呢</p>
<ul>
<li>指定一个发布者</li>
<li>给发布者添加一个缓冲列表，用于存放回调函数以用于通知订阅者</li>
<li>发布消息时，发布者遍历缓存列表，依次触发每个订阅者的回调函数</li>
</ul>
<p><strong>一个简单的天气状态订阅</strong></p>
<pre><code>var Weather = {
    list: [], // 缓存列表
    listen: function(fn) { // 增加订阅者
        this.list.push(fn)
    },
    publish: function() { // 发布消息
        for(var i=0,fn; fn=this.list[i++];) {
            fn.apply(this,arguments);
        }
    }
};

// 订阅消息
Weather.listen(function(weather, wind){
    console.log(&apos;天气：&apos; + weather, &apos;风力：&apos;+ wind);
})

// 发布消息
Weather.publish(&quot;晴天&quot;,&quot;微风&quot;); // 天气：晴天 风力：微风
Weather.publish(&quot;雷阵雨&quot;,&quot;5级风&quot;); // 天气：雷阵雨 风力：5级风
</code></pre><p>以上，已经实现了一个最简单的发布—订阅模式，还可以为订阅者增加自选功能，订阅自己想要的消息，也可以增加取消订阅的事件。</p>
<pre><code>var PubSub = {
    list: [],
    listen: function(key, fn){
        if(!this.list[key]) {
            this.list[key]=[];
        }
        this.list[key].push(fn);
    },
    publish: function(){
        var key = Array.prototype.shift.call(arguments),
            fns = this.list[key];
        if(!fns || fns.length === 0) {
            return false;
        }
        for(var i = 0, fn; fn = fns[i++];){
            fn.apply(this, arguments);
        }
    }
}

//
var installEvent = function(obj) {
    for (var i in PubSub) {
        obj[i] = PubSub[i];
    }
};

var day = {}
installEvent(day);

day.listen(&apos;天气&apos;, function(wind) {
    console.log(&apos;风力：&apos;+ wind);
});

day.publish(&apos;天气&apos;, &quot;8级风&quot;);
</code></pre><h3 id="实战之网站登录"><a href="#实战之网站登录" class="headerlink" title="实战之网站登录"></a>实战之网站登录</h3><p>网站登录是最常见的形式，通常在登录以后我们会ajax异步请求获取用户信息，比如显示用户名字、头像等信息在header模块，而这两个字段都是来自用户登录后返回的信息。至于 ajax 请求什么时候能成功返回用户信息，这点我们没有办法确定，虽然现在看起来和发布订阅模式没关系，因为异步的问题通常也可以回调函数来解决。</p>
<p>我们不知道除了 header 头部、nav 导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式:</p>
<pre><code>login.succ(function(data){
    header.setAvatar( data.avatar);  // 设置 header 模块的头像
    nav.setAvatar( data.avatar ); // 设置导航模块的头像
    message.refresh(); // 刷新消息列表
    cart.refresh(); // 刷新购物车列表
});
</code></pre><p>现在登录模块是我们负责编写的，但我们还必须了解 header 模块里设置头像的方法叫 setAvatar、购物车模块里刷新的方法叫 refresh，这种耦合性会使程序变得僵硬，header 模块不能随意再改变 setAvatar 的方法名，它自身的名字也不能被改为 header1、header2。 这是针对具 体实现编程的典型例子，针对具体实现编程是不被赞同的。</p>
<p>某一个，项目新增加收获地址管理模块：</p>
<pre><code>login.succ(function(data){
    header.setAvatar( data.avatar);
    nav.setAvatar( data.avatar );
    message.refresh();
    address.refresh(); // 新增加收获地址
});
</code></pre><p>现在我们用发布订阅重写，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。 当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码如下:</p>
<pre><code>$.ajax( &apos;http://xxx.com?login&apos;, function(data){ // 登录成功
    login.trigger( &apos;loginSucc&apos;, data); // 发布登录成功的消息
});
</code></pre><p>各模块监听登录成功的消息:</p>
<pre><code>var header = (function() { // header 模块
    login.listen( &apos;loginSucc&apos;, function(data) {
        header.setAvatar( data.avatar );
    });
    return {
        setAvatar: function(data) {
            console.log( &apos;设置 header 模块的头像&apos;);
        }
    }
})();

var nav = (function() {  // nav 模块
    login.listen(&apos;loginSucc&apos;, function(data) {
        nav.setAvatar( data.avatar );
    });
    return {
        setAvatar: function(avatar) {
            console.log( &apos;设置 nav 模块的头像&apos;);
        }
    }
})();
</code></pre><p>如果有一天在登录完成之 后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用再关心这些行为了</p>
<pre><code>var address = (function(){ // 收获地址模块
    login.listen(&apos;loginSucc&apos;, function(obj){
        address.refresh(obj);
    });
    return {
        refresh: function( avatar ){
            console.log( &apos;刷新收货地址列表&apos; );
        }
    }
})();
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发布订阅的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p>
<p>总的来说，发布订阅模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>
<p>另外， 发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布/订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布/订阅模式&lt;/p&gt;
&lt;h2 id=&quot;遍地的发布订阅现象&quot;&gt;&lt;a href=&quot;#遍地的发布订阅现象&quot; class=&quot;headerlink&quot; title=&quot;遍地的发布订阅现象&quot;&gt;&lt;/a&gt;遍地的发布订阅现象&lt;/h2&gt;&lt;p&gt;如今的信息化时代，发布/订阅模式的应用可以说非常广泛，比如微信公众号就是典型的发布/订阅模式，公众号发布一条信息，所有的订阅者都会收到。&lt;/p&gt;
&lt;p&gt;有人可能也会想到经常收到的各种广告短信信息（有的可能是被动订阅），其实发送短信通知或广告也是一个典型的发布/订阅模式。&lt;/p&gt;
&lt;p&gt;发布/订阅模式可以广泛用于异步编程中，代替传递回掉函数的方案，比如，我们可以订阅 ajax 请求的 error、succ 等事件。&lt;/p&gt;
&lt;p&gt;另外发表订阅让两个对象松耦合在一起，不必了解彼此细节，当有新的订阅者出现时，发布者的代码不需要任何修改。同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式(Iterator)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-strategy.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-strategy.html</id>
    <published>2017-04-01T04:53:39.000Z</published>
    <updated>2017-04-01T07:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。</p>
<p>比如：JavaScript 的 <code>Array.prototype.forEach</code></p>
<p>jQuery里一个非常有名的迭代器就是 <code>$.each</code> 方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.each( [1, 2, 3], function( i, n )&#123;</div><div class="line">	console.log( &apos;当前下标为： &apos;+ i,&apos;当前值为:&apos; + n );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 下标： 0 当前值:1 </div><div class="line">// 下标： 1 当前值:2  </div><div class="line">// 下标： 2 当前值:3</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式(Iterator)：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。</p>
<p>迭代器的几个特点是：</p>
<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h3><p>参照jQuery的<code>$.each</code> 方法, 我们来自己实现一个 each 函数，each 函数接受 2 个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var each = function( ary, callback ) &#123;</div><div class="line">	for ( var i = 0, l = ary.length; i &lt; l; i++ )&#123;</div><div class="line">		callback.call( ary[i], i, ary[ i ] ); </div><div class="line">		// 把下标和元素当作参数传给callback 函数</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">each( [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ], function( i, n )&#123;</div><div class="line">	console.log( &apos;自定义下标为： &apos;+ i,&apos;自定义值为:&apos; + n );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 自定义下标为： 0 自定义值为:a  </div><div class="line">// 自定义下标为： 1 自定义值为:b </div><div class="line">// 自定义下标为： 2 自定义值为:c</div></pre></td></tr></table></figure>
<h3 id="迭代器模式的应用举例"><a href="#迭代器模式的应用举例" class="headerlink" title="迭代器模式的应用举例"></a>迭代器模式的应用举例</h3><p>以常用的上传文件功能为例，在不同的浏览器环境下，选择的上传方式是不一样的。因为使用浏览器的上传控件进行上传速度快，可以暂停和续传，所以我们首先会优先使用控件上传。如果浏览器没有安装上传控件， 则使用 Flash 上传， 如果连 Flash 也没安装，那就只好使用浏览器原生的表单上传了，代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var getUploadObj = function() &#123;</div><div class="line">	try &#123;</div><div class="line">		return new ActiveXObject(&quot;TXFTNActiveX.FTNUpload&quot;); // IE 上传控件</div><div class="line">	&#125; catch (e) &#123;</div><div class="line">		if (supportFlash()) &#123; // supportFlash 函数未提供</div><div class="line">			var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class="line">			return $(str).appendTo($(&apos;body&apos;));</div><div class="line">		&#125; else &#123;</div><div class="line">			var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot;/&gt;&apos;; // 表单上传</div><div class="line">			return $(str).appendTo($(&apos;body&apos;));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看看上面的代码，为了得到一个 upload 对象，这个 getUploadObj 函数里面充斥了 try，catch 以及 if 条件分支。缺点是显而易见的。</p>
<p>现在来梳理一下问题，目前一共有 3 种可能的上传方式，我们不知道目前浏览器支持那种上传方式，那就需要逐个尝试，直到成功为止，分别定义以下几个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// IE 上传控件</div><div class="line">var getActiveUploadObj = function() &#123;</div><div class="line">	try &#123;</div><div class="line">		return new ActiveXObject(&quot;TXFTNActiveX.FTNUpload&quot;); </div><div class="line">	&#125; catch (e) &#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Flash 上传</div><div class="line">var getFlashUploadObj = function() &#123;</div><div class="line">	if (supportFlash()) &#123; // supportFlash 函数未提供</div><div class="line">		var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class="line">		return $(str).appendTo($(&apos;body&apos;));</div><div class="line">	&#125;;</div><div class="line">	return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 表单上传</div><div class="line">var getFormUpladObj = function() &#123;</div><div class="line">	var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; class=&quot;ui-file&quot;/&gt;&apos;; </div><div class="line">	return $(str).appendTo($(&apos;body&apos;));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在以上三个函数中，如果该函数里面的 upload 对象是可用的，则让函数返回该对象，反之返回 false，提示迭代器继续往后面进行迭代。</p>
<p>那么迭代器只需进行下面这几步工作：</p>
<ul>
<li>提供一个可以被迭代的方法，使得 getActiveUploadObj，getFlashUploadObj 以及 getFlashUploadObj 依照优先级被循环迭代。</li>
<li>如果正在被迭代的函数返回一个对象，则表示找到了正确的 upload 对象，反之如果该函数返回 false，则让迭代器继续工作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var iteratorUpload = function() &#123;</div><div class="line">	for (var i = 0, fn; fn = arguments[i++];) &#123;</div><div class="line">		var upload = fn();</div><div class="line">		if (upload !== false) &#123;</div><div class="line">			return upload;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var uploadObj = iteratorUpload( getActiveUploadObj, getFlashUploadObj, getFormUpladObj )</div></pre></td></tr></table></figure>
<p>重构代码之后，可以看到，上传对象的各个函数彼此分离互补干扰，很方便维护和扩展，如果后期增加了 Webkit 控件上传和 HTML5 上传，我们就增加对应的函数功能并在迭代器里添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var getWebkitUploadObj = function()&#123; </div><div class="line"> // 具体代码略</div><div class="line">&#125;</div><div class="line"></div><div class="line">var getHtml5UploadObj = function()&#123; </div><div class="line"> // 具体代码略</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 依照优先级把它们添加进迭代器</div><div class="line">var uploadObj = iteratorUploadObj( getActiveUploadObj, getWebkitUploadObj,getFlashUploadObj, getHtml5UploadObj, getFormUpladObj );</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迭代器的使用场景是：对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又想让客户代码透明地访问其中的元素，这种情况下我们可以使用迭代器模式。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。&lt;/p&gt;
&lt;p&gt;比如：JavaScript 的 &lt;code&gt;Array.prototype.forEach&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;jQuery里一个非常有名的迭代器就是 &lt;code&gt;$.each&lt;/code&gt; 方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$.each( [1, 2, 3], function( i, n )&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log( &amp;apos;当前下标为： &amp;apos;+ i,&amp;apos;当前值为:&amp;apos; + n );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 下标： 0 当前值:1 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 下标： 1 当前值:2  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 下标： 2 当前值:3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="iterator" scheme="http://www.imeetyou.net/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>safari浏览器fixed后，被软键盘遮盖的问题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/html-safari-fixed.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/html-safari-fixed.html</id>
    <published>2017-03-31T10:12:19.000Z</published>
    <updated>2017-03-31T09:57:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>safari浏览器fixed后，被软键盘遮盖的问题，暂未有更好解决方案，度娘了好多方案，发现他们并未解决此问题，下文会叙述。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>测试环境：ios 10.2/10.3</strong></p>
<p>简单来说就是在html5页面中底部有个fixed的区域，如图</p>
<a id="more"></a>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix1.png" alt="safari-fix"></p>
<p>在点击输入框的时候，软键盘弹出，遮盖了fixed区域，如图</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix2.png" alt="safari-fix"></p>
<p>但是当你点击“完成”让软键盘收起，再次点击输入框的时候，what？一切正常了～！如图（就是要这样子的嘛，之后收起弹出软键盘都正常了，不会遮盖fixed底部区域了！）</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix3.png" alt="safari-fix"></p>
<p>但是，但是，还没完，在输入框里随便输入点内容，点击“提交”，关闭软键盘，之后再次点击输入框，问题依旧～，软键盘再次遮挡fixed区域。</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix4.png" alt="safari-fix"></p>
<p>如上循环，问题无法解决。</p>
<h2 id="测试代码如下"><a href="#测试代码如下" class="headerlink" title="测试代码如下"></a>测试代码如下</h2><p>代码很简单，但还是贴一下，方便测试，只需要复制粘贴到本机即可测试上述现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div><div class="line">    &lt;title&gt;fixed测试页面&lt;/title&gt;</div><div class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1&quot;&gt;</div><div class="line">    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</div><div class="line">    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</div><div class="line"></div><div class="line">	&lt;style&gt;</div><div class="line">		.head &#123;</div><div class="line">			top: 0;</div><div class="line">			height: 50px;</div><div class="line">			line-height: 50px;</div><div class="line">			text-align: center;</div><div class="line">			position: fixed;</div><div class="line">			left: 0;</div><div class="line">			width: 100%;</div><div class="line">			z-index: 10;</div><div class="line">			background-color: #99CC00;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.foot &#123;</div><div class="line">			bottom: 0;</div><div class="line">			padding: 10px;</div><div class="line">			position: fixed;</div><div class="line">			left: 0;</div><div class="line">			width: 100%;</div><div class="line">			background-color: #99CC00;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.main &#123;</div><div class="line">			width: 100%;</div><div class="line">			height: 100%;</div><div class="line">			overflow-y: scroll;</div><div class="line">			-webkit-overflow-scrolling: touch;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.list &#123;</div><div class="line">			padding: 0;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.list li &#123;</div><div class="line">			list-style: none;</div><div class="line">			background: #ccc;</div><div class="line">			height: 140px;</div><div class="line">			margin-bottom: 10px;</div><div class="line">			width: 100%;</div><div class="line">			padding:10px;</div><div class="line">		&#125;</div><div class="line">		.list a &#123;</div><div class="line">			border:2px solid #999;</div><div class="line">			display: block;</div><div class="line">			width:88%;</div><div class="line">			position: absolute;</div><div class="line">			height:140px;</div><div class="line">		&#125;</div><div class="line">		.input &#123;</div><div class="line">			width: 76%;</div><div class="line">			line-height: 30px;</div><div class="line">			border: none;</div><div class="line">			float: left;</div><div class="line">			border-radius:5px;</div><div class="line">		&#125;</div><div class="line">		.btn &#123;</div><div class="line">			float:right;</div><div class="line">			margin-right:15px;</div><div class="line">			border-radius:5px;</div><div class="line">			height:34px;</div><div class="line">			line-height: 32px;</div><div class="line">			padding: 0 10px;</div><div class="line">			border: none;</div><div class="line">			background: #000;</div><div class="line">			color: #fff;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">	&lt;header class=&quot;head&quot;&gt;顶部固定区域&lt;/header&gt;</div><div class="line"></div><div class="line">	&lt;main class=&quot;main&quot;&gt;</div><div class="line">		&lt;div class=&quot;content&quot;&gt;</div><div class="line">			&lt;ul class=&quot;list&quot;&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">			&lt;/ul&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/main&gt;</div><div class="line"></div><div class="line">	&lt;footer class=&quot;foot&quot; id=&quot;footer-fixed&quot;&gt;</div><div class="line">		&lt;button type=&quot;button&quot; id=&quot;btn-submit&quot; class=&quot;btn&quot; name=&quot;button&quot;&gt;提交&lt;/button&gt;</div><div class="line">		&lt;input type=&quot;text&quot; id=&quot;input-txt&quot; class=&quot;input&quot; name=&quot;&quot; value=&quot;&quot; placeholder=&quot;我来说两句...(200字内)&quot;&gt;</div><div class="line">	&lt;/footer&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="尝试过的解决方案"><a href="#尝试过的解决方案" class="headerlink" title="尝试过的解决方案"></a>尝试过的解决方案</h2><p>搜索后有很多解决方法，但发现他们都没解决上述问题，</p>
<p><strong>暂时的想法，绕过fixed点击输入框后，隐藏此区域，在顶部出现更大的输入区域以让用户输入内容。</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000005370182#articleHeader2" target="_blank" rel="external">IOS中弹出键盘后出现fixed失效现象的解决方案</a></li>
<li><a href="http://blog.csdn.net/kongjiea/article/details/46545351" target="_blank" rel="external">移动端解决fixed和input获取焦点软键盘弹出影响定位的问题</a></li>
<li><a href="http://www.cnblogs.com/yexiaochai/p/3561939.html" target="_blank" rel="external">虚拟键盘与fixed带给移动端的痛</a></li>
<li><a href="http://www.cnblogs.com/PeunZhang/archive/2013/06/14/3117589.html" target="_blank" rel="external">使用iScroll.js解决ios4下不支持position:fixed的问题</a></li>
</ul>
<p>好，至此，问题描述完毕，期待有牛人更好解决方案</p>
<hr>
<blockquote>
<p>segmentfault 专栏提出了问题</p>
<p><a href="https://segmentfault.com/a/1190000008906437?_ea=1772278" target="_blank" rel="external">https://segmentfault.com/a/1190000008906437?_ea=1772278</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;safari浏览器fixed后，被软键盘遮盖的问题，暂未有更好解决方案，度娘了好多方案，发现他们并未解决此问题，下文会叙述。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;测试环境：ios 10.2/10.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是在html5页面中底部有个fixed的区域，如图&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="css" scheme="http://www.imeetyou.net/tags/css/"/>
    
      <category term="html" scheme="http://www.imeetyou.net/tags/html/"/>
    
      <category term="safari" scheme="http://www.imeetyou.net/tags/safari/"/>
    
      <category term="fixed" scheme="http://www.imeetyou.net/tags/fixed/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式(Proxy)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-iterator.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-iterator.html</id>
    <published>2017-03-31T09:56:19.000Z</published>
    <updated>2017-03-31T09:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>代理，顾名思义就是帮助别人做事，GoF对代理模式的定义如下：</p>
<blockquote>
<p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们来举一个简单的例子，假如小明要送酸奶小妹玫瑰花，却不知道她的联系方式或者不好意思，想委托大叔去送这些玫瑰，那大叔就是个代理，那我们如何来做呢？</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 先声明美女对象</div><div class="line">var girl = function (name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 这是小明</div><div class="line">var xiaoMing = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        alert(&quot;Hi &quot; + girl.name + &quot;, 小明送你一个礼物：&quot; + gift);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 大叔是代理</div><div class="line">var proxyTom = function (girl) &#123;</div><div class="line">    this.girl = girl;</div><div class="line">    this.sendGift = function (gift) &#123;</div><div class="line">        (new xiaoMing(girl)).sendGift(gift); // 替dudu送花咯</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var proxy = new proxyTom(new girl(&quot;酸奶小妹&quot;));</div><div class="line">proxy.sendGift(&quot;999朵玫瑰&quot;);</div></pre></td></tr></table></figure>
<h3 id="虚拟代理实现图片预加载"><a href="#虚拟代理实现图片预加载" class="headerlink" title="虚拟代理实现图片预加载"></a>虚拟代理实现图片预加载</h3><p>在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性， 由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种 场景就很适合使用虚拟代理。</p>
<p>下面我们来实现这个虚拟代理，首先创建一个普通的本体对象，这个对象负责往页面中创建 一个 img 标签，并且提供一个对外的 setSrc 接口，外界调用这个接口，便可以给该 img 标签设置<br>src 属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var myImage = (function()&#123;</div><div class="line">	var imgNode = document.createElement( &apos;img&apos; );</div><div class="line">	document.body.appendChild( imgNode );</div><div class="line">	return &#123;</div><div class="line">		setSrc: function( src ) &#123;</div><div class="line">			imgNode.src = src;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();```我们把网速调至 5KB/s，然后通过 MyImage.setSrc 给该 img 节点设置 src，可以看到，在图片被加载好之前，页面中有一段长长的空白时间。现在开始引入代理对象 proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的菊花图 loading.gif, 来提示用户图片正在加载。代码如下:</div></pre></td></tr></table></figure>
<p>var myImage = (function(){<br>    var imgNode = document.createElement( ‘img’ );<br>    document.body.appendChild( imgNode );<br>    return {<br>        setSrc: function( src ) {<br>            imgNode.src = src;<br>        }<br>    }<br>})();</p>
<p>var proxyImage = (function() {<br>    var img = new Image;<br>    img.onload = function() {<br>        myImage.setSrc( this.src );<br>    }<br>    return {<br>        setSrc: function( src ) {<br>            myImage.setSrc( ‘./pic.jpg’ );<br>            img.src = src;<br>        }<br>    }<br>})();</p>
<p>proxyImage.setSrc( ‘./loading.gif’ );<br>```</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。 当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。&lt;/p&gt;
&lt;p&gt;代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;代理，顾名思义就是帮助别人做事，GoF对代理模式的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用实例&quot;&gt;&lt;a href=&quot;#使用实例&quot; class=&quot;headerlink&quot; title=&quot;使用实例&quot;&gt;&lt;/a&gt;使用实例&lt;/h2&gt;&lt;h3 id=&quot;简单实例&quot;&gt;&lt;a href=&quot;#简单实例&quot; class=&quot;headerlink&quot; title=&quot;简单实例&quot;&gt;&lt;/a&gt;简单实例&lt;/h3&gt;&lt;p&gt;我们来举一个简单的例子，假如小明要送酸奶小妹玫瑰花，却不知道她的联系方式或者不好意思，想委托大叔去送这些玫瑰，那大叔就是个代理，那我们如何来做呢？&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="proxy" scheme="http://www.imeetyou.net/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式(Strategy)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-proxy.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-proxy.html</id>
    <published>2017-03-29T10:16:09.000Z</published>
    <updated>2017-03-29T09:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在程序设计中，我们也常常遇到这样的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。<br>这些算法灵活多样，而且可以随意互相替换。这种解决方案就是将要介绍的策略模式。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<p>从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p>在一个 Web 项目中，注册、登录、修改用户信息等功能的实现都离不开提交表单。</p>
<p>在将用户输入的数据交给后台之前，常常要做一些客户端力所能及的校验工作，比如注册的时候需要校验是否填写了用户名，密码的长度是否符合规定等等。这样可以避免因为提交不合法数据而带来的不必要网络开销。</p>
<p>假设我们正在编写一个注册的页面，在点击注册按钮之前，有如下几条校验逻辑。</p>
<ul>
<li>用户名不能为空。</li>
<li>密码长度不能少于 6 位</li>
<li>手机号码必须符合格式。</li>
</ul>
<p>在理解策略模式之前，通常我们遇到类似多条件的业务，按照swith语句来判断，但是这就带来几个问题，首先如果增加需求的话，我们还要再次修改这段代码以增加逻辑，而且在进行单元测试的时候也会越来越复杂，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var validator = &#123;</div><div class="line">    validate: function (value, type) &#123;</div><div class="line">        switch (type) &#123;</div><div class="line">            case &apos;isNonEmpty &apos;:</div><div class="line">                    return true; // NonEmpty 验证结果</div><div class="line">            case &apos;minLength &apos;:</div><div class="line">                    return true; // minLength 验证结果</div><div class="line">                    break;</div><div class="line">            case &apos;isMobile &apos;:</div><div class="line">                    return true; // isMobile 验证结果</div><div class="line">            default:</div><div class="line">                    return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// 测试</div><div class="line">alert(validator.validate(&quot;123&quot;, &quot;isNonEmpty&quot;));</div></pre></td></tr></table></figure>
<h3 id="用策略模式重构表单校验"><a href="#用策略模式重构表单校验" class="headerlink" title="用策略模式重构表单校验"></a>用策略模式重构表单校验</h3><p>用策略模式来重构表单校验的代码，我们可以将相同的工作代码单独封装成不同的类，然后通过统一的策略处理类来处理，OK，我们先来定义策略处理类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">var validator = &#123;</div><div class="line"></div><div class="line">    // 所有可以的验证规则处理类存放的地方，后面会单独定义</div><div class="line">    types: &#123;&#125;,</div><div class="line"></div><div class="line">    // 验证类型所对应的错误消息</div><div class="line">    messages: [],</div><div class="line"></div><div class="line">    // 当然需要使用的验证类型</div><div class="line">    config: &#123;&#125;,</div><div class="line"></div><div class="line">    // 暴露的公开验证方法</div><div class="line">    // 传入的参数是 key =&gt; value对</div><div class="line">    validate: function (data) &#123;</div><div class="line"></div><div class="line">        var i, msg, type, checker, result_ok;</div><div class="line"></div><div class="line">        // 清空所有的错误信息</div><div class="line">        this.messages = [];</div><div class="line"></div><div class="line">        for (i in data) &#123;</div><div class="line">            if (data.hasOwnProperty(i)) &#123;</div><div class="line"></div><div class="line">                type = this.config[i];  // 根据key查询是否有存在的验证规则</div><div class="line">                checker = this.types[type]; // 获取验证规则的验证类</div><div class="line"></div><div class="line">                if (!type) &#123;</div><div class="line">                    continue; // 如果验证规则不存在，则不处理</div><div class="line">                &#125;</div><div class="line">                if (!checker) &#123; // 如果验证规则类不存在，抛出异常</div><div class="line">                    throw &#123;</div><div class="line">                        name: &quot;ValidationError&quot;,</div><div class="line">                        message: &quot;No handler to validate type &quot; + type</div><div class="line">                    &#125;;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证</div><div class="line">                if (!result_ok) &#123;</div><div class="line">                    msg = &quot;Invalid value for *&quot; + i + &quot;*, &quot; + checker.instructions;</div><div class="line">                    this.messages.push(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return this.hasErrors();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // helper</div><div class="line">    hasErrors: function () &#123;</div><div class="line">        return this.messages.length !== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后剩下的工作，就是定义types里存放的各种验证类了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 验证给定的值是否不为空</div><div class="line">validator.types.isNonEmpty = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return value !== &quot;&quot;;</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值不能为空&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否是数字</div><div class="line">validator.types.isNumber = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !isNaN(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能是合法的数字，例如：1, 3.14 or 2010&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否只是字母或数字</div><div class="line">validator.types.isAlphaNum = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !/[^a-z0-9]/i.test(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能保护字母和数字，不能包含特殊字符&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用的时候，我们首先要定义需要验证的数据集合，然后还需要定义每种数据需要验证的规则类型，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var data = &#123;</div><div class="line">    first_name: &quot;Tom&quot;,</div><div class="line">    last_name: &quot;Xu&quot;,</div><div class="line">    age: &quot;unknown&quot;,</div><div class="line">    username: &quot;TomXu&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">validator.config = &#123;</div><div class="line">    first_name: &apos;isNonEmpty&apos;,</div><div class="line">    age: &apos;isNumber&apos;,</div><div class="line">    username: &apos;isAlphaNum&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后，获取验证结果的代码就简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">validator.validate(data);</div><div class="line"></div><div class="line">if (validator.hasErrors()) &#123;</div><div class="line">    console.log(validator.messages.join(&quot;\n&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><p>策略模式是一种常用且有效的设计模式，我们可以总结出策略模式的一些优点：</p>
<ol>
<li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li>
<li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。</li>
<li>策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li>
<li>在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。</li>
</ol>
<p>当然，策略模式也有一些缺点，但这些缺点并不严重。</p>
<p>首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的 逻辑堆砌在 Context 中要好。</p>
<p>其次，要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点， 这样才能选择一个合适的 strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选 择飞机、火车、自行车等方案的细节。此时 strategy 要向客户暴露它的所有实现，这是违反最少 知识原则的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>策略模式定义了一系列算法，从概念上来说，所有的这些算法都是做相同的事情，只是实现不同，他可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合。</p>
<p>从另外一个层面上来说，单独定义算法类，也方便了单元测试，因为可以通过自己的算法进行单独测试。</p>
<p>实践中，不仅可以封装算法，也可以用来封装几乎任何类型的规则，是要在分析过程中需要在不同时间应用不同的业务规则，就可以考虑是要策略模式来处理各种变化。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序设计中，我们也常常遇到这样的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。&lt;br&gt;这些算法灵活多样，而且可以随意互相替换。这种解决方案就是将要介绍的策略模式。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p&gt;
&lt;p&gt;从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="strategy" scheme="http://www.imeetyou.net/tags/strategy/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式(Singleton)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-singleton.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-singleton.html</id>
    <published>2017-03-29T03:36:29.000Z</published>
    <updated>2017-03-29T09:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 开发中，单例模式的用途非常广泛。比如，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式的定义是：<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong></p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>经典Singleton模式的实现方式是，如果实例不存在，通过一个方法创建一个实例。如果已经存在，则返回实例的引用。</p>
<p>Singleton与静态类（对象）不同的是，它可以被延迟生成，只有在需要的时候才会生成实例。</p>
<p>在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var singleton = (function() &#123;</div><div class="line">	var instance;</div><div class="line"></div><div class="line">	function init() &#123;</div><div class="line">		// define private methods and properties</div><div class="line">		// do something</div><div class="line">		return &#123;</div><div class="line">			// define public methods and properties</div><div class="line">			publicMethod: function() &#123;</div><div class="line">				console.log(&apos;hello singleton!&apos;)</div><div class="line">			&#125;,</div><div class="line">			publicProperty: &apos;test&apos;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	return &#123;</div><div class="line">		getInstance: function() &#123;</div><div class="line">			if (!instance) &#123;</div><div class="line">				instance = init()</div><div class="line">			&#125;</div><div class="line">			return instance</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">singleton.getInstance().publicMethod(); // hello singleton!</div><div class="line">console.log(singleton.getInstance().publicProperty); // test</div></pre></td></tr></table></figure>
<h2 id="其它实现方法"><a href="#其它实现方法" class="headerlink" title="其它实现方法"></a>其它实现方法</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 判断是否存在实例</div><div class="line">    if (typeof Universe.instance === &apos;object&apos;) &#123;</div><div class="line">        return Universe.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 缓存</div><div class="line">    Universe.instance = this;</div><div class="line"></div><div class="line">    // 隐式返回this</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni === uni2); // true</div><div class="line">`</div></pre></td></tr></table></figure>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存的实例</div><div class="line">    var instance = this;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 重写构造函数</div><div class="line">    Universe = function () &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">uni.bang = &quot;123&quot;;</div><div class="line">console.log(uni === uni2); // true</div><div class="line">console.log(uni2.bang); // 123</div><div class="line">`</div></pre></td></tr></table></figure>
<h3 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存实例</div><div class="line">    var instance;</div><div class="line"></div><div class="line">    // 重新构造函数</div><div class="line">    Universe = function Universe() &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // 后期处理原型属性</div><div class="line">    Universe.prototype = this;</div><div class="line"></div><div class="line">    // 实例</div><div class="line">    instance = new Universe();</div><div class="line"></div><div class="line">    // 重设构造函数指针</div><div class="line">    instance.constructor = Universe;</div><div class="line"></div><div class="line">    // 其它功能</div><div class="line">    instance.start_time = 0;</div><div class="line">    instance.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    return instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni === uni2); // true</div><div class="line"></div><div class="line">// 添加原型属性</div><div class="line">Universe.prototype.nothing = true;</div><div class="line"></div><div class="line">var uni = new Universe();</div><div class="line"></div><div class="line">Universe.prototype.everything = true;</div><div class="line"></div><div class="line">var uni2 = new Universe();</div><div class="line"></div><div class="line">console.log(uni.nothing); // true</div><div class="line">console.log(uni2.nothing); // true</div><div class="line">console.log(uni.everything); // true</div><div class="line">console.log(uni2.everything); // true</div><div class="line">console.log(uni.constructor === Universe); // true</div></pre></td></tr></table></figure>
<h3 id="方式4"><a href="#方式4" class="headerlink" title="方式4:"></a>方式4:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var Universe;</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line"></div><div class="line">    var instance;</div><div class="line"></div><div class="line">    Universe = function Universe() &#123;</div><div class="line"></div><div class="line">        if (instance) &#123;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        instance = this;</div><div class="line"></div><div class="line">        // 其它内容</div><div class="line">        this.start_time = 0;</div><div class="line">        this.bang = &quot;Big&quot;;</div><div class="line">    &#125;;</div><div class="line">&#125; ());</div><div class="line"></div><div class="line">//测试代码</div><div class="line">var a = new Universe();</div><div class="line">var b = new Universe();</div><div class="line">alert(a === b); // true</div><div class="line">a.bang = &quot;123&quot;;</div><div class="line">alert(b.bang); // 123</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考及引用资料：</p>
<p><a href="https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/singleton.html" target="_blank" rel="external">https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/singleton.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 开发中，单例模式的用途非常广泛。比如，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;单例模式的定义是：&lt;strong&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现方法&quot;&gt;&lt;a href=&quot;#实现方法&quot; class=&quot;headerlink&quot; title=&quot;实现方法&quot;&gt;&lt;/a&gt;实现方法&lt;/h2&gt;&lt;p&gt;经典Singleton模式的实现方式是，如果实例不存在，通过一个方法创建一个实例。如果已经存在，则返回实例的引用。&lt;/p&gt;
&lt;p&gt;Singleton与静态类（对象）不同的是，它可以被延迟生成，只有在需要的时候才会生成实例。&lt;/p&gt;
&lt;p&gt;在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="singleton" scheme="http://www.imeetyou.net/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>Kindle 书籍源下载推荐</title>
    <link href="http://www.imeetyou.net/posts/life/2017/kindle-book.html"/>
    <id>http://www.imeetyou.net/posts/life/2017/kindle-book.html</id>
    <published>2017-03-28T04:35:39.000Z</published>
    <updated>2017-03-28T05:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>近日重拾公司所发kindle，之前一度觉得手机阅读完全可以替代这个产品，但手机看pdf文件，还是不够舒适，虽然是无背光版的，但在上下班路上的几个小时，用kindle阅读一些书籍感觉还是挺不错的，愉快的加入kindle大家庭，多刷秘籍吧。</p>
<h2 id="新手入门介绍"><a href="#新手入门介绍" class="headerlink" title="新手入门介绍"></a>新手入门介绍</h2><p><a href="https://kindlefere.com/" target="_blank" rel="external">Kindle伴侣 为静心阅读而生</a></p>
<p>将近日下载 Kindle 书籍源地址等整理分享一下，也算服务大众吧。</p>
<a id="more"></a>
<h2 id="推送及下载网站"><a href="#推送及下载网站" class="headerlink" title="推送及下载网站"></a>推送及下载网站</h2><p>除了<a href="https://www.amazon.cn/Kindle%E5%85%8D%E8%B4%B9%E7%94%B5%E5%AD%90%E4%B9%A6/b/ref=sa_menu_kindle_l3_b116175071?ie=UTF8&amp;node=116175071" target="_blank" rel="external">亚马逊 Kindle 商店免费电子书</a>,还有很多下载地址， 个人觉得比较方便全面的整理了一下：</p>
<ol>
<li><a href="http://readfree.me/" target="_blank" rel="external">readfree</a> 每日可以下载或推送2个书籍</li>
<li><a href="https://book.90xz.com/" target="_blank" rel="external">90图书网</a> 每日推送一个</li>
<li><a href="http://www.kindlepush.com/main" target="_blank" rel="external">kindle推</a> 普通会员下载4个，推送2个，这个挺不错</li>
<li><a href="http://forfrigg.com/" target="_blank" rel="external">forfrigg</a> 搜索需要科学上网，你懂的</li>
<li><a href="http://mebook.cc/" target="_blank" rel="external">我的小书屋</a> 可直接下载，多格式，图书有简介。</li>
<li><a href="https://www.gitbook.com/explore" target="_blank" rel="external">GitBook</a> 怎能忘了程序员的出书平台呢</li>
</ol>
<h2 id="书籍转换及制作工具"><a href="#书籍转换及制作工具" class="headerlink" title="书籍转换及制作工具"></a>书籍转换及制作工具</h2><ul>
<li>阅读 azw3 用 <a href="http://mac.softpedia.com/get/Utilities/Clearview-Reader.shtml" target="_blank" rel="external">clearview</a></li>
<li>转换格式用 <a href="http://www.calibre-ebook.com/download_osx" target="_blank" rel="external">calibre</a>，很方便将通常pdf格式转换为 azw3 格式</li>
</ul>
<p>更多格式转换技巧查看：<a href="https://kindlefere.com/skills/convert" target="_blank" rel="external">格式转换 – Kindle伴侣</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日重拾公司所发kindle，之前一度觉得手机阅读完全可以替代这个产品，但手机看pdf文件，还是不够舒适，虽然是无背光版的，但在上下班路上的几个小时，用kindle阅读一些书籍感觉还是挺不错的，愉快的加入kindle大家庭，多刷秘籍吧。&lt;/p&gt;
&lt;h2 id=&quot;新手入门介绍&quot;&gt;&lt;a href=&quot;#新手入门介绍&quot; class=&quot;headerlink&quot; title=&quot;新手入门介绍&quot;&gt;&lt;/a&gt;新手入门介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://kindlefere.com/&quot;&gt;Kindle伴侣 为静心阅读而生&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将近日下载 Kindle 书籍源地址等整理分享一下，也算服务大众吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.imeetyou.net/categories/life/"/>
    
    
      <category term="kindle" scheme="http://www.imeetyou.net/tags/kindle/"/>
    
      <category term="life" scheme="http://www.imeetyou.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>typeof与instanceof的区别</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-typeof-instanceof.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-typeof-instanceof.html</id>
    <published>2017-03-26T09:24:36.000Z</published>
    <updated>2017-03-28T08:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>typeof和instanceof都可以用来判断变量，它们的用法有很大区别：</p>
<ul>
<li><strong>typeof：返回一个变量的基本类型，检测的是基本数据类型</strong></li>
<li><strong>instanceof：返回的是一个布尔值，检测的是引用类型</strong></li>
</ul>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(typeof 1); // number</div><div class="line">console.log(typeof &quot;abc&quot;); // string</div><div class="line">console.log(typeof true); // boolean</div><div class="line">console.log(typeof a); // undefined</div><div class="line">console.log(typeof new Object()); // object</div><div class="line">console.log(typeof null); // object</div><div class="line">console.log(typeof []); // object</div></pre></td></tr></table></figure>
<p>可以看到 <code>typeof</code> 无法判断数组、null，不管是数组还是对象，都会返回 object </p>
<p>更多方法具体可查看 <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html" target="_blank" rel="external">《Javascript基础之数组》</a>—数组检测方法</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof返回的是一个布尔值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&#125;;</div><div class="line">console.log(a instanceof Object);  // true</div><div class="line">var b = [];</div><div class="line">console.log(b instanceof Array);  // true</div></pre></td></tr></table></figure>
<p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,所以可以用来判断数组。</p>
<p>需要注意的是，<strong>instanceof只能用来判断对象和函数，不能用来判断字符串和数字等</strong>，如：</p>
<p>```<br>var b = ‘123’;<br>console.log(b instanceof String);  // false<br>console.log(typeof b);  // string</p>
<p>var c = new String(“123”);<br>console.log(c instanceof String);  // true<br>console.log(typeof c);  // object</p>
<p>更多格式转换技巧查看：<a href="https://kindlefere.com/skills/convert" target="_blank" rel="external">格式转换 – Kindle伴侣</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;typeof和instanceof都可以用来判断变量，它们的用法有很大区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;typeof：返回一个变量的基本类型，检测的是基本数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;instanceof：返回的是一个布尔值，检测的是引用类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h2&gt;&lt;p&gt;typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例：&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="typeof" scheme="http://www.imeetyou.net/tags/typeof/"/>
    
      <category term="instanceof" scheme="http://www.imeetyou.net/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>Javascript数组常见问题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-array-issue.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-array-issue.html</id>
    <published>2017-03-23T09:24:23.000Z</published>
    <updated>2017-03-23T08:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、删除数组里指定的某个元素"><a href="#1、删除数组里指定的某个元素" class="headerlink" title="1、删除数组里指定的某个元素"></a>1、删除数组里指定的某个元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var arr = [3,2,3,3,5,3],</div><div class="line">	val = 3;</div><div class="line"></div><div class="line">var removeElement = function(arr, elm) &#123;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		if (arr[i] == elm) &#123;</div><div class="line">			arr.splice(i, 1);</div><div class="line">			i--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(removeElement(arr, val)); // [2, 5]</div></pre></td></tr></table></figure>
<p><strong>注意：这里for循环里的length是动态的，随着splice删除数组元素而变小，这里不能用forEach，因为forEach方法它一开始执行就自动缓存数组的长度，删除数组元素会出现意外。</strong></p>
<a id="more"></a>
<h2 id="2、数组去重的方法"><a href="#2、数组去重的方法" class="headerlink" title="2、数组去重的方法"></a>2、数组去重的方法</h2><h3 id="第一种，双重遍历去重法"><a href="#第一种，双重遍历去重法" class="headerlink" title="第一种，双重遍历去重法"></a>第一种，双重遍历去重法</h3><ol>
<li>构建一个新的数组存放结果</li>
<li>for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比</li>
<li>若结果数组中没有该元素，则存到结果数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 去除数组里的重复元素</div><div class="line">function unique(arr) &#123;</div><div class="line">    var ret = [];</div><div class="line">    var len = arr.length;</div><div class="line">    var isRepeat;</div><div class="line">    for(var i=0; i&lt;len; i++) &#123;</div><div class="line">        isRepeat = false;</div><div class="line">        for(var j=i+1; j&lt;len; j++) &#123;</div><div class="line">            if(arr[i] === arr[j])&#123;</div><div class="line">                isRepeat = true;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(!isRepeat)&#123;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">var arr = [3, 3, 2, 3];</div><div class="line">console.log(unique(arr)); // [2, 3]</div></pre></td></tr></table></figure>
<h3 id="第二种，对象键值对法"><a href="#第二种，对象键值对法" class="headerlink" title="第二种，对象键值对法"></a>第二种，对象键值对法</h3><ol>
<li>创建一个新的数组存放结果</li>
<li>创建一个空对象</li>
<li>for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。</li>
</ol>
<p><strong>说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">	var res = [];</div><div class="line">	var json = &#123;&#125;;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		if (!json[arr[i]]) &#123;</div><div class="line">			res.push(arr[i]);</div><div class="line">			json[arr[i]] = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [3, 3, 2, &quot;3&quot;, &quot;a&quot;, &quot;a&quot;];</div><div class="line">console.log(unique(arr)); // [3, 2, &quot;a&quot;]</div></pre></td></tr></table></figure>
<h3 id="第三种，ES5方法"><a href="#第三种，ES5方法" class="headerlink" title="第三种，ES5方法"></a>第三种，ES5方法</h3><p>利用 ES5 里的方法, indexOf、filter</p>
<p>arr.indexOf(要查找的元素)，返回被找到的元素在数组中的索引位置，如果没有则返回-1。</p>
<p>arr.filter(元素的值，元素的索引，被遍历的数组)，返回一个通过测试的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">  var res = arr.filter(function(item, index, array) &#123;</div><div class="line">    return array.indexOf(item) === index;</div><div class="line">  &#125;);</div><div class="line">  return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 1, &apos;1&apos;, &apos;2&apos;, 1];</div><div class="line">var ans = unique(arr);</div><div class="line">console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</div></pre></td></tr></table></figure>
<h3 id="第四种，ES6方法"><a href="#第四种，ES6方法" class="headerlink" title="第四种，ES6方法"></a>第四种，ES6方法</h3><p>ES6 部署了 Set 以及 Array.from 方法，如果浏览器支持，完全可以这样：</p>
<p>ES2015还引入了一种叫作Set的数据类型，它不允许重复元素出现，如果你重复添加同一个元素的话，Set中只会存在一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">  return Array.from(new Set(arr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 2, &quot;a&quot;, &quot;1&quot;, 2 ,&quot;a&quot;];</div><div class="line">console.log(unique(arr)) // [1, 2, &quot;a&quot;, &quot;1&quot;]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>关于数组去重更多详细方法参看</p>
<p><a href="https://github.com/hanzichi/underscore-analysis/issues/9" target="_blank" rel="external">JavaScript 数组去重</a></p>
<p><a href="http://www.jstips.co/zh_cn/deduplicate-an-array/" target="_blank" rel="external">数组去重 – JS Tips – A JS tip per day!</a></p>
<p><a href="http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array" target="_blank" rel="external">Remove Duplicates from JavaScript Array</a></p>
<p><a href="https://github.com/lifesinger/blog/issues/113" target="_blank" rel="external">从 JavaScript 数组去重谈性能优化</a></p>
<p><a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank" rel="external">也谈 JavaScript 数组去重</a></p>
</blockquote>
<h2 id="3、取数组中最大值最小值"><a href="#3、取数组中最大值最小值" class="headerlink" title="3、取数组中最大值最小值"></a>3、取数组中最大值最小值</h2><h3 id="遍历比较方法"><a href="#遍历比较方法" class="headerlink" title="遍历比较方法"></a>遍历比较方法</h3><ol>
<li>设一个变量存放最大值，将数组中第一个值赋值给该变量</li>
<li>遍历数组与最大值变量比较，如果大于最大值，则将该值赋值最大值变量</li>
<li>遍历结束后，变量里储存的就是数组里的最大值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function arrayMax(arr) &#123;</div><div class="line">   var max = arr[0];</div><div class="line">   arr.forEach(function(v)&#123;</div><div class="line">   	  if(v &gt; max) &#123;</div><div class="line">	     max = v</div><div class="line">      &#125;</div><div class="line">   &#125;)</div><div class="line">   return max;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(arrayMax(arr)); // 45</div></pre></td></tr></table></figure>
<h3 id="利用-Math-max-与-Math-min-方法"><a href="#利用-Math-max-与-Math-min-方法" class="headerlink" title="利用 Math.max() 与 Math.min() 方法"></a>利用 Math.max() 与 Math.min() 方法</h3><p>将数组转换成参数传进Math.max()或Math.min()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function max(arr) &#123;</div><div class="line">  return Math.max.apply(&#123;&#125;,arr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(max(arr)); // 45</div></pre></td></tr></table></figure>
<h3 id="ES5方法"><a href="#ES5方法" class="headerlink" title="ES5方法"></a>ES5方法</h3><ol>
<li>利用数组实例的 reduce(function(prev,curv,index,arr))  方法</li>
<li>依次比较回调函数中参数 prev 与 curv 的大小，返回大的那个</li>
</ol>
<p><strong>reduce(function(上一次调用回调返回的值, 数组中正在处理的元素, 当前元素索引, 调用reduce的数组))</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function max(arr) &#123;</div><div class="line">  return arr.reduce(function(prev,curv)&#123;</div><div class="line">      return prev &gt; curv ? prev : curv</div><div class="line">  &#125;) </div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(max(arr)); // 45</div></pre></td></tr></table></figure>
<h2 id="4、多维数组扁平化"><a href="#4、多维数组扁平化" class="headerlink" title="4、多维数组扁平化"></a>4、多维数组扁平化</h2><p>将多维数组”拍平”</p>
<p>将下列数组转为单一数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div></pre></td></tr></table></figure>
<h3 id="1、双层遍历法"><a href="#1、双层遍历法" class="headerlink" title="1、双层遍历法"></a>1、双层遍历法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [];</div><div class="line">for (var i = 0; i &lt; myArray.length; ++i) &#123;</div><div class="line">  for (var j = 0; j &lt; myArray[i].length; ++j)</div><div class="line">    newArray.push(myArray[i][j]);</div><div class="line">&#125;</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="2、使用concat-和apply"><a href="#2、使用concat-和apply" class="headerlink" title="2、使用concat()和apply()"></a>2、使用concat()和apply()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [].concat.apply([], myArray);</div><div class="line"></div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="3、使用reduce"><a href="#3、使用reduce" class="headerlink" title="3、使用reduce()"></a>3、使用reduce()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = myArray.reduce(function(prev, curr) &#123;</div><div class="line">  return prev.concat(curr);</div><div class="line">&#125;);</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="4、使用-ES6-的展开运算符"><a href="#4、使用-ES6-的展开运算符" class="headerlink" title="4、使用 ES6 的展开运算符"></a>4、使用 ES6 的展开运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [].concat(...myArray);</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>引用参考列表</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN 的 JavaScript 标准库 Array 部分</a></p>
<p><a href="http://www.jstips.co/zh_CN/" target="_blank" rel="external">Js Tips</a></p>
<p><a href="http://www.ferecord.com/lujs-array.html#_13" target="_blank" rel="external">撸js基础之数组</a></p>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-issue.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-array-issue.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、删除数组里指定的某个元素&quot;&gt;&lt;a href=&quot;#1、删除数组里指定的某个元素&quot; class=&quot;headerlink&quot; title=&quot;1、删除数组里指定的某个元素&quot;&gt;&lt;/a&gt;1、删除数组里指定的某个元素&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = [3,2,3,3,5,3],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	val = 3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var removeElement = function(arr, elm) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (var i = 0; i &amp;lt; arr.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (arr[i] == elm) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			arr.splice(i, 1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			i--;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	return arr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(removeElement(arr, val)); // [2, 5]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：这里for循环里的length是动态的，随着splice删除数组元素而变小，这里不能用forEach，因为forEach方法它一开始执行就自动缓存数组的长度，删除数组元素会出现意外。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="array" scheme="http://www.imeetyou.net/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-class3.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-class3.html</id>
    <published>2017-03-23T01:22:23.000Z</published>
    <updated>2017-03-23T01:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。</p>
<p>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</p>
<h2 id="1、构造函数法"><a href="#1、构造函数法" class="headerlink" title="1、构造函数法"></a>1、构造函数法</h2><p>第一种是经典方法，它用构造函数模拟”类”，在其内部用this关键字指代实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Dog() &#123;</div><div class="line">　　this.name = &quot;旺财&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成实例的时候，使用new关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dog = new Dog();</div><div class="line">console.log(dog.name); // 旺财</div></pre></td></tr></table></figure>
<p>类的属性和方法，还可以定义在构造函数的prototype对象之上。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Dog.prototype.wow = function()&#123;</div><div class="line">　 console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于这种方法的详细介绍，请看《Javascript 面向对象编程》，这里就不多说了。</p>
<p>它的主要缺点是，比较复杂，用到了this和prototype，编写和阅读都很费力。</p>
<h2 id="2、Object-create-法"><a href="#2、Object-create-法" class="headerlink" title="2、Object.create()法"></a>2、Object.create()法</h2><p>在ECM5中，加入一个新的方法 <code>Object.create()</code>,用这个方法，”类”就是一个对象，不是函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">	this.name = &quot;旺财&quot;;</div><div class="line">    wow: function() &#123;</div><div class="line">		console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，直接用Object.create()生成实例，不需要用到new。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dog = Object.create(Dog);</div><div class="line">console.log(dog.name); // 旺财</div><div class="line">dog.wow(); // 汪～汪～汪！</div></pre></td></tr></table></figure>
<p>这种方法不能实现私有属性和私有方法，实例对象之间也不能共享数据。</p>
<h2 id="3、BlackScript-法"><a href="#3、BlackScript-法" class="headerlink" title="3、BlackScript 法"></a>3、BlackScript 法</h2><p>荷兰程序员Gabor de Mooij提出了一种比Object.create()更好的<a href="http://www.gabordemooij.com/index.php?p=/blackscript" target="_blank" rel="external">新方法</a>。</p>
<p>事实上就是用一个对象模拟类，在这个类里，定义一个构造函数 createNew() 用来生成实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      //some code</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在 createNew() 里面，定义一个实例对象，把这个实例对象作为返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.wow(); // 汪～汪～汪！</div></pre></td></tr></table></figure>
<p>这种方法简单易学，可以实现OOP的特性，继承、私有属性和方法、数据共享。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>比如让 Dog 继承 Animal,只要在 Dog的 createNew()方法中，调用后者的createNew()方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Animal = &#123;</div><div class="line">　　　　createNew: function()&#123;</div><div class="line">　　　　　　var animal = &#123;&#125;;</div><div class="line">　　　　　　animal.sleep = function()&#123; </div><div class="line">				console.log(&quot;睡懒觉&quot;);</div><div class="line">		  &#125;;</div><div class="line">　　　　　　return animal;</div><div class="line">　　　　&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后，在 Dog 的 createNew() 方法中，调用 Animal 的 createNew() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = Animal.createNew();</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样得到的 Dog 实例，就会同时继承 Dog 类和Animal类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.sleep() // 睡懒觉 </div><div class="line">dog1.wow() // 汪～汪～汪！</div></pre></td></tr></table></figure>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>在 createNew() 方法中，只要不是定义在 dog 对象上的方法和属性，都是私有的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">      var sound = &quot;汪汪汪&quot;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(sound);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上例的内部变量 sound，外部无法读取，只有通过 dog 的公有方法 wow() 来读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.name // 旺财</div><div class="line">dog1.sound // undefined </div><div class="line">dog1.wow() // 汪汪汪</div></pre></td></tr></table></figure>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>有时候，我们需要所有实例对象，能够读写同一项内部数据。</p>
<p>这个时候，只要把这个内部数据，封装在类对象的里面、createNew()方法的外面即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   sound: &quot;汪汪汪&quot;,</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.sound = function() &#123;</div><div class="line">         console.log(Dog.sound);</div><div class="line">      &#125;</div><div class="line">      dog.changSound = function(para)&#123;</div><div class="line">         Dog.sound = para</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>生成两个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">var dog2 = Dog.createNew();</div><div class="line">dog1.sound(); // 汪汪汪</div><div class="line">dog2.sound(); // 汪汪汪</div></pre></td></tr></table></figure>
<p>这时，如果有一个实例对象，修改了共享的数据，另一个实例对象也会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dog2.changSound(&quot;呱呱呱&quot;);</div><div class="line">dog1.sound(); // 呱呱呱</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文转载引用自 <a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="external">Javascript定义类（class）的三种方法</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。&lt;/p&gt;
&lt;p&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/p&gt;
&lt;h2 id=&quot;1、构造函数法&quot;&gt;&lt;a href=&quot;#1、构造函数法&quot; class=&quot;headerlink&quot; title=&quot;1、构造函数法&quot;&gt;&lt;/a&gt;1、构造函数法&lt;/h2&gt;&lt;p&gt;第一种是经典方法，它用构造函数模拟”类”，在其内部用this关键字指代实例对象。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Dog() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　this.name = &amp;quot;旺财&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成实例的时候，使用new关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var dog = new Dog();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(dog.name); // 旺财&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类的属性和方法，还可以定义在构造函数的prototype对象之上。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="class" scheme="http://www.imeetyou.net/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基础之数组</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-array-base.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-array-base.html</id>
    <published>2017-03-22T03:34:42.000Z</published>
    <updated>2017-03-22T08:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。</p>
<h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><ul>
<li>constructor 表示引用数组对象的构造函数</li>
<li>length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。</li>
<li>prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="一、创建方法"><a href="#一、创建方法" class="headerlink" title="一、创建方法"></a>一、创建方法</h3><h4 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">var arr = new Array(); // 创建一个空数组</div><div class="line">`</div></pre></td></tr></table></figure>
<h4 id="创建一个指定长度的数组"><a href="#创建一个指定长度的数组" class="headerlink" title="创建一个指定长度的数组"></a>创建一个指定长度的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array(size) // size 表示数组的长度</div></pre></td></tr></table></figure>
<h4 id="创建一个指定元素的数组"><a href="#创建一个指定元素的数组" class="headerlink" title="创建一个指定元素的数组"></a>创建一个指定元素的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、检测方法"><a href="#二、检测方法" class="headerlink" title="二、检测方法"></a>二、检测方法</h3><h4 id="1、利用-instanceof-操作符"><a href="#1、利用-instanceof-操作符" class="headerlink" title="1、利用 instanceof 操作符"></a>1、利用 instanceof 操作符</h4><p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(arr instanceof Array) // true</div></pre></td></tr></table></figure>
<h4 id="2、通过对象自身的-constructor-属性"><a href="#2、通过对象自身的-constructor-属性" class="headerlink" title="2、通过对象自身的 constructor 属性"></a>2、通过对象自身的 constructor 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(arr.constructor === Array) // true</div></pre></td></tr></table></figure>
<p><strong>跨frame实例化对象带来的问题</strong></p>
<p><code>constructor</code> 和 <code>instanceof</code> 貌似很好的两个检测数组的方法，但实际上还是有些漏洞的，当你在多个frame中回来跳的时候，这两种方法就惨了。</p>
<p>由于每一个frame都有自己的一套执行环境，跨frame实例化的对象彼此并不共享原型链，通过 <code>instanceof</code> 操作符和 <code>constructor</code> 属性检测的方法自然会失败。</p>
<p>那么第三种方法就比较好了，如下</p>
<h4 id="3、对象原生toString检测"><a href="#3、对象原生toString检测" class="headerlink" title="3、对象原生toString检测"></a>3、对象原生toString检测</h4><p><code>Object.prototype.toString</code> 的行为：首先，取得对象的一个内部属性 [[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //true</div></pre></td></tr></table></figure>
<p>可以将判断方法封装一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function isArray(obj) &#123;</div><div class="line">   return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</div><div class="line">&#125;</div><div class="line">var arr =[1,2,3];</div><div class="line">console.log(isArray(arr)); // true</div></pre></td></tr></table></figure>
<h4 id="4、ECMAScript-5的isArray函数"><a href="#4、ECMAScript-5的isArray函数" class="headerlink" title="4、ECMAScript 5的isArray函数"></a>4、ECMAScript 5的isArray函数</h4><p>为了让数组检测更方便，ECMAScript5新增了Array.isArray()方法。该方法的目的是最终确定某个值到底是不是数组，而不管它在哪个全局环境中创建的。</p>
<p><strong>注：此方法在IE8之前的版本是不支持的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(Array.isArray(arr)); // true</div></pre></td></tr></table></figure>
<h2 id="ECM3方法"><a href="#ECM3方法" class="headerlink" title="ECM3方法"></a>ECM3方法</h2><h3 id="1、Array-prototype-join"><a href="#1、Array-prototype-join" class="headerlink" title="1、Array.prototype.join()"></a>1、Array.prototype.join()</h3><p><code>join()</code> 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。此方法不会改变原数组。也就是说所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。</p>
<p><code>arr.join(separator)</code> 参数 <code>separator</code></p>
<ul>
<li>指定一个字符串来分隔数组的每个元素</li>
<li>如果省略()，数组元素用逗号分隔。默认为 “,”</li>
<li>如果separator是空字符串(“”)，则所有元素之间都没有任何字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a1&apos;, &apos;b2&apos;, &apos;c3&apos;];</div><div class="line">var myArr1 = arr.join();</div><div class="line">var myArr2 = arr.join(&apos;, &apos;);</div><div class="line">var myArr3 = arr.join(&apos; + &apos;);</div><div class="line">var myArr4 = arr.join(&apos;&apos;);</div><div class="line"></div><div class="line">console.log(myArr1);  // a1,b2,c3</div><div class="line">console.log(myArr2);  // a1, b2, c3</div><div class="line">console.log(myArr3);  // a1 + b2 + c3</div><div class="line">console.log(myArr4);  // a1b2c3</div></pre></td></tr></table></figure>
<h3 id="2、Array-prototype-push"><a href="#2、Array-prototype-push" class="headerlink" title="2、Array.prototype.push()"></a>2、Array.prototype.push()</h3><p>push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。</p>
<p><strong>添加元素：</strong>可以添加新的元素到数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 添加元素</div><div class="line">var letter = [&quot;a&quot;, &quot;b&quot;];</div><div class="line">var total = letter.push(&quot;c&quot;,&quot;d&quot;);</div><div class="line">console.log(total); // 4</div><div class="line">console.log(letter); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</div></pre></td></tr></table></figure>
<p><strong>合并数组</strong>：可以使用 apply() 添加第二个数组的所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 合并数组</div><div class="line">var arr1 = [1, 2];</div><div class="line">var arr2 = [&quot;a&quot;, &quot;b&quot;];</div><div class="line"></div><div class="line">// 将第二个数组融合进第一个数组</div><div class="line">// 相当于 arr1.push(&apos;a&apos;, &apos;b&apos;);</div><div class="line">Array.prototype.push.apply(arr1, arr2);</div><div class="line"></div><div class="line">console.log(arr1); // [1, 2, &quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure>
<h3 id="3、Array-prototype-pop"><a href="#3、Array-prototype-pop" class="headerlink" title="3、Array.prototype.pop()"></a>3、Array.prototype.pop()</h3><p>pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<p>如果你在一个空数组上调用 pop()，它返回  undefined。</p>
<h3 id="4、Array-prototype-unshift"><a href="#4、Array-prototype-unshift" class="headerlink" title="4、Array.prototype.unshift()"></a>4、Array.prototype.unshift()</h3><p>unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2];</div><div class="line"></div><div class="line">arr.unshift(0);</div><div class="line">//arr is [0, 1, 2]</div><div class="line"></div><div class="line">arr.unshift(-2, -1); // = 5</div><div class="line">//arr is [-2, -1, 0, 1, 2]</div><div class="line"></div><div class="line">arr.unshift( [-3] );</div><div class="line">//arr is [[-3], -2, -1, 0, 1, 2]</div></pre></td></tr></table></figure>
<h3 id="5、Array-prototype-shift"><a href="#5、Array-prototype-shift" class="headerlink" title="5、Array.prototype.shift()"></a>5、Array.prototype.shift()</h3><p>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;surgeon&apos;];</div><div class="line"></div><div class="line">console.log(&apos;调用 shift 之前: &apos; + myFish);</div><div class="line">// &quot;调用 shift 之前: angel,clown,mandarin,surgeon&quot;</div><div class="line"></div><div class="line">var shifted = myFish.shift();</div><div class="line"></div><div class="line">console.log(&apos;调用 shift 之后: &apos; + myFish);</div><div class="line">// &quot;调用 shift 之后: clown,mandarin,surgeon&quot;</div><div class="line"></div><div class="line">console.log(&apos;被删除的元素: &apos; + shifted);</div><div class="line">// &quot;被删除的元素: angel&quot;</div></pre></td></tr></table></figure>
<h3 id="6、Array-prototype-sort"><a href="#6、Array-prototype-sort" class="headerlink" title="6、Array.prototype.sort()"></a>6、Array.prototype.sort()</h3><p>sort(compareFunction) 方法在适当的位置对数组的元素进行排序，并返回数组。</p>
<p>sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。</p>
<p>一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数:</p>
<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</li>
<li>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [4, 2, 5, 1, 3];</div><div class="line">numbers.sort(function(a, b) &#123;</div><div class="line">  return a - b;</div><div class="line">&#125;);</div><div class="line">console.log(numbers); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h3 id="7、Array-prototype-reverse"><a href="#7、Array-prototype-reverse" class="headerlink" title="7、Array.prototype.reverse()"></a>7、Array.prototype.reverse()</h3><p>reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。</p>
<p>下例将会创建一个数组 myArray，其包含三个元素，然后颠倒该数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">myArray.reverse();</div><div class="line">console.log(myArray);  // [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</div></pre></td></tr></table></figure>
<h3 id="8、Array-prototype-concat"><a href="#8、Array-prototype-concat" class="headerlink" title="8、Array.prototype.concat()"></a>8、Array.prototype.concat()</h3><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</div><div class="line">var arr2 = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</div><div class="line"></div><div class="line">var arr3 = arr1.concat(arr2);</div><div class="line"></div><div class="line">console.log(arr3);</div><div class="line">// 返回结果是一个新数组</div><div class="line">// [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</div><div class="line"></div><div class="line">// 原数组没有改变</div><div class="line">console.log(arr1); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">console.log(arr2); // [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</div></pre></td></tr></table></figure>
<h3 id="9、Array-prototype-slice"><a href="#9、Array-prototype-slice" class="headerlink" title="9、Array.prototype.slice()"></a>9、Array.prototype.slice()</h3><p><code>slice(start, end)</code> 方法将数组的一部分浅拷贝, 返回到从开始到结束（不包括结束）选择的新数组对象。原始数组不会被修改。</p>
<ul>
<li>slice()</li>
<li>slice(start)</li>
<li>slice(start,end)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;];</div><div class="line"></div><div class="line">//如果不传参数，表示从数组0开始到到end（包含end）</div><div class="line">var newArr1 = arr.slice();</div><div class="line">console.log(newArr1)  // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div><div class="line"></div><div class="line">//如果省略 end，则表示从start开始到end（包含end）</div><div class="line">var newArr2 = arr.slice(1);</div><div class="line">console.log(newArr2) // [&quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div><div class="line"></div><div class="line">//如果传人star、end，则表示从start到end不包含end</div><div class="line">var newArr3 = arr.slice(1, 3);</div><div class="line">console.log(newArr3) // [&quot;two&quot;, &quot;three&quot;]</div><div class="line"></div><div class="line">console.log(arr)    // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div></pre></td></tr></table></figure>
<h3 id="10、Array-prototype-splice"><a href="#10、Array-prototype-splice" class="headerlink" title="10、Array.prototype.splice()"></a>10、Array.prototype.splice()</h3><p>splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。</p>
<p><strong>注意：splice 方法直接更改原数组内容</strong></p>
<ul>
<li>array.splice(start)</li>
<li>array.splice(start, deleteCount)</li>
<li>array.splice(start, deleteCount, item1, item2, …)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];</div><div class="line"></div><div class="line">//从第 2 位开始删除 0 个元素，插入 &quot;drum&quot;</div><div class="line">var removed = myFish.splice(2, 0, &quot;drum&quot;);</div><div class="line">console.log(myFish);</div><div class="line">//运算后的 myFish:[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[]，没有元素被删除</div><div class="line"></div><div class="line">//从第 3 位开始删除 1 个元素</div><div class="line">removed = myFish.splice(3, 1);</div><div class="line">//运算后的myFish：[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[&quot;mandarin&quot;]</div><div class="line"></div><div class="line">//从第 2 位开始删除 1 个元素，然后插入 &quot;trumpet&quot;</div><div class="line">removed = myFish.splice(2, 1, &quot;trumpet&quot;);</div><div class="line">//运算后的myFish: [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[&quot;drum&quot;]</div><div class="line"></div><div class="line">//从第 0 位开始删除 2 个元素，然后插入 &quot;parrot&quot;, &quot;anemone&quot; 和 &quot;blue&quot;</div><div class="line">removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;);</div><div class="line">//运算后的myFish：[&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素的数组：[&quot;angel&quot;, &quot;clown&quot;]</div><div class="line"></div><div class="line">//从第 3 位开始删除 2 个元素</div><div class="line">removed = myFish.splice(3, Number.MAX_VALUE);</div><div class="line">//运算后的myFish: [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;]</div><div class="line">//被删除元素的数组：[&quot;trumpet&quot;, &quot;surgeon&quot;]</div></pre></td></tr></table></figure>
<hr>
<h2 id="ECM5方法"><a href="#ECM5方法" class="headerlink" title="ECM5方法"></a>ECM5方法</h2><h3 id="1、Array-prototype-indexOf"><a href="#1、Array-prototype-indexOf" class="headerlink" title="1、Array.prototype.indexOf()"></a>1、Array.prototype.indexOf()</h3><p>indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [2, 6, 9, 6];</div><div class="line"></div><div class="line">a.indexOf(2); // 0</div><div class="line">a.indexOf(7); // -1 不存在</div><div class="line">a.indexOf(6); // 1 返回指定元素的第一个索引值</div></pre></td></tr></table></figure>
<p><strong>找出指定元素出现的所有位置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 找出 a 在 array 里的所有位置</div><div class="line">var str = &apos;a&apos;;</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;a&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line"></div><div class="line">var indices = [];</div><div class="line">var idx = array.indexOf(str);</div><div class="line"></div><div class="line">while (idx != -1) &#123;</div><div class="line">  indices.push(idx);</div><div class="line">  idx = array.indexOf(str, idx + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(indices);</div><div class="line">// [0, 2, 4]</div></pre></td></tr></table></figure>
<h3 id="2、Array-prototype-lastIndexOf"><a href="#2、Array-prototype-lastIndexOf" class="headerlink" title="2、Array.prototype.lastIndexOf()"></a>2、Array.prototype.lastIndexOf()</h3><p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</div></pre></td></tr></table></figure>
<p><strong>定位数组中的值：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9, 2];</div><div class="line">var index = array.lastIndexOf(2);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(7);</div><div class="line">// index is -1</div><div class="line">index = array.lastIndexOf(2, 3);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(2, 2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -1);</div><div class="line">// index is 3</div></pre></td></tr></table></figure>
<p><strong>查找所有元素</strong></p>
<p>下例使用 lastIndexOf 查找到一个元素在数组中所有的索引（下标），并使用 push 将所有添加到另一个数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var element = &apos;a&apos;;</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;a&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line">var indices = [];</div><div class="line">var idx = array.lastIndexOf(element);</div><div class="line"></div><div class="line">while (idx != -1) &#123;</div><div class="line">  indices.push(idx);</div><div class="line">  idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(indices);</div><div class="line">// [4, 2, 0];</div></pre></td></tr></table></figure>
<h3 id="3、Array-prototype-every"><a href="#3、Array-prototype-every" class="headerlink" title="3、Array.prototype.every()"></a>3、Array.prototype.every()</h3><p>every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>
<p>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</p>
<p>如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。</p>
<p>every 不会改变原数组。</p>
<p>every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。</p>
<p><strong>检测所有数组元素的大小</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [12, 5, 8, 130, 44].every(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 54, 18, 130, 44].every(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
<h3 id="4、Array-prototype-some"><a href="#4、Array-prototype-some" class="headerlink" title="4、Array.prototype.some()"></a>4、Array.prototype.some()</h3><p>some() 方法测试数组中的某些元素是否通过了指定函数的测试。</p>
<p>some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p>callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.some(callback[, thisArg])</div></pre></td></tr></table></figure>
<p>如果为 some 提供了一个 thisArg 参数，将会把它传给被调用的 callback，作为 this 值。否则，在非严格模式下将会是全局对象，严格模式下是 undefined。</p>
<p>some 被调用时不会改变数组。</p>
<p><strong>测试数组元素的值</strong></p>
<p>下面的例子检测在数组中是否有元素大于 10。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [2, 5, 8, 1, 4].some(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 5, 8, 1, 4].some(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
<h3 id="5、Array-prototype-filter"><a href="#5、Array-prototype-filter" class="headerlink" title="5、Array.prototype.filter()"></a>5、Array.prototype.filter()</h3><p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<p>对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var new_array = arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>
<p><strong>筛选排除掉所有的小值</strong></p>
<p>下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(value) &#123;</div><div class="line">  return value &gt;= 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);</div><div class="line">// filtered is [12, 130, 44]</div></pre></td></tr></table></figure>
<h3 id="6、Array-prototype-map"><a href="#6、Array-prototype-map" class="headerlink" title="6、Array.prototype.map()"></a>6、Array.prototype.map()</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数，<strong>返回这个新数组</strong>。</p>
<p><strong>求数组中每个元素的平方根</strong></p>
<p>下面的代码创建了一个新数组，值为原数组中对应数字的平方根。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 4, 9];</div><div class="line">var roots = numbers.map(Math.sqrt);</div><div class="line">/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */</div></pre></td></tr></table></figure>
<p><strong>问答题</strong></p>
<p>问题：<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt)</code> 答案是多少？</p>
<p>答案是<code>[1,NaN,NaN]</code></p>
<h3 id="7、Array-prototype-forEach"><a href="#7、Array-prototype-forEach" class="headerlink" title="7、Array.prototype.forEach()"></a>7、Array.prototype.forEach()</h3><p>forEach() 方法对数组的每个元素执行一次提供的函数。</p>
<p>对数组中的每一项运行给定函数，这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, this)</div></pre></td></tr></table></figure>
<ul>
<li>currentValue(当前值) 数组中正在处理的当前元素。</li>
<li>index(索引) 数组中正在处理的当前元素的索引。</li>
<li>array forEach()方法正在操作的数组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr=[2, 4, 5];</div><div class="line">arr.forEach(function(elm,index, array) &#123;</div><div class="line">   console.log(index, elm);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 0 2</div><div class="line">// 1 4</div><div class="line">// 2 5</div></pre></td></tr></table></figure>
<h3 id="8、Array-prototype-reduce"><a href="#8、Array-prototype-reduce" class="headerlink" title="8、Array.prototype.reduce()"></a>8、Array.prototype.reduce()</h3><p>reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<p><strong>将数组所有项相加</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var sum = [0, 1, 2, 3].reduce(function(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;, 0);</div><div class="line">// sum is 6</div></pre></td></tr></table></figure>
<p><strong>数组扁平化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</div><div class="line">    return a.concat(b);</div><div class="line">&#125;, []);</div><div class="line">// flattened is [0, 1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h3 id="9、Array-prototype-reduceRight"><a href="#9、Array-prototype-reduceRight" class="headerlink" title="9、Array.prototype.reduceRight()"></a>9、Array.prototype.reduceRight()</h3><p>reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(function(a, b) &#123;</div><div class="line">    return a.concat(b);</div><div class="line">&#125;, []);</div><div class="line"></div><div class="line">// flattened is [4, 5, 2, 3, 0, 1]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文主要内容引用：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN 的 JavaScript 标准库 Array 部分</a></li>
<li><a href="http://www.w3cplus.com/" target="_blank" rel="external">W3cplus 博客</a></li>
</ul>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-array-base.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。&lt;/p&gt;
&lt;h2 id=&quot;数组属性&quot;&gt;&lt;a href=&quot;#数组属性&quot; class=&quot;headerlink&quot; title=&quot;数组属性&quot;&gt;&lt;/a&gt;数组属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;constructor 表示引用数组对象的构造函数&lt;/li&gt;
&lt;li&gt;length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。&lt;/li&gt;
&lt;li&gt;prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&quot;一、创建方法&quot;&gt;&lt;a href=&quot;#一、创建方法&quot; class=&quot;headerlink&quot; title=&quot;一、创建方法&quot;&gt;&lt;/a&gt;一、创建方法&lt;/h3&gt;&lt;h4 id=&quot;创建一个空数组&quot;&gt;&lt;a href=&quot;#创建一个空数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个空数组&quot;&gt;&lt;/a&gt;创建一个空数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(); // 创建一个空数组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;`&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;创建一个指定长度的数组&quot;&gt;&lt;a href=&quot;#创建一个指定长度的数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个指定长度的数组&quot;&gt;&lt;/a&gt;创建一个指定长度的数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(size) // size 表示数组的长度&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;创建一个指定元素的数组&quot;&gt;&lt;a href=&quot;#创建一个指定元素的数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个指定元素的数组&quot;&gt;&lt;/a&gt;创建一个指定元素的数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="array" scheme="http://www.imeetyou.net/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 面向对象编程详解</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-oop.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-oop.html</id>
    <published>2017-03-18T10:25:34.000Z</published>
    <updated>2017-03-23T01:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript是一种基于对象的语言，秉承一切皆对象的理念。</p>
<p>但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态</p>
<p>那么如何用 Javascript 来实现面向对象编程呢</p>
<h1 id="1、利用Prototype模式实现封装"><a href="#1、利用Prototype模式实现封装" class="headerlink" title="1、利用Prototype模式实现封装"></a>1、利用Prototype模式实现封装</h1><p>在Javascript里每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这样，我们把那些不变的属性和方法，直接定义在<code>prototype</code>对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.legs = 2</div><div class="line">Person.prototype.speak = function() &#123;</div><div class="line">	console.log(&quot;我的名字是：&quot; + this.name + &quot;，年龄：&quot; + this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，生成实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var jack = new Person(&quot;jack&quot;, 26);</div><div class="line">var lily = new Person(&quot;lily&quot;, 25);</div><div class="line"></div><div class="line">jack.legs; // 2</div><div class="line">lily.speak() // 我的名字是：lily，年龄：25</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2、实现构造函数继承的五种方法"><a href="#2、实现构造函数继承的五种方法" class="headerlink" title="2、实现构造函数继承的五种方法"></a>2、实现构造函数继承的五种方法</h1><p>举例，有一个水果的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有个“苹果”的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>怎么使得 <code>Apple</code> 继承 <code>Fruit</code> 呢？</p>
<h2 id="第一种，使用call-apply，构造函数绑定"><a href="#第一种，使用call-apply，构造函数绑定" class="headerlink" title="第一种，使用call/apply，构造函数绑定"></a>第一种，使用call/apply，构造函数绑定</h2><p>如题，使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name,color) &#123;</div><div class="line">	Fruit.apply(this, arguments); // 这里用call也可以</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new Apple(&quot;苹果&quot;, &quot;红色&quot;);</div><div class="line">console.log(a.type) // 水果</div></pre></td></tr></table></figure>
<h2 id="第二种，-使用prototype属性继承"><a href="#第二种，-使用prototype属性继承" class="headerlink" title="第二种， 使用prototype属性继承"></a>第二种， 使用prototype属性继承</h2><p>第二种方法比较常见，使用prototype属性。</p>
<p>如果水果的prototype对象，指向一个Fruit的实例，那么所有”水果”的实例，就能继承Fruit了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将 Apple 的 prototype 对象指向 Fruit实例</div><div class="line">Apple.prototype = new Fruit();</div><div class="line">// 将 Apple 的 prototype 对象的构造函数指回原来的构造函数</div><div class="line">Apple.prototype.constructor = Apple;</div><div class="line"></div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<h2 id="第三种-直接继承prototype"><a href="#第三种-直接继承prototype" class="headerlink" title="第三种 直接继承prototype"></a>第三种 直接继承prototype</h2><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Apple()跳过 Fruit()，直接继承Fruit.prototype。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Apple.prototype = Fruit.prototype;</div><div class="line">Apple.prototype.constructor = Apple; //</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Fruit的实例了），比较省内存。缺点是 <code>Apple.prototype</code>和<code>Fruit.prototype</code>现在指向了同一个对象，那么任何对<code>Apple.prototype</code>的修改，都会反映到<code>Fruit.prototype</code>。</p>
<p>所以，上面这一段代码其实是有问题的。请看第二行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Apple.prototype.constructor = Apple;</div></pre></td></tr></table></figure>
<p>这一句实际上把 <code>Fruit.prototype</code> 对象的 <code>constructor</code> 属性也改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Fruit.prototype.constructor); // Apple</div></pre></td></tr></table></figure>
<h2 id="第四种，-利用空对象作为中介"><a href="#第四种，-利用空对象作为中介" class="headerlink" title="第四种， 利用空对象作为中介"></a>第四种， 利用空对象作为中介</h2><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var F = function()&#123;&#125;;</div><div class="line">F.prototype = Fruit.prototype;</div><div class="line">Apple.prototype = new F();</div><div class="line">Apple.prototype.constructor = Apple;</div><div class="line"></div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>##第五种， 拷贝继承</p>
<p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p>
<p>写一个函数，实现属性拷贝的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extend2(Child, Parent) &#123;</div><div class="line">　　var p = Parent.prototype;</div><div class="line">　　var c = Child.prototype;</div><div class="line">　  for (var i in p) &#123;</div><div class="line">　　　　	c[i] = p[i];</div><div class="line">　　&#125;</div><div class="line">　　c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父对象的 prototype 对象中的属性，一一拷贝给 Child 对象的 prototype 对象。</p>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend2(Apple, Fruit);</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<h1 id="3、不使用构造函数实现”继承”的方法"><a href="#3、不使用构造函数实现”继承”的方法" class="headerlink" title="3、不使用构造函数实现”继承”的方法"></a>3、不使用构造函数实现”继承”的方法</h1><p><strong>什么是”非构造函数”的继承？</strong></p>
<p>比如，现在有一个对象，叫做”中国人”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>还有一个对象，叫做”医生”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor =&#123;</div><div class="line">　　career:&apos;医生&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<h3 id="第一种-object-方法"><a href="#第一种-object-方法" class="headerlink" title="第一种 object()方法"></a>第一种 object()方法</h3><p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">　　function F() &#123;&#125;</div><div class="line">　　F.prototype = o;</div><div class="line">　　return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = object(Chinese);</div></pre></td></tr></table></figure>
<p>然后，再加上子对象本身的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.career = &apos;医生&apos;;</div></pre></td></tr></table></figure>
<p>这时，子对象已经继承了父对象的属性了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Doctor =&#123;</div><div class="line">　　　career:&apos;医生&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function object(o) &#123;</div><div class="line">　　function F() &#123;&#125;</div><div class="line">　　F.prototype = o;</div><div class="line">　　return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Doctor = object(Chinese);</div><div class="line"></div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line"></div><div class="line">alert(Doctor.nation); //中国</div></pre></td></tr></table></figure>
<h3 id="第二种-浅拷贝"><a href="#第二种-浅拷贝" class="headerlink" title="第二种 浅拷贝"></a>第二种 浅拷贝</h3><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extendCopy(p) &#123;</div><div class="line">　　var c = &#123;&#125;;</div><div class="line">　　for (var i in p) &#123;</div><div class="line">　　　　c[i] = p[i];</div><div class="line">　　&#125;</div><div class="line">　　c.uber = p;</div><div class="line">　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div></pre></td></tr></table></figure>
<p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div></pre></td></tr></table></figure>
<p>然后，我们为Doctor的”出生地”添加一个城市</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>发生了什么事？Chinese的”出生地”也被改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门</div></pre></td></tr></table></figure>
<p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<h3 id="第三种-深拷贝"><a href="#第三种-深拷贝" class="headerlink" title="第三种 深拷贝"></a>第三种 深拷贝</h3><p>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p, c) &#123;</div><div class="line">　　　　var c = c || &#123;&#125;;</div><div class="line">　　　　for (var i in p) &#123;</div><div class="line">　　　　　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">　　　　　　　　deepCopy(p[i], c[i]);</div><div class="line">　　　　　　&#125; else &#123;</div><div class="line">　　　　　　　　　c[i] = p[i];</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = deepCopy(Chinese);</div></pre></td></tr></table></figure>
<p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>这时，父对象就不会受到影响了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港</div></pre></td></tr></table></figure>
<p>目前，jQuery库使用的就是这种继承方法。</p>
<hr>
<blockquote>
<p>以上文章内容，转载修改自<a href="http://www.ruanyifeng.com/blog/javascript/" target="_blank" rel="external">阮一峰的网络日志</a>，仅作学习总结，原文链接如下：</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">Javascript面向对象编程（三）：非构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">Javascript面向对象编程（二）：构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">Javascript 面向对象编程（一）：封装</a></p>
</blockquote>
<p>本文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-oop.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-oop.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript是一种基于对象的语言，秉承一切皆对象的理念。&lt;/p&gt;
&lt;p&gt;但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态&lt;/p&gt;
&lt;p&gt;那么如何用 Javascript 来实现面向对象编程呢&lt;/p&gt;
&lt;h1 id=&quot;1、利用Prototype模式实现封装&quot;&gt;&lt;a href=&quot;#1、利用Prototype模式实现封装&quot; class=&quot;headerlink&quot; title=&quot;1、利用Prototype模式实现封装&quot;&gt;&lt;/a&gt;1、利用Prototype模式实现封装&lt;/h1&gt;&lt;p&gt;在Javascript里每一个构造函数都有一个&lt;code&gt;prototype&lt;/code&gt;属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。&lt;/p&gt;
&lt;p&gt;这样，我们把那些不变的属性和方法，直接定义在&lt;code&gt;prototype&lt;/code&gt;对象上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Person(name,age) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.age = age;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Person.prototype.legs = 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Person.prototype.speak = function() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(&amp;quot;我的名字是：&amp;quot; + this.name + &amp;quot;，年龄：&amp;quot; + this.age);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，生成实例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var jack = new Person(&amp;quot;jack&amp;quot;, 26);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var lily = new Person(&amp;quot;lily&amp;quot;, 25);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jack.legs; // 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lily.speak() // 我的名字是：lily，年龄：25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="oop" scheme="http://www.imeetyou.net/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>div嵌套水平垂直居中方法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/div-center-middle.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/div-center-middle.html</id>
    <published>2017-03-12T09:24:54.000Z</published>
    <updated>2017-03-22T07:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。<br>首先给需要实现水平垂直居中的两个div设置统一的样式，<a href="/demos/div-center-middle.html"><strong>查看demo</strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl &#123;</div><div class="line">	width: 100%;</div><div class="line">	height: 300px;</div><div class="line">	background: #ccc;</div><div class="line">	margin: 30px auto;</div><div class="line">	position: relative;</div><div class="line">	border: 1px solid #000;</div><div class="line">&#125;</div><div class="line">.box &#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 100px;</div><div class="line">	background: #333;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法一：父标签-table-cell-法"><a href="#方法一：父标签-table-cell-法" class="headerlink" title="方法一：父标签 table-cell 法"></a>方法一：父标签 table-cell 法</h2><p>看题目就知道是利用父标签的 <code>display: table-cell</code>,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。<br>那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性<code>vertical-align: middle;</code> 来使得内部元素垂直居中了，然后再给子标签 <code>margin:0 auto;</code> 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">.styl1 &#123;</div><div class="line">	width: 1000px;</div><div class="line">	display: table-cell;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl1 .box &#123;</div><div class="line">	margin: 0 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html代码只要用我们上面的样式即可，之后的class名只要修改 <code>styl1</code> 为对应的样式名即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* html */</div><div class="line">&lt;div class=&quot;styl styl1&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="方法二：常规-position-及子元素偏移方法"><a href="#方法二：常规-position-及子元素偏移方法" class="headerlink" title="方法二：常规 position 及子元素偏移方法"></a>方法二：常规 position 及子元素偏移方法</h2><p>父标签设置 <code>position:relative</code>,子标签设置 <code>position:absolute</code>,同时设置 <code>left:50%</code>,<code>top:50%</code>,这个时候子标签的左上角已经垂直水平居中，再设置<code>margin</code>的负值为子元素宽高的50%即可将中心点对齐。<br>此方法缺点，需要动态调整 margin 偏移量为子标签宽高度的一半这个值，无法自动匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl2 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	margin: -50px 0 0 -100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法三：CSS3新属性-transform-的-translate-方法"><a href="#方法三：CSS3新属性-transform-的-translate-方法" class="headerlink" title="方法三：CSS3新属性 transform 的 translate 方法"></a>方法三：CSS3新属性 transform 的 translate 方法</h2><p>首先 <code>transform</code> 是css3的新属性，该属性是让我们对元素进行旋转、缩放、<strong>移动</strong>或倾斜。那么再看属性值 <code>translate</code> 是定义2D转换，就是平面的x,y喽。知道这些，那么我们在 方法二的基础上将偏移量通过 <code>transform</code> 来设置即可。<br>此属性支持IE9以上属性，而且需要兼容不同浏览器写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.styl3 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	transform: translate(-50%, -50%);</div><div class="line">	-webkit-transform: translate(-50%, -50%);</div><div class="line">	-moz-transform: translate(-50%, -50%);</div><div class="line">	-ms-transform: translate(-50%, -50%)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法四：margin-auto-方法"><a href="#方法四：margin-auto-方法" class="headerlink" title="方法四：margin:auto 方法"></a>方法四：margin:auto 方法</h2><p>此方法依然是在方法二的基础上修改，将子元素的left、top、right、bottom都设置为0，然后再 <code>margin:auto</code>,即可实现子元素的水平垂直居中。<br>此方法好处是自适应父标签的宽高，也就是说，无论父标签宽高怎么变都水平垂直居中哦。<br>此方法支持IE8+以及其他浏览器。是不是很神奇，具体原因查看 <strong><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" target="_blank" rel="external">margin:auto实现绝对定位元素的水平垂直居中</a></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.styl4 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	margin: auto;</div><div class="line">	left: 0;</div><div class="line">	top: 0;</div><div class="line">	bottom: 0;</div><div class="line">	right: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法五：flex-布局方法"><a href="#方法五：flex-布局方法" class="headerlink" title="方法五：flex 布局方法"></a>方法五：flex 布局方法</h2><p>flex意为弹性布局，不同于盒模型布局，子元素实现垂直居中就比较容易了，具体教程可以参看 <strong><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰的flex布局教程</a></strong>，这里只说怎么实现。<br>在此我们只要将父标签设置为 <code>display: flex</code>,并进行相应的主轴 <code>justify-content: center</code> 和交叉轴上的 <code>align-items: center</code> 对齐方式就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl5 &#123;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">	display: -webkit-flex;</div><div class="line">	display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html结构同上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;styl styl5&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="方法六：伪元素-inline-block-vertical-align-方法"><a href="#方法六：伪元素-inline-block-vertical-align-方法" class="headerlink" title="方法六：伪元素 inline-block/vertical-align 方法"></a>方法六：伪元素 inline-block/vertical-align 方法</h2><p>这个方法主要利用父标签的 <code>::before</code> 伪元素的 <code>inline-block</code> <code>vertical-align</code>来实现，比较巧妙，但这个方法要求子元素的属性必须是 <code>display: inline-block</code>, 好处依然是父子元素都可以自适应宽高并保持水平垂直居中。css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl6 &#123;</div><div class="line">	text-align: center;</div><div class="line">&#125;</div><div class="line">.styl6:before &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	display: inline-block;</div><div class="line">	height: 100%;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl6 .box &#123;</div><div class="line">	display: inline-block;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好，至此总结了div内部元素水平垂直居中的方法。</p>
<hr>
<blockquote>
<p>本文主要内容引用：</p>
<ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-绝对定位-水平垂直居中/" target="_blank" rel="external">margin:auto 实现绝对定位元素的水平垂直居中</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰的flex布局教程</a></li>
</ul>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/div-center-middle.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/div-center-middle.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。&lt;br&gt;首先给需要实现水平垂直居中的两个div设置统一的样式，&lt;a href=&quot;/demos/div-center-middle.html&quot;&gt;&lt;strong&gt;查看demo&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.styl &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 100%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 300px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #ccc;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	margin: 30px auto;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	position: relative;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	border: 1px solid #000;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.box &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 200px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 100px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #333;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;方法一：父标签-table-cell-法&quot;&gt;&lt;a href=&quot;#方法一：父标签-table-cell-法&quot; class=&quot;headerlink&quot; title=&quot;方法一：父标签 table-cell 法&quot;&gt;&lt;/a&gt;方法一：父标签 table-cell 法&lt;/h2&gt;&lt;p&gt;看题目就知道是利用父标签的 &lt;code&gt;display: table-cell&lt;/code&gt;,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。&lt;br&gt;那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性&lt;code&gt;vertical-align: middle;&lt;/code&gt; 来使得内部元素垂直居中了，然后再给子标签 &lt;code&gt;margin:0 auto;&lt;/code&gt; 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="html" scheme="http://www.imeetyou.net/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局和双飞翼布局详解</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/div-the-holy-grail.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/div-the-holy-grail.html</id>
    <published>2017-03-06T04:35:54.000Z</published>
    <updated>2017-03-22T07:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。<br>首先给需要实现水平垂直居中的两个div设置统一的样式，<a href="/demos/the-holy-grail.html"><strong>查看demo</strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl &#123;</div><div class="line">	width: 100%;</div><div class="line">	height: 300px;</div><div class="line">	background: #ccc;</div><div class="line">	margin: 30px auto;</div><div class="line">	position: relative;</div><div class="line">	border: 1px solid #000;</div><div class="line">&#125;</div><div class="line">.box &#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 100px;</div><div class="line">	background: #333;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法一：父标签-table-cell-法"><a href="#方法一：父标签-table-cell-法" class="headerlink" title="方法一：父标签 table-cell 法"></a>方法一：父标签 table-cell 法</h2><p>看题目就知道是利用父标签的 <code>display: table-cell</code>,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。<br>那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性<code>vertical-align: middle;</code> 来使得内部元素垂直居中了，然后再给子标签 <code>margin:0 auto;</code> 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">.styl1 &#123;</div><div class="line">	width: 1000px;</div><div class="line">	display: table-cell;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl1 .box &#123;</div><div class="line">	margin: 0 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html代码只要用我们上面的样式即可，之后的class名只要修改 <code>styl1</code> 为对应的样式名即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* html */</div><div class="line">&lt;div class=&quot;styl styl1&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="方法二：常规-position-及子元素偏移方法"><a href="#方法二：常规-position-及子元素偏移方法" class="headerlink" title="方法二：常规 position 及子元素偏移方法"></a>方法二：常规 position 及子元素偏移方法</h2><p>父标签设置 <code>position:relative</code>,子标签设置 <code>position:absolute</code>,同时设置 <code>left:50%</code>,<code>top:50%</code>,这个时候子标签的左上角已经垂直水平居中，再设置<code>margin</code>的负值为子元素宽高的50%即可将中心点对齐。<br>此方法缺点，需要动态调整 margin 偏移量为子标签宽高度的一半这个值，无法自动匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl2 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	margin: -50px 0 0 -100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法三：CSS3新属性-transform-的-translate-方法"><a href="#方法三：CSS3新属性-transform-的-translate-方法" class="headerlink" title="方法三：CSS3新属性 transform 的 translate 方法"></a>方法三：CSS3新属性 transform 的 translate 方法</h2><p>首先 <code>transform</code> 是css3的新属性，该属性是让我们对元素进行旋转、缩放、<strong>移动</strong>或倾斜。那么再看属性值 <code>translate</code> 是定义2D转换，就是平面的x,y喽。知道这些，那么我们在 方法二的基础上将偏移量通过 <code>transform</code> 来设置即可。<br>此属性支持IE9以上属性，而且需要兼容不同浏览器写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.styl3 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	transform: translate(-50%, -50%);</div><div class="line">	-webkit-transform: translate(-50%, -50%);</div><div class="line">	-moz-transform: translate(-50%, -50%);</div><div class="line">	-ms-transform: translate(-50%, -50%)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法四：margin-auto-方法"><a href="#方法四：margin-auto-方法" class="headerlink" title="方法四：margin:auto 方法"></a>方法四：margin:auto 方法</h2><p>此方法依然是在方法二的基础上修改，将子元素的left、top、right、bottom都设置为0，然后再 <code>margin:auto</code>,即可实现子元素的水平垂直居中。<br>此方法好处是自适应父标签的宽高，也就是说，无论父标签宽高怎么变都水平垂直居中哦。<br>此方法支持IE8+以及其他浏览器。是不是很神奇，具体原因查看 <strong><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" target="_blank" rel="external">margin:auto实现绝对定位元素的水平垂直居中</a></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.styl4 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	margin: auto;</div><div class="line">	left: 0;</div><div class="line">	top: 0;</div><div class="line">	bottom: 0;</div><div class="line">	right: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法五：flex-布局方法"><a href="#方法五：flex-布局方法" class="headerlink" title="方法五：flex 布局方法"></a>方法五：flex 布局方法</h2><p>flex意为弹性布局，不同于盒模型布局，子元素实现垂直居中就比较容易了，具体教程可以参看 <strong><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰的flex布局教程</a></strong>，这里只说怎么实现。<br>在此我们只要将父标签设置为 <code>display: flex</code>,并进行相应的主轴 <code>justify-content: center</code> 和交叉轴上的 <code>align-items: center</code> 对齐方式就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl5 &#123;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">	display: -webkit-flex;</div><div class="line">	display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html结构同上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;styl styl5&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="方法六：伪元素-inline-block-vertical-align-方法"><a href="#方法六：伪元素-inline-block-vertical-align-方法" class="headerlink" title="方法六：伪元素 inline-block/vertical-align 方法"></a>方法六：伪元素 inline-block/vertical-align 方法</h2><p>这个方法主要利用父标签的 <code>::before</code> 伪元素的 <code>inline-block</code> <code>vertical-align</code>来实现，比较巧妙，但这个方法要求子元素的属性必须是 <code>display: inline-block</code>, 好处依然是父子元素都可以自适应宽高并保持水平垂直居中。css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl6 &#123;</div><div class="line">	text-align: center;</div><div class="line">&#125;</div><div class="line">.styl6:before &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	display: inline-block;</div><div class="line">	height: 100%;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl6 .box &#123;</div><div class="line">	display: inline-block;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好，至此总结了div内部元素水平垂直居中的方法。</p>
<hr>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/the-holy-grail.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/the-holy-grail.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。&lt;br&gt;首先给需要实现水平垂直居中的两个div设置统一的样式，&lt;a href=&quot;/demos/the-holy-grail.html&quot;&gt;&lt;strong&gt;查看demo&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.styl &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 100%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 300px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #ccc;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	margin: 30px auto;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	position: relative;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	border: 1px solid #000;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.box &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 200px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 100px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #333;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;方法一：父标签-table-cell-法&quot;&gt;&lt;a href=&quot;#方法一：父标签-table-cell-法&quot; class=&quot;headerlink&quot; title=&quot;方法一：父标签 table-cell 法&quot;&gt;&lt;/a&gt;方法一：父标签 table-cell 法&lt;/h2&gt;&lt;p&gt;看题目就知道是利用父标签的 &lt;code&gt;display: table-cell&lt;/code&gt;,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。&lt;br&gt;那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性&lt;code&gt;vertical-align: middle;&lt;/code&gt; 来使得内部元素垂直居中了，然后再给子标签 &lt;code&gt;margin:0 auto;&lt;/code&gt; 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="html" scheme="http://www.imeetyou.net/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>CSS中margin边界叠加问题及解决方案</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/css-margin-margin.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/css-margin-margin.html</id>
    <published>2017-03-02T01:25:34.000Z</published>
    <updated>2017-03-22T08:13:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>边界叠加简介</strong></p>
<p>边界叠加是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。<br>简单地说，当两个垂直边界相遇时，它们将形成一个边界。<br>这个边界的高度等于两个发生叠加的边界的高度中的较大者。</p>
<h2 id="元素的顶边界与前面元素的底边界发生叠加-示例一"><a href="#元素的顶边界与前面元素的底边界发生叠加-示例一" class="headerlink" title="元素的顶边界与前面元素的底边界发生叠加 示例一"></a>元素的顶边界与前面元素的底边界发生叠加 <a href="/demos/margin-margin.html">示例一</a></h2><p>也就是说当一个元素出现在另一个元素上面时，第一个元素的底边界与第二个元素的顶边界发生叠加。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="子元素的顶边界与父元素的顶边界发生叠加-示例二"><a href="#子元素的顶边界与父元素的顶边界发生叠加-示例二" class="headerlink" title="子元素的顶边界与父元素的顶边界发生叠加 示例二"></a>子元素的顶边界与父元素的顶边界发生叠加 <a href="/demos/margin-margin.html">示例二</a></h2><p>当一个元素包含在另一个元素中时（假设没有填充或边框将边界分隔开），它们的顶和/或底边界也发生叠加,<br>如果给父元素设置边框border或padding，此叠加不会发生。</p>
<hr>
<h2 id="元素的顶边界与底边界发生叠加-示例三"><a href="#元素的顶边界与底边界发生叠加-示例三" class="headerlink" title="元素的顶边界与底边界发生叠加 示例三"></a>元素的顶边界与底边界发生叠加 <a href="/demos/margin-margin.html">示例三</a></h2><p>尽管初看上去有点儿奇怪，但是边界甚至可以与本身发生叠加。假设有一个空元素，它有边界，但是没有边框或高度及内间距。<br>在这种情况下，顶边界与底边界就碰到了一起，它们会发生叠加，如果这个边界碰到另一个元素的边界，它还会发生叠加</p>
<hr>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>边界叠加的大多数问题可以通过添加透明边框或1px的补白来修复。其它补充解决方案：</p>
<p>1.外层 <code>padding</code></p>
<p>2.透明边框 <code>border:1px solid transparent;</code></p>
<p>3.绝对定位 <code>postion:absolute;</code></p>
<p>4.外层DIV <code>overflow:hidden;</code></p>
<p>5.内层DIV　加 <code>float:left; display:inline;</code></p>
<hr>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/margin-margin.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/margin-margin.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;边界叠加简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;边界叠加是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。&lt;br&gt;简单地说，当两个垂直边界相遇时，它们将形成一个边界。&lt;br&gt;这个边界的高度等于两个发生叠加的边界的高度中的较大者。&lt;/p&gt;
&lt;h2 id=&quot;元素的顶边界与前面元素的底边界发生叠加-示例一&quot;&gt;&lt;a href=&quot;#元素的顶边界与前面元素的底边界发生叠加-示例一&quot; class=&quot;headerlink&quot; title=&quot;元素的顶边界与前面元素的底边界发生叠加 示例一&quot;&gt;&lt;/a&gt;元素的顶边界与前面元素的底边界发生叠加 &lt;a href=&quot;/demos/margin-margin.html&quot;&gt;示例一&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;也就是说当一个元素出现在另一个元素上面时，第一个元素的底边界与第二个元素的顶边界发生叠加。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="css" scheme="http://www.imeetyou.net/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何自定义Atom主题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/atom-custom-theme.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/atom-custom-theme.html</id>
    <published>2016-12-08T04:42:32.000Z</published>
    <updated>2016-12-08T06:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Atom有段时间，一直使用别人的主题，想着自己也制作一款主题，便再 <a href="https://atom.io/docs/v1.2.4/hacking-atom-creating-a-theme" target="_blank" rel="external">官网</a> 上研究一番：</p>
<p>aotm主题，分为两种，一种是界面主题，一种是语法主题，下面就一一试试。</p>
<h1 id="创建界面主题"><a href="#创建界面主题" class="headerlink" title="创建界面主题"></a>创建界面主题</h1><p>首先，去下载一个主题，一直使用的是这个 <a href="https://atom.io/themes/one-dark-ui" target="_blank" rel="external">one-dark-ui</a>,下载到本机，并修改文件及主题名称，我修改的 <code>codyer-theme-ui</code>,然后，执行链接命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.atom/packages</div><div class="line">apm link /Users/username/Desktop/codyer-theme-ui</div></pre></td></tr></table></figure>
<p>之后，打开设置，选择 themes，就可以看到了。</p>
<a id="more"></a>
<h2 id="即时重启"><a href="#即时重启" class="headerlink" title="即时重启"></a>即时重启</h2><p>在你修改你的主题之后，按下 <code>cmd-alt-ctrl-L</code> 来重启不是十分理想。在dev模式的Atom窗口下，Atom支持样式的即时更新。</p>
<p>要想开启dev模式的窗口：</p>
<p>通过选择 View &gt; Developer &gt; Open in Dev Mode 菜单，或者按下 <code>cmd-shift-o</code> 快捷键来直接在dev模式窗口中打开你的主题。<br>修改你的主题并保存它。你的修改应该会马上应用。<br>如果你想要在任何时候都重新加载全部的样式，你可以使用 <code>cmd-ctrl-shift-r</code> 快捷键。</p>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>Atom基于Chrome浏览器，并且支持Chrome开发者工具。你可以选择View &gt; Toggle Developer Tools菜单，或者使用cmd-alt-i快捷键来打开它。</p>
<p>开发者工具允许你查看各个元素，以及他们的CSS属性。</p>
<h2 id="Atom-样式指南"><a href="#Atom-样式指南" class="headerlink" title="Atom 样式指南"></a>Atom 样式指南</h2><p>如果你在创建一个界面主题，你可能想要一种方式来查看你的主题如何影响系统中的组件。样式指南是一个页面，里面渲染了所有Atom支持的组件。</p>
<p>打开命令面板（cmd-shift-P）寻找“styleguide”，或者使用cmd-ctrl-shift-g快捷键来打开样式指南。</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/atom-styleguide.png" alt="atom-styleguide"></p>
<p>这里列出了所有style，直观多了。通过这里，我知道了如果我想改变边栏选中时的颜色，只要修改background-color-selected 的颜色值就可以了。于是回到 ui-variables.less 中，找到这个变量，改成想要的颜色(#93ffeb)即可。重新加载主题就能看到效果了。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><ul>
<li>@text-color</li>
<li>@text-color-subtle</li>
<li>@text-color-highlight</li>
<li>@text-color-selected</li>
<li>@text-color-info - 蓝色</li>
<li>@text-color-success- 绿色</li>
<li>@text-color-warning - 橙色或者黄色</li>
<li>@text-color-error - 红色</li>
</ul>
<h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><ul>
<li>@background-color-info - 蓝色</li>
<li>@background-color-success - 绿色</li>
<li>@background-color-warning - 橙色或者黄色</li>
<li>@background-color-error - 红色</li>
<li>@background-color-highlight</li>
<li>@background-color-selected</li>
<li>@app-background-color - 所有编辑器组件下面的应用背景</li>
</ul>
<p>###组件颜色</p>
<ul>
<li>@base-background-color -</li>
<li>@base-border-color -</li>
<li>@pane-item-background-color -</li>
<li>@pane-item-border-color -</li>
<li>@input-background-color -</li>
<li>@input-border-color -</li>
<li>@tool-panel-background-color -</li>
<li>@tool-panel-border-color -</li>
<li>@inset-panel-background-color -</li>
<li>@inset-panel-border-color -</li>
<li>@panel-heading-background-color -</li>
<li>@panel-heading-border-color -</li>
<li>@overlay-background-color -</li>
<li>@overlay-border-color -</li>
<li>@button-background-color -</li>
<li>@button-background-color-hover -</li>
<li>@button-background-color-selected -</li>
<li>@button-border-color -</li>
<li>@tab-bar-background-color -</li>
<li>@tab-bar-border-color -</li>
<li>@tab-background-color -</li>
<li>@tab-background-color-active -</li>
<li>@tab-border-color -</li>
<li>@tree-view-background-color -</li>
<li>@tree-view-border-color -</li>
<li>@ui-site-color-1 -</li>
<li>@ui-site-color-2 -</li>
<li>@ui-site-color-3 -</li>
<li>@ui-site-color-4 -</li>
<li>@ui-site-color-5 -</li>
</ul>
<h3 id="组件尺寸"><a href="#组件尺寸" class="headerlink" title="组件尺寸"></a>组件尺寸</h3><ul>
<li>@disclosure-arrow-size -</li>
<li>@component-padding -</li>
<li>@component-icon-padding -</li>
<li>@component-icon-size -</li>
<li>@component-line-height -</li>
<li>@component-border-radius -</li>
<li>@tab-height -</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li>@font-size -</li>
<li>@font-family -</li>
</ul>
<h1 id="创建语法主题"><a href="#创建语法主题" class="headerlink" title="创建语法主题"></a>创建语法主题</h1><p>同时按 <code>cmd+shift+p</code>，输入 <code>generate syntax theme</code> 并回车，为主题命名，选择一个保存的位置就可以了。注意名字一定要以-syntax结尾。</p>
<p>保存好后，就可以在设置-Themes的Syntax主题列表中看到刚建好的主题了。选择它。Syntax部分比较简单，不需要手动建立链接，目录结构也少了许多。</p>
<p>目录结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">codyer-theme-Syntax/</div><div class="line">	  └── styles/</div><div class="line">	      ├── base.less </div><div class="line">	      ├── colors.less  </div><div class="line">	      └── syntax-variables.less</div></pre></td></tr></table></figure>
<p>在 <code>colors.less</code> 修改自己喜好的配色即可。</p>
<h2 id="发布语法主题"><a href="#发布语法主题" class="headerlink" title="发布语法主题"></a>发布语法主题</h2><ul>
<li>首先把制造好的主题上传至github。</li>
<li>进入主题目录 执行 <code>apm publish minor</code> 之后输入github的用户名及密码，会要求输入 atom token，然后上传成功，就可以在 atom编辑器里下载到你自己的主题了。</li>
</ul>
<h1 id="我的自定义主题"><a href="#我的自定义主题" class="headerlink" title="我的自定义主题"></a>我的自定义主题</h1><p>主题名称 <a href="https://atom.io/themes/codyer-theme-syntax" target="_blank" rel="external">codyer-theme-syntax</a></p>
<p><img src="http://og8z552x2.bkt.clouddn.com/atom-js-style.png" alt="codyer-theme-html"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Atom有段时间，一直使用别人的主题，想着自己也制作一款主题，便再 &lt;a href=&quot;https://atom.io/docs/v1.2.4/hacking-atom-creating-a-theme&quot;&gt;官网&lt;/a&gt; 上研究一番：&lt;/p&gt;
&lt;p&gt;aotm主题，分为两种，一种是界面主题，一种是语法主题，下面就一一试试。&lt;/p&gt;
&lt;h1 id=&quot;创建界面主题&quot;&gt;&lt;a href=&quot;#创建界面主题&quot; class=&quot;headerlink&quot; title=&quot;创建界面主题&quot;&gt;&lt;/a&gt;创建界面主题&lt;/h1&gt;&lt;p&gt;首先，去下载一个主题，一直使用的是这个 &lt;a href=&quot;https://atom.io/themes/one-dark-ui&quot;&gt;one-dark-ui&lt;/a&gt;,下载到本机，并修改文件及主题名称，我修改的 &lt;code&gt;codyer-theme-ui&lt;/code&gt;,然后，执行链接命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd ~/.atom/packages&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;apm link /Users/username/Desktop/codyer-theme-ui&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，打开设置，选择 themes，就可以看到了。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="atom" scheme="http://www.imeetyou.net/tags/atom/"/>
    
      <category term="theme" scheme="http://www.imeetyou.net/tags/theme/"/>
    
      <category term="syntax" scheme="http://www.imeetyou.net/tags/syntax/"/>
    
  </entry>
  
  <entry>
    <title>重装node导致Hexo不能正常使用解决办法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/hexo-node-err.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/hexo-node-err.html</id>
    <published>2016-11-22T02:40:15.000Z</published>
    <updated>2016-11-22T02:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。最近重装了node，导致在编译博客的时候，会出现很多依赖的错误。比如：</p>
<p>在使用hexo过程中，使用node 6.0以上版本，会出现fs版本问题。</p>
<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ATAL Error: Module version mismatch. Expected 48, got 14.</div><div class="line">Template render error: Error: Module version mismatch. Expected 48, got 14.</div></pre></td></tr></table></figure>
<p>错误提示模块的版本不匹配，可能是因为重装了node，很多模块更新或者确实，所以我们重新安装配置下Hexo,解决方法：执行以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo --no-optional</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p>安装Hexo时，执行“npm install -g hexo-cli“出现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">npm ERR! tar.unpack untar error /Users/Macx/.npm/hexo-cli/0.1.8/package.tgz</div><div class="line">npm ERR! Darwin 14.4.0</div><div class="line">npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;hexo-cli&quot; &quot;-g&quot;</div><div class="line">npm ERR! node v4.2.1</div><div class="line">npm ERR! npm v2.14.7</div><div class="line">npm ERR! path /usr/local/lib/node_modules/hexo-cli</div><div class="line">npm ERR! code EACCES</div><div class="line">npm ERR! errno -13</div><div class="line">npm ERR! syscall mkdir</div><div class="line"></div><div class="line">npm ERR! Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo-cli&apos;</div><div class="line">npm ERR! at Error (native)</div><div class="line">npm ERR! &#123; [Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo-cli&apos;]</div><div class="line">npm ERR! errno: -13,</div><div class="line">npm ERR! code: &apos;EACCES&apos;,</div><div class="line">npm ERR! syscall: &apos;mkdir&apos;,</div><div class="line">npm ERR! path: &apos;/usr/local/lib/node_modules/hexo-cli&apos;,</div><div class="line">npm ERR! fstream_type: &apos;Directory&apos;,</div><div class="line">npm ERR! fstream_path: &apos;/usr/local/lib/node_modules/hexo-cli&apos;,</div><div class="line">npm ERR! fstream_class: &apos;DirWriter&apos;,</div><div class="line">npm ERR! fstream_stack: </div><div class="line">npm ERR! [ &apos;/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25&apos;,</div><div class="line">npm ERR! &apos;/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53&apos;,</div><div class="line">npm ERR! &apos;FSReqWrap.oncomplete (fs.js:82:15)&apos; ] &#125;</div><div class="line">npm ERR! </div><div class="line">npm ERR! Please try running this command again as root/Administrator.</div><div class="line"></div><div class="line">npm ERR! Please include the following file with any support request:</div><div class="line">npm ERR! /Users/Macx/Desktop/GitHub/npm-debug.log</div></pre></td></tr></table></figure>
<p>分析下错误，异常可能因为权限问题，所以我们执行一些安装命令是需要申请root执行权限。</p>
<p>解决方法：执行以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install --unsafe-perm --verbose -g hexo</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。最近重装了node，导致在编译博客的时候，会出现很多依赖的错误。比如：&lt;/p&gt;
&lt;p&gt;在使用hexo过程中，使用node 6.0以上版本，会出现fs版本问题。&lt;/p&gt;
&lt;h1 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一&quot;&gt;&lt;/a&gt;问题一&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ATAL Error: Module version mismatch. Expected 48, got 14.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Template render error: Error: Module version mismatch. Expected 48, got 14.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;错误提示模块的版本不匹配，可能是因为重装了node，很多模块更新或者确实，所以我们重新安装配置下Hexo,解决方法：执行以下代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install hexo --no-optional&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="hexo" scheme="http://www.imeetyou.net/tags/hexo/"/>
    
  </entry>
  
</feed>
