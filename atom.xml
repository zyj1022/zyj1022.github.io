<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>智的前端之路</title>
  <subtitle>若有智，事可为</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.imeetyou.net/"/>
  <updated>2017-05-02T09:10:08.000Z</updated>
  <id>http://www.imeetyou.net/</id>
  
  <author>
    <name>KINGZHI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub 项目徽章的添加和设置</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/github-badge.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/github-badge.html</id>
    <published>2017-05-02T09:25:34.000Z</published>
    <updated>2017-05-02T09:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多同学在 GitHub 上发布了自己的开源项目，有辛苦开发的实用工具、构思巧妙的开源库、别具一格的 App、精心整理的示例代码等等。</p>
<p>自己花了大把时间和精力构建的项目，当然是希望能够得到更多人的关注，被更多的人知晓或者使用。如何更好滴向他人展示自己的项目，介绍项目相关信息呢？用一些通用的小图标来描述项目相关信息不失为一种很棒的选择，几个好看的徽标能够为自己的项目说明增色不少！</p>
<h1 id="一-徽标简介"><a href="#一-徽标简介" class="headerlink" title="一. 徽标简介"></a>一. 徽标简介</h1><p>GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。</p>
<p>徽标主要由图片和对应的链接（当然，你可以不填）组成，徽标图片的话一般由左半部分的名称和右半部分的值组成。</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-3489b47031ed2017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一枚普通的徽标"></p>
<p>GitHub 徽标的官方网站是 <a href="http://shields.io/" target="_blank" rel="external">http://shields.io/</a>，我萌可以在官网预览绝大部分的徽标样式，然后选择自己喜欢的（当然首先需要适用于自己的目标项目）徽标，添加到自己的项目文档中去。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-b2676f0571e5684c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Shields.IO"></p>
<p>下面贴出几个栗子以供参考：</p>
<ul>
<li>正在学习的 ReSwift</li>
</ul>
<p><a href="https://travis-ci.org/ReSwift/ReSwift" target="_blank" rel="external"><img src="https://img.shields.io/travis/ReSwift/ReSwift/master.svg?style=flat-square" alt="Build Status"></a> <a href="http://codecov.io/github/ReSwift/ReSwift" target="_blank" rel="external"><img src="https://img.shields.io/codecov/c/github/ReSwift/ReSwift.svg?style=flat-square" alt="Code coverage status"></a> <a href="https://cocoapods.org/pods/ReSwift" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/v/ReSwift.svg?style=flat-square" alt="CocoaPods Compatible"></a> <a href="https://github.com/ReSwift/ReSwift/blob/master/LICENSE.md" target="_blank" rel="external"><img src="https://img.shields.io/badge/platform-ios%20%7C%20osx%20%7C%20tvos%20%7C%20watchos-lightgrey.svg?style=flat-square" alt="Platform support"></a> <a href="https://github.com/ReSwift/ReSwift/blob/master/LICENSE.md" target="_blank" rel="external"><img src="https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square" alt="License MIT"></a></p>
<ul>
<li>大名鼎鼎的 Kingfisher</li>
</ul>
<p align="center"><br><br><img src="https://raw.githubusercontent.com/onevcat/Kingfisher/master/images/logo.png" alt="Kingfisher" title="Kingfisher" width="557"><br><br></p>

<p align="center"><br><a href="https://travis-ci.org/onevcat/Kingfisher" target="_blank" rel="external"><img src="https://img.shields.io/travis/onevcat/Kingfisher/master.svg"></a><br><a href="https://github.com/Carthage/Carthage/" target="_blank" rel="external"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"></a><br><a href="https://swift.org/package-manager/" target="_blank" rel="external"><img src="https://img.shields.io/badge/SPM-ready-orange.svg"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat"></a><br><a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat"></a><br><a href="https://codebeat.co/projects/github-com-onevcat-kingfisher" target="_blank" rel="external"><img alt="codebeat badge" src="https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg"></a><br><img src="https://img.shields.io/badge/made%20with-%3C3-orange.svg"><br></p>

<ul>
<li>家喻户晓的 Alamofire</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png" alt="Alamofire: Elegant Networking in Swift"></p>
<p><a href="https://travis-ci.org/Alamofire/Alamofire" target="_blank" rel="external"><img src="https://travis-ci.org/Alamofire/Alamofire.svg?branch=master" alt="Build Status"></a><br><a href="https://img.shields.io/cocoapods/v/Alamofire.svg" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/v/Alamofire.svg" alt="CocoaPods Compatible"></a><br><a href="https://github.com/Carthage/Carthage" target="_blank" rel="external"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage Compatible"></a><br><a href="http://cocoadocs.org/docsets/Alamofire" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat" alt="Platform"></a><br><a href="http://twitter.com/AlamofireSF" target="_blank" rel="external"><img src="https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat" alt="Twitter"></a><br><a href="https://gitter.im/Alamofire/Alamofire?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge" target="_blank" rel="external"><img src="https://badges.gitter.im/Alamofire/Alamofire.svg" alt="Gitter"></a></p>
<p>徽标并不是添加的越多越好，合理地选择适合项目的徽标做具有针对性地添加才是理性的做法，像 <a href="https://github.com/EyreFree/EFQRCode" target="_blank" rel="external">EFQRCode</a> 这样堆积徽标的无脑行为并不是十分可取，在这里提出这一点，希望大家不要盲目追求数量。</p>
<ul>
<li>腊鸡 EFQRCode</li>
</ul>
<p><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/assets/EFQRCode.jpg" alt=""></p>
<p align="center"><br><a href="https://travis-ci.org/EyreFree/EFQRCode" target="_blank" rel="external"><img src="http://img.shields.io/travis/EyreFree/EFQRCode.svg"></a><br><a href="https://codecov.io/gh/EyreFree/EFQRCode" target="_blank" rel="external"><img src="https://codecov.io/gh/EyreFree/EFQRCode/branch/master/graph/badge.svg"></a><br><a href="https://github.com/Carthage/Carthage/" target="_blank" rel="external"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"></a><br><a href="https://swift.org/package-manager/" target="_blank" rel="external"><img src="https://img.shields.io/badge/SPM-ready-orange.svg"></a><br><a href="http://cocoapods.org/pods/EFQRCode" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/v/EFQRCode.svg?style=flat"></a><br><a href="http://cocoapods.org/pods/EFQRCode" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/p/EFQRCode.svg?style=flat"></a><br><a href="https://github.com/apple/swift" target="_blank" rel="external"><img src="https://img.shields.io/badge/language-swift-orange.svg"></a><br><a href="https://codebeat.co/projects/github-com-eyrefree-efqrcode-master" target="_blank" rel="external"><img src="https://codebeat.co/badges/01f53e9d-542c-4c22-adc7-d1dbff0d2a6f"></a><br><a href="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/l/EFQRCode.svg?style=flat"></a><br><a href="https://gitter.im/EFQRCode/Lobby" target="_blank" rel="external"><img src="https://badges.gitter.im/EyreFree/EFQRCode.svg"></a><br><a href="https://twitter.com/EyreFree777" target="_blank" rel="external"><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?style=flat"></a><br><a href="http://weibo.com/eyrefree777" target="_blank" rel="external"><img src="https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=flat"></a><br></p>

<p>当然如果个人比较喜欢的话，请随意添加。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-bd12202658a6a391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请随意"></p>
<h1 id="二-常用徽标添加"><a href="#二-常用徽标添加" class="headerlink" title="二. 常用徽标添加"></a>二. 常用徽标添加</h1><p>常用的徽标主要有持续集成状态、项目版本信息、代码测试覆盖率、项目支持平台、项目语言、代码分析等，下面我萌就来依次添加这些可爱的徽标！</p>
<h2 id="1-持续集成状态"><a href="#1-持续集成状态" class="headerlink" title="1. 持续集成状态"></a>1. 持续集成状态</h2><p>持续集成的话推荐 <a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a>，针对开源项目免费，所以你的私有项目无法享受到免费的持续构建服务，不过我们的目的貌似就是给开源项目添加徽标。</p>
<p>同类型的产品还有 <a href="https://circleci.com" target="_blank" rel="external">CircleCI</a>，不过目前跑 OS X 项目需要额外付费，免费版提供一个 Linux 项目队列，作为非付费用户在这里不多做评价，大佬们可以自己试下。其他还有诸如 <a href="https://jenkins.io/" target="_blank" rel="external">Jenkins</a><br> 和 <a href="https://codeship.com/" target="_blank" rel="external">Codeship</a> 等，大家可以在 <a href="http://shields.io/" target="_blank" rel="external">http://shields.io/</a> 的 <code>Build</code> 这一栏自行翻阅。</p>
<p>接下来就是 Travis CI 的集成工作了，首先打开 <a href="https://travis-ci.org/" target="_blank" rel="external">https://travis-ci.org/</a> 注册一个 Travis-CI 账号，可以通过 GitHub 账户直接登陆。</p>
<p>然后参考 <a href="https://docs.travis-ci.com/user/getting-started/" target="_blank" rel="external">官方文档</a>，根据你的项目语言或类型选择具体的配置方式，主要就是在项目中添加一个 <code>.travis.yml</code> 配置文件，告诉 Travis CI 怎样对你的项目进行编译或测试。这里有一个 Swift CocoaPods 库的集成示例，可以参考一下：<a href="http://www.jianshu.com/p/beaa9ec9183d" target="_blank" rel="external">http://www.jianshu.com/p/beaa9ec9183d</a>。</p>
<p>然后徽标图片地址是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://img.shields.io/travis/&#123;GitHub 用户名&#125;/&#123;项目名称&#125;.svg</div></pre></td></tr></table></figure>
<p>将上面 URL 中的 {GitHub 用户名} 和 {项目名称} 替换为你的即可，再加上该项目在 Travis CI 上的地址，以 Alamofire 为例，最后集成完成的 Markdown 代码和效果大概是这个样子：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">![</span>](<span class="link">https://travis-ci.org/Alamofire/Alamofire.svg?branch=master</span>)](<span class="link">https://travis-ci.org/Alamofire/Alamofire</span>)</div></pre></td></tr></table></figure>
<p><a href="https://travis-ci.org/Alamofire/Alamofire" target="_blank" rel="external"><img src="https://travis-ci.org/Alamofire/Alamofire.svg?branch=master" alt=""></a></p>
<p>当然如果你的编译没跑过或者发生错误之类的，会出现其他的状态，比如酱紫的：</p>
<p><img src="https://img.shields.io/codeship/d6c1ddd0-16a3-0132-5f85-2e35c05e22b1.svg" alt=""></p>
<p><img src="https://img.shields.io/vso/build/larsbrinkhoff/953a34b9-5966-4923-a48a-c41874cfb5f5/1.svg" alt=""></p>
<p><img src="https://img.shields.io/snap-ci/ThoughtWorksStudios/eb_deployer/master.svg" alt=""></p>
<p>这里需要指出的是，开源项目的 Travis CI 也是公开的，包括日志和历史记录在内，都是针对所有人可见的，所以小伙伴们一定不要把密码、私钥等重要信息暴露了。</p>
<h2 id="2-项目下载量"><a href="#2-项目下载量" class="headerlink" title="2. 项目下载量"></a>2. 项目下载量</h2><p>项目被下载的次数，这个的话各个平台的统计都是独立的，比如发布在 CocoaPods 的项目下载量徽标图片地址如下，以 AFNetworking 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">总下载量：https://img.shields.io/cocoapods/dt/AFNetworking.svg</div><div class="line">月下载量：https://img.shields.io/cocoapods/dm/AFNetworking.svg</div><div class="line">周下载量：https://img.shields.io/cocoapods/dw/AFNetworking.svg</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://img.shields.io/cocoapods/dt/AFNetworking.svg" alt=""><br><img src="https://img.shields.io/cocoapods/dm/AFNetworking.svg" alt=""><br><img src="https://img.shields.io/cocoapods/dw/AFNetworking.svg" alt=""></p>
<p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 AFNetworking 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 <a href="http://shields.io/" target="_blank" rel="external">http://shields.io/</a> 的 <code>Downloads</code> 一栏。</p>
<h2 id="3-项目版本信息"><a href="#3-项目版本信息" class="headerlink" title="3. 项目版本信息"></a>3. 项目版本信息</h2><p>这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/cocoapods/v/&#123;项目名称&#125;.svg?style=flat</div></pre></td></tr></table></figure>
<p>以 Alamofire 为例，Markdown 代码和效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat" alt=""></p>
<p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 <a href="http://shields.io/" target="_blank" rel="external">http://shields.io/</a> 的 <code>Version</code> 一栏。</p>
<p>如果你的发布工具不提供项目版本信息的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/badge/&#123;发布方式&#125;-&#123;版本号&#125;-519dd9.svg</div></pre></td></tr></table></figure>
<p>将 {发布方式} 和 {版本号} 替换为你的项目目前的发布方式和版本号即可，例如通过 360 应用商店发布，发布版本号为 v1.2.3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg" alt=""></p>
<h2 id="4-代码测试覆盖率"><a href="#4-代码测试覆盖率" class="headerlink" title="4. 代码测试覆盖率"></a>4. 代码测试覆盖率</h2><p>代码测试覆盖率的话推荐 <a href="https://codecov.io/" target="_blank" rel="external">Codecov</a>。同类产品有 <a href="https://coveralls.io/" target="_blank" rel="external">Coveralls</a>，不过网站风格略复古，文档也不详细，安装过程也复杂，需要配置一大堆奇怪的东西，遂不推荐。</p>
<p>同样的，Codecov 可以直接使用 GitHub 账号登陆，需要结合 Travis CI 使用，在 <code>.travis.yml</code> 文件中添加一个回调触发 Codecov 的刷新，同时需要打开工程中的测试覆盖信息收集，XCode 中的设置如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-a1fceb0028ce645a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>更多信息可参考 <a href="https://docs.codecov.io/docs" target="_blank" rel="external">官方文档</a> 和 <a href="https://github.com/codecov" target="_blank" rel="external">示例</a>。</p>
<p>然后，我们就可以在 Setting 中的 Badge 一栏找到添加图标的代码啦：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-95306d0d263235c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>最终效果如下：</p>
<p><a href="https://codecov.io/gh/EyreFree/EFQRCode" target="_blank" rel="external"><img src="https://codecov.io/gh/EyreFree/EFQRCode/branch/master/graph/badge.svg" alt="codecov"></a></p>
<h2 id="5-项目支持平台"><a href="#5-项目支持平台" class="headerlink" title="5. 项目支持平台"></a>5. 项目支持平台</h2><p>这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/cocoapods/p/&#123;项目名称&#125;.svg?style=flat</div></pre></td></tr></table></figure>
<p>以 Alamofire 为例，Markdown 代码和效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat" alt=""></p>
<p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供项目支持平台的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/badge/platform-&#123;项目支持平台&#125;-lightgrey.svg</div></pre></td></tr></table></figure>
<p>将 {项目支持平台} 替换为你的项目目前的版本号即可，例如 ios：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/platform-ios-lightgrey.svg)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/platform-ios-lightgrey.svg" alt=""></p>
<h2 id="6-项目语言"><a href="#6-项目语言" class="headerlink" title="6. 项目语言"></a>6. 项目语言</h2><p>嗯，这个完全是用自定义徽标实现的，具体可参考下文自定义徽标一节，这里给出徽标代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/badge/language-&#123;项目语言&#125;-&#123;背景色&#125;.svg</div></pre></td></tr></table></figure>
<p>将 {项目语言} 和 {背景色} 替换为你的项目目前的语言和你想要的背景色即可，这里以 Swift 为例，我们用上 Swift 官方橘色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/language-swift-orange.svg)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/language-swift-orange.svg" alt=""></p>
<p>完美!</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-7aaab9c7de41a78c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Swift"></p>
<h2 id="7-代码分析"><a href="#7-代码分析" class="headerlink" title="7. 代码分析"></a>7. 代码分析</h2><blockquote>
<p><a href="https://codebeat.co/" target="_blank" rel="external">Codebeat</a> 可以计算全局项目评分、GPA、和不同命名空间的等级来帮助您量化技术债务和发现重构机会，你唯一需要做的就是连接你的 Github 库，获得反馈就好了。</p>
</blockquote>
<p>嗯，上面是官方自述，大概意思就是每次 push 或者 merge 之后会对代码进行分，给出评分，然后告诉你哪些地方复杂度过高需要进行重构之类的。用 GitHub 登陆后绑定项目即可，无需对原有项目进行修改（其实是 codebeat 在你的项目设置里加了一个 Webhook，通知它重新计算评分）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-271c429613a8d34e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Webhooks"></p>
<p>照着引导巴拉巴拉一顿操作之后就可以获取图标啦，在项目的 Setting 中可以获取徽标代码，自己复制出来就可以。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1018190-080b0705f241d072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting"></p>
<p>最终效果如下：</p>
<p><a href="https://codebeat.co/projects/github-com-eyrefree-efqrcode-master" target="_blank" rel="external"><img src="https://codebeat.co/badges/01f53e9d-542c-4c22-adc7-d1dbff0d2a6f" alt="codebeat badge"></a></p>
<h2 id="8-开源协议类型"><a href="#8-开源协议类型" class="headerlink" title="8. 开源协议类型"></a>8. 开源协议类型</h2><p>这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/cocoapods/l/&#123;项目名称&#125;.svg?style=flat</div></pre></td></tr></table></figure>
<p>以 Alamofire 为例，Markdown 代码和效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat" alt=""></p>
<p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供开源协议类型的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/badge/license-&#123;协议名称&#125;-000000.svg</div></pre></td></tr></table></figure>
<p>将 {协议名称} 替换为你的项目所使用的协议名称即可，例如 MIT：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/license-MIT-000000.svg)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/license-MIT-000000.svg" alt=""></p>
<h1 id="三-自定义徽标"><a href="#三-自定义徽标" class="headerlink" title="三. 自定义徽标"></a>三. 自定义徽标</h1><h2 id="1-标题／内容／颜色／链接"><a href="#1-标题／内容／颜色／链接" class="headerlink" title="1. 标题／内容／颜色／链接"></a>1. 标题／内容／颜色／链接</h2><p>如果以上这些徽标没有满足你的需求，我们还可以定制自己的个性化徽标，<code>shields.io</code> 提供了添加自定义徽标的功能，通过修改如下 URL 即可获取自定义徽标图片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg</div></pre></td></tr></table></figure>
<p>{徽标标题}：徽标左半部分的文本（短线：–，下划线：__，空格： 或_）；<br>{徽标内容}：徽标右半部分的文本，同上；<br>{徽标颜色}：徽标右半部分背景颜色，可以是 red、green、blue 等颜色英文单词，也可以直接写十六进制的颜色值，如 ff69b4，示例如下：</p>
<p><img src="https://img.shields.io/badge/color-brightgreen-brightgreen.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-green-green.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-yellowgreen-yellowgreen.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-yellow-yellow.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-orange-orange.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-red-red.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-lightgrey-lightgrey.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-blue-blue.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-ff69b4-ff69b4.svg?maxAge=2592000" alt=""></p>
<p>将其中的 {徽标标题}、{徽标内容}、{徽标颜色} 分别替换为需要的内容即可，例如我的微博徽标图片地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://img.shields.io/badge/weibo-@EyreFree-red.svg</div></pre></td></tr></table></figure>
<p>再结合我的微博地址 <a href="http://weibo.com/eyrefree777" target="_blank" rel="external">http://weibo.com/eyrefree777</a> 后完整徽标代码和效果如下（如果这段代码用在 GitHub 的话，点击该徽标会打开对应的 URL 地址，即直接跳到我的微博）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">![</span>](<span class="link">https://img.shields.io/badge/weibo-@EyreFree-red.svg</span>)](<span class="link">http://weibo.com/eyrefree777</span>)</div></pre></td></tr></table></figure>
<p><a href="http://weibo.com/eyrefree777" target="_blank" rel="external"><img src="https://img.shields.io/badge/weibo-@EyreFree-red.svg" alt=""></a></p>
<p>同理我的推特徽标代码和效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">![</span>](<span class="link">https://img.shields.io/badge/twitter-@EyreFree777-blue.svg</span>)](<span class="link">https://twitter.com/EyreFree777</span>)</div></pre></td></tr></table></figure>
<p><a href="https://twitter.com/EyreFree777" target="_blank" rel="external"><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg" alt=""></a></p>
<h2 id="2-附加参数"><a href="#2-附加参数" class="headerlink" title="2. 附加参数"></a>2. 附加参数</h2><p>可以在徽标图片 URL 后面带上一些参数来控制徽标的样式，这一部分是可选的，不想折腾的话默认的样式就挺好了，可以不看这里的。</p>
<p>使用方法就是在徽标图片 URL 后面跟上 <code>?{参数名}={参数值}</code></p>
<p>多个参数联用的话就是 <code>?{参数名1}={参数值1}&amp;{参数名2}={参数值2}...</code></p>
<h3 id="1-style"><a href="#1-style" class="headerlink" title="1. style"></a>1. style</h3><p>style 控制徽标的主体样式，有四种，不设置的话默认是 <code>flat</code> 的，示例代码和效果如下：</p>
<h4 id="plastic"><a href="#plastic" class="headerlink" title="plastic"></a>plastic</h4><p>塑料？大概是指立体效果</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic" alt=""></p>
<h4 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h4><p>正常的样子，扁平化</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat" alt=""></p>
<h4 id="flat-square"><a href="#flat-square" class="headerlink" title="flat-square"></a>flat-square</h4><p>扁平化 + 去除圆角</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square" alt=""></p>
<h4 id="social"><a href="#social" class="headerlink" title="social"></a>social</h4><p>社交样式</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=social)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=social" alt=""></p>
<h3 id="2-label"><a href="#2-label" class="headerlink" title="2. label"></a>2. label</h3><p>该参数可以用来强制覆盖原有的徽标标题文字，效果如下，原有的 pod 字样已经被覆盖了：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses" alt=""></p>
<h3 id="3-logo"><a href="#3-logo" class="headerlink" title="3. logo"></a>3. logo</h3><p>该参数可以用来为徽标添加 logo，logo 图片会出现在左半部分的徽标标题左边，logo 图片高度必须 ≥ 14px，logo 图片需要先转为 base64 编码然后直接插入到 URL 中（可以用 <a href="http://b64.io/" target="_blank" rel="external">http://b64.io/</a> 将图片转为 base64 编码的字符串），格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?logo=&#123;base64 编码后的图片数据&#125;</div></pre></td></tr></table></figure>
<p>示例代码和效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII" alt=""></p>
<h3 id="4-logoWidth"><a href="#4-logoWidth" class="headerlink" title="4. logoWidth"></a>4. logoWidth</h3><p>该参数可以设置在上一个参数 logo 中添加的图标的宽度，设为 0 的话即为忽略该参数，示例代码和效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&amp;logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&amp;logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII" alt=""></p>
<h3 id="5-link"><a href="#5-link" class="headerlink" title="5. link"></a>5. link</h3><p>据说该参数是用来设置点击后跳转的 URL 的（嗯，俗称超链接），官方描述如下：</p>
<ul>
<li>Specify what clicking on the left/right of a badge should do (esp. for social badge style)</li>
</ul>
<p>不过试了一下好像没啥效果（并且实在是没想明白怎么通过返回的图片控制不同点击区域的跳转），如果有大佬知道的求指点，感谢！</p>
<h3 id="6-colorA"><a href="#6-colorA" class="headerlink" title="6. colorA"></a>6. colorA</h3><p>该参数用来控制徽标左半部分的背景色，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将左半部分的背景色改为 0xabcdef，代码和效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef" alt=""></p>
<h3 id="7-colorB"><a href="#7-colorB" class="headerlink" title="7. colorB"></a>7. colorB</h3><p>该参数用来控制徽标右半部分的背景色，同上，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将右半部分的背景色改为 0xabcdef，代码和效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef)</div></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef" alt=""></p>
<h3 id="8-maxAge"><a href="#8-maxAge" class="headerlink" title="8. maxAge"></a>8. maxAge</h3><p>该参数用来设置 HTTP 缓存时间，以秒为单位，直接在 svg 地址后跟 <code>?maxAge={缓存秒数}</code> 即可，好像没啥好预览的，不放效果图了。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>这里需要注意的是，如果你是引用的第三方 svg 然后添加自己的样式，如果该样式之前已经被第三方添加过，是不一定会覆盖第三方的设置的，也就是说自己设置的属性不一定会生效…例如下面的代码设置 colorB 就没生效：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000)</div></pre></td></tr></table></figure>
<p>右半部分应该变成黑色，但是毫无效果的说：</p>
<p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000" alt=""></p>
<h1 id="四-其他"><a href="#四-其他" class="headerlink" title="四. 其他"></a>四. 其他</h1><p>默认的徽标是居左排列的，如果需要居中排列需要使用 HTML 的方式来插入徽标，可参考 <a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="external">Kingfisher</a>，代码和效果如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://travis-ci.org/onevcat/Kingfisher"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/travis/onevcat/Kingfisher/master.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/Carthage/Carthage/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://swift.org/package-manager/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/badge/SPM-ready-orange.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://onevcat.github.io/Kingfisher/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://onevcat.github.io/Kingfisher/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://codebeat.co/projects/github-com-onevcat-kingfisher"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">"codebeat badge"</span> <span class="attr">src</span>=<span class="string">"https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p align="center"><br><a href="https://travis-ci.org/onevcat/Kingfisher" target="_blank" rel="external"><img src="https://img.shields.io/travis/onevcat/Kingfisher/master.svg"></a><br><a href="https://github.com/Carthage/Carthage/" target="_blank" rel="external"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"></a><br><a href="https://swift.org/package-manager/" target="_blank" rel="external"><img src="https://img.shields.io/badge/SPM-ready-orange.svg"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat"></a><br><a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="external"><img src="https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat"></a><br><a href="https://codebeat.co/projects/github-com-onevcat-kingfisher" target="_blank" rel="external"><img alt="codebeat badge" src="https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg"></a><br></p>

<p>没了，🙄</p>
<hr>
<blockquote>
<p>原文链接：<a href="https://github.com/EyreFree/GitHubBadgeIntroduction" target="_blank" rel="external">https://github.com/EyreFree/GitHubBadgeIntroduction</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多同学在 GitHub 上发布了自己的开源项目，有辛苦开发的实用工具、构思巧妙的开源库、别具一格的 App、精心整理的示例代码等等。&lt;/p&gt;
&lt;p&gt;自己花了大把时间和精力构建的项目，当然是希望能够得到更多人的关注，被更多的人知晓或者使用。如何更好滴向他人展示自己的项目，介绍项目相关信息呢？用一些通用的小图标来描述项目相关信息不失为一种很棒的选择，几个好看的徽标能够为自己的项目说明增色不少！&lt;/p&gt;
&lt;h1 id=&quot;一-徽标简介&quot;&gt;&lt;a href=&quot;#一-徽标简介&quot; class=&quot;headerlink&quot; title=&quot;一. 徽标简介&quot;&gt;&lt;/a&gt;一. 徽标简介&lt;/h1&gt;&lt;p&gt;GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。&lt;/p&gt;
&lt;p&gt;徽标主要由图片和对应的链接（当然，你可以不填）组成，徽标图片的话一般由左半部分的名称和右半部分的值组成。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="github" scheme="http://www.imeetyou.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式(Adapter)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-adapter.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-adapter.html</id>
    <published>2017-04-24T09:26:19.000Z</published>
    <updated>2017-04-24T09:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。</p>
<p>适配器的别名是包装器(wrapper)，这是一个相对简单的模式。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="现实中的适配器——apple的各种转接头"><a href="#现实中的适配器——apple的各种转接头" class="headerlink" title="现实中的适配器——apple的各种转接头"></a>现实中的适配器——apple的各种转接头</h3><p>相信大家对apple对各种设备设计精良，用户使用方便比较赞同，但是针对各种转接头又有各种吐槽，其实转接头是不是就对应我们但适配器呢？</p>
<a id="more"></a>
<p>如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种 “亡羊补牢”的模式，没有人会在程序的设计之初就使用它。因为没有人可以完全预料到未来的事情，也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式 把旧接口包装成一个新的接口，使它继续保持生命力。比较典型但就是最新但 iphone7 去掉了耳机接口，提供了额外但转接头。也许以后充电口也会去掉，用无线充电，并且提供额外但转接设备。</p>
<h3 id="地图调用"><a href="#地图调用" class="headerlink" title="地图调用"></a>地图调用</h3><p>当我们向 googleMap 和 baiduMap 都发出“显示”请求时，googleMap 和 baiduMap 分别以各自的方式在页面中展现了地图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var googleMap = &#123;</div><div class="line">    show: function() &#123;</div><div class="line">        console.log( &apos;开始渲染谷歌地图&apos; );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var baiduMap = &#123;</div><div class="line">    show: function()&#123;</div><div class="line">        console.log( &apos;开始渲染百度地图&apos; );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var renderMap = function( map ) &#123;</div><div class="line">    if ( map.show instanceof Function )&#123;</div><div class="line">        map.show();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">renderMap( googleMap ); // 输出:开始渲染谷歌地图</div><div class="line">renderMap( baiduMap ); // 输出:开始渲染百度地图</div></pre></td></tr></table></figure>
<p>因为 googleMap 和 baiduMap 提供了一致的 show 方法，但第三方的接口方法并不在我们自己的控制范围之内，假如 baiduMap 提供的显示地图的方法不叫 show 而叫 display 呢? baiduMap 这个对象来源于第三方，正常情况下我们都没办法改动它。此时我们可以通过增加 baiduMapAdapter 来解决问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var googleMap = &#123;</div><div class="line">    show: function() &#123;</div><div class="line">        console.log( &apos;开始渲染谷歌地图&apos; );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var baiduMap = &#123;</div><div class="line">    display: function()&#123;</div><div class="line">        console.log( &apos;开始渲染百度地图&apos; );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var baiduMapAdapter = &#123;</div><div class="line">    show: function()&#123;</div><div class="line">        return baiduMap.display();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var renderMap = function( map ) &#123;</div><div class="line">    if ( map.show instanceof Function )&#123;</div><div class="line">        map.show();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">renderMap( googleMap ); // 输出:开始渲染谷歌地图</div><div class="line">renderMap( baiduMapAdapter );; // 输出:开始渲染百度地图</div></pre></td></tr></table></figure>
<h3 id="动物叫声"><a href="#动物叫声" class="headerlink" title="动物叫声"></a>动物叫声</h3><p>鸭子但叫声为 quack, 而公鸡但叫声为 crow, 假如我们也要公鸡实现嘎嘎叫（quack）这个动作。我们就可以复用鸭子但quack方法，但发出但声音还是 crow 的。</p>
<p>首先要先定义鸭子和火鸡的抽象行为，也就是各自的方法函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Duck = function()&#123; &#125;</div><div class="line">Duck.prototype.quack =function() &#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Cock = function()&#123; &#125;</div><div class="line">Cock.prototype.crow = function() &#123;</div><div class="line">    throw new Error(&quot; 该方法必须被重写 !&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再定义具体的鸭子和公鸡的构造函数，分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var MallarDuck = function() &#123;</div><div class="line">    Duck.apply(this);</div><div class="line">&#125;</div><div class="line">MallarDuck.prototype = new Duck();</div><div class="line">MallarDuck.prototype.quack = function() &#123;</div><div class="line">    console.log(&quot;嘎嘎！嘎嘎！&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var WildCock = function() &#123;</div><div class="line">    Cock.apply(this);</div><div class="line">&#125;</div><div class="line">WildCock.prototype = new Cock();</div><div class="line">WildCock.prototype.crow = function() &#123;</div><div class="line">    console.log(&quot;咯咯！咯咯！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了让公鸡也支持quack方法，我们创建了一个新的公鸡适配器 CockAdapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var CockAdapter = function(ck) &#123;</div><div class="line">    Duck.apply(this);</div><div class="line">    this.ck = ck;</div><div class="line">&#125;</div><div class="line">CockAdapter.prototype = new Duck();</div><div class="line">CockAdapter.prototype.quack = function() &#123;</div><div class="line">    this.ck.crow();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该构造函数接受一个公鸡的实例对象，然后使用 Duck 进行 apply，其适配器原型是 Duck，然后要重新修改其原型的quack方法，以便内部调用 ck.crow() 方法。</p>
<p>测试一下便可以知道结果了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var oDuck = new MallarDuck()</div><div class="line">var oCock = new WildCock()</div><div class="line">var oCkadapter = new CockAdapter(oCock);</div><div class="line"></div><div class="line">// 原有的鸭子行为</div><div class="line">oDuck.quack();  // 嘎嘎！嘎嘎！</div><div class="line">// 原有但公鸡行为</div><div class="line">oCock.crow(); // 咯咯！咯咯！</div><div class="line"></div><div class="line">// 适配器公鸡的行为</div><div class="line">oCkadapter.quack(); // 咯咯！咯咯！</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那合适使用适配器模式好呢？如果有以下情况出现时，建议使用：</p>
<ul>
<li>1、使用一个已经存在的对象，但其方法或属性接口不符合你的要求；</li>
<li>2、你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作；</li>
<li>3、想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。</li>
</ul>
<p>另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别：</p>
<ul>
<li><strong>适配器模式</strong>主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</li>
<li><strong>装饰者模式和代理模式</strong>也不会改变原有对象的接口，但装饰者模式的作用是为了给对象<strong>增加功能</strong>。装饰者模式常常形成一条长的装饰链，而<strong>适配器模式通常只包装一次</strong>。<strong>代理模式是为了控制对对象的访问</strong>，通常也只包装一次。</li>
<li><strong>外观模式</strong>的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</li>
</ul>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。&lt;/p&gt;
&lt;p&gt;适配器的别名是包装器(wrapper)，这是一个相对简单的模式。&lt;/p&gt;
&lt;h2 id=&quot;使用实例&quot;&gt;&lt;a href=&quot;#使用实例&quot; class=&quot;headerlink&quot; title=&quot;使用实例&quot;&gt;&lt;/a&gt;使用实例&lt;/h2&gt;&lt;h3 id=&quot;现实中的适配器——apple的各种转接头&quot;&gt;&lt;a href=&quot;#现实中的适配器——apple的各种转接头&quot; class=&quot;headerlink&quot; title=&quot;现实中的适配器——apple的各种转接头&quot;&gt;&lt;/a&gt;现实中的适配器——apple的各种转接头&lt;/h3&gt;&lt;p&gt;相信大家对apple对各种设备设计精良，用户使用方便比较赞同，但是针对各种转接头又有各种吐槽，其实转接头是不是就对应我们但适配器呢？&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰者模式(Decorator)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-decorator.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-decorator.html</id>
    <published>2017-04-21T01:16:39.000Z</published>
    <updated>2017-04-21T01:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>装饰者提供比继承更有弹性的替代方案。 装饰者用用于包装同接口的对象，不仅允许你向方法添加行为，而且还可以将方法设置成原始对象调用（例如装饰者的构造函数）。</p>
<p>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给对象动态地增加职责的方式称为装饰者(decorator)模式。</p>
<p>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>那么装饰者模式有什么好处呢？前面说了，装饰者是一种实现继承的替代方案。当脚本运行时，在子类中增加行为会影响原有类所有的实例，而装饰者却不然。取而代之的是它能给不同对象各自添加新行为。</p>
<p>比如有个Student类，我们需要获得一个学生的一年的总花费。而一个学生这一年可能需要：学费（必交）、住宿舍交宿舍费、买书交书费、交女朋友。那么它的总花费应该是这些的和，有的没有女朋友，那么花费计算就不一样了，可以像如下方式进行定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 定制基本款</div><div class="line">function macbook(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.getName = function() &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;;</div><div class="line">    this.getCost = function() &#123;</div><div class="line">        return 13888; //</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">//定义装饰器，需要提高cup</div><div class="line">function NeedCPU(macbook) &#123;</div><div class="line">    var cost = macbook.getCost();</div><div class="line">    macbook.getCost = function() &#123;</div><div class="line">        return cost + 2280;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">//定义装饰器，需要扩展内存</div><div class="line">function NeedMemory(macbook) &#123;</div><div class="line">    var cost = macbook.getCost();</div><div class="line">    macbook.getCost = function() &#123;</div><div class="line">        return cost + 1520;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">//定义装饰器，需要预先安装正版软件</div><div class="line">function NeedSoft(macbook) &#123;</div><div class="line">    var cost = macbook.getCost();</div><div class="line">    macbook.getCost = function() &#123;</div><div class="line">        return cost + 1298;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就定义好了三个可选的装饰器，分别表示需要宿舍，需要书本，有女朋友。那么创建两个学生对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var xmMacBook = new macbook(&quot;小明&quot;);</div><div class="line">NeedCPU(xmMacBook);</div><div class="line">NeedMemory(xmMacBook);</div><div class="line">NeedSoft(xmMacBook);</div><div class="line">console.log(xmMacBook.getName() + &quot;的macbook需要人民币：&quot; + xmMacBook.getCost());</div><div class="line"></div><div class="line">var wangMacBook = new macbook(&quot;小王&quot;);</div><div class="line">NeedCPU(wangMacBook);</div><div class="line">NeedMemory(wangMacBook);</div><div class="line">console.log(wangMacBook.getName() + &quot;的macbook需要人民币：&quot; + wangMacBook.getCost());</div><div class="line"></div><div class="line">// 小明的macbook需要人民币：18986</div><div class="line">// 小王的macbook需要人民币：17688</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。优点是把类（函数）的核心职责和装饰功能区分开了。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;装饰者提供比继承更有弹性的替代方案。 装饰者用用于包装同接口的对象，不仅允许你向方法添加行为，而且还可以将方法设置成原始对象调用（例如装饰者的构造函数）。&lt;/p&gt;
&lt;p&gt;装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;给对象动态地增加职责的方式称为装饰者(decorator)模式。&lt;/p&gt;
&lt;p&gt;装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之中介者模式(Mediator)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-mediator.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-mediator.html</id>
    <published>2017-04-19T04:36:29.000Z</published>
    <updated>2017-04-19T07:51:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系.</p>
<a id="more"></a>
<p><img src="http://og8z552x2.bkt.clouddn.com/js-mediator.png" alt="中介者模式"></p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>开发中，中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。</p>
<p>打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="购买商品筛选"><a href="#购买商品筛选" class="headerlink" title="购买商品筛选"></a>购买商品筛选</h3><p>假设我们正在编写一个手机购买的页面，在购买流程中，</p>
<ul>
<li>选择手机颜色、购买数量（如果购买数量大于库存则显示库存不足，禁用下一步按钮）</li>
<li>下一步按钮，加入购物车</li>
</ul>
<p>可能想到的扩展，购买过程中不仅选择筛选颜色，还会加入内存、品牌、价格区间等等。</p>
<p>为了减少耦合，筛选条件之间彼此独立，引入中介者模式，当其中某个条件发生改变时，仅仅通知中介者它被改变了， 同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需要改动中介者对象里的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">var goods = &#123;  // 手机库存</div><div class="line">	&quot;red|32G&quot;: 3,</div><div class="line">	&quot;red|16G&quot;: 0,</div><div class="line">	&quot;blue|32G&quot;: 1,</div><div class="line">	&quot;blue|16G&quot;: 6</div><div class="line">&#125;</div><div class="line"></div><div class="line">var mediator = (function() &#123;</div><div class="line">	var colorSelect = document.getElementById( &apos;colorSelect&apos; ),</div><div class="line">		memorySelect = document.getElementById( &apos;memorySelect&apos; ),</div><div class="line">		numberInput = document.getElementById( &apos;numberInput&apos; ),</div><div class="line">		colorInfo = document.getElementById( &apos;colorInfo&apos; ),</div><div class="line">		memoryInfo = document.getElementById( &apos;memoryInfo&apos; ),</div><div class="line">		numberInfo = document.getElementById( &apos;numberInfo&apos; ),</div><div class="line">		nextBtn = document.getElementById( &apos;nextBtn&apos; );</div><div class="line">	return &#123;</div><div class="line">		changed: function( obj )&#123;</div><div class="line">			var color = colorSelect.value, // 颜色</div><div class="line">			memory = memorySelect.value,// 内存</div><div class="line">			number = numberInput.value, // 数量</div><div class="line">			stock = goods[ color + &apos;|&apos; + memory ];</div><div class="line">			// 颜色和内存对应的手机库存数量</div><div class="line">			if ( obj === colorSelect )&#123; // 如果改变的是选择颜色下拉框</div><div class="line">				colorInfo.innerHTML = color;</div><div class="line">			&#125; else if ( obj === memorySelect ) &#123;</div><div class="line">				memoryInfo.innerHTML = memory;</div><div class="line">			&#125; else if ( obj === numberInput ) &#123;</div><div class="line">				numberInfo.innerHTML = number;</div><div class="line">			&#125;</div><div class="line">			if ( !color ) &#123;</div><div class="line">				nextBtn.disabled = true;</div><div class="line">				nextBtn.innerHTML = &apos;请选择手机颜色&apos;;</div><div class="line">				return;</div><div class="line">			&#125;</div><div class="line">			if ( !memory ) &#123;</div><div class="line">				nextBtn.disabled = true;</div><div class="line">				nextBtn.innerHTML = &apos;请选择内存大小&apos;;</div><div class="line">				return;</div><div class="line">			&#125;</div><div class="line">			if ( ( ( number - 0 ) | 0 ) !== number - 0 )&#123;</div><div class="line">				nextBtn.disabled = true;</div><div class="line">				nextBtn.innerHTML = &apos;请输入正确的购买数量&apos;;</div><div class="line">				return;</div><div class="line">			&#125;</div><div class="line">			nextBtn.disabled = false;</div><div class="line">			nextBtn.innerHTML = &apos;放入购物车&apos;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 事件函数:</div><div class="line">colorSelect.onchange = function()&#123;</div><div class="line">	mediator.changed( this );</div><div class="line">&#125;;</div><div class="line">memorySelect.onchange = function()&#123;</div><div class="line">	mediator.changed( this );</div><div class="line">&#125;;</div><div class="line">numberInput.oninput = function()&#123;</div><div class="line">	mediator.changed( this );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上，如果某一天又要新增一些筛选选择条件，我们只需要修改 mediator 对象即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象(类似不和陌生人说话)。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象，跟“城门失火，殃及池鱼”的道理是一样的。而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系.&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之职责链模式(Chain of responsibility)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-chain-of-responsibility.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-chain-of-responsibility.html</id>
    <published>2017-04-17T09:46:19.000Z</published>
    <updated>2017-04-18T09:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>职责链模式的定义</strong>：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 5 的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对 象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>假设我们负责一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定<br>后(订单已在此时生成)，现在已经到了正式购买的阶段。</p>
<p>公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用 户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金 的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。</p>
<p>在页面加载之初，后端会传递给页面几个字段。</p>
<ul>
<li><strong>orderType</strong>：表示订单类型(定金用户或者普通购买用户)，code 的值为 1 的时候是 500 元 定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户。</li>
<li><strong>pay</strong>：表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的 订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。</li>
<li><strong>stock</strong>：表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用 户不受此限制。</li>
</ul>
<p>看到上面的需求，简单点可以想到有用 <code>if</code> <code>else</code> 分之来实现，但肯定会比较难以维护及扩展。</p>
<p>那么就将此需求用职责链模式重构代码：</p>
<p>首先需要 3 种购买模式的节点函数，我们约定，如果某个节点不能处理请<br>求，则返回一个特定的字符串 ‘nextSuccessor’来表示该请求需要继续往后面传递:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 500 元订单</div><div class="line">var order500 = function(orderType, pay, stock) &#123;</div><div class="line">     if (orderType === 1 &amp;&amp; pay === true ) &#123;</div><div class="line">         console.log(&apos;500 元定金预购, 得到 100 优惠券&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        return &apos;nextSuccessor&apos;; // 我不知道下一个节点是谁，反正把请求往后面传递</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 200 元订单</div><div class="line">var order200 = function(orderType, pay, stock) &#123;</div><div class="line">    if (orderType === 2 &amp;&amp; pay === true ) &#123;</div><div class="line">        console.log(&apos;200 元定金预购, 得到 50 优惠券&apos;);</div><div class="line">   &#125; else &#123;</div><div class="line">       return &apos;nextSuccessor&apos;; // 我不知道下一个节点是谁，反正把请求往后面传递</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">// 普通购买订单</div><div class="line">var orderNormal = function(orderType, pay, stock) &#123;</div><div class="line">    if (stock &gt; 0) &#123;</div><div class="line">        console.log(&apos;普通购买, 无优惠券&apos;);</div><div class="line">   &#125; else &#123;</div><div class="line">       console.log( &apos;手机库存不足&apos; );</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来需要把函数包装进职责链节点，我们定义一个构造函数 Chain，在 new Chain 的时候传 递的参数即为需要被包装的函数， 同时它还拥有一个实例属性 this.successor，表示在链中的下 一个节点。</p>
<p>此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Chain.prototype.setNextSuccessor 指定在链中的下一个节点</div><div class="line">// Chain.prototype.passRequest 传递请求给某个节点</div><div class="line"></div><div class="line">var Chain = function(fn)&#123;</div><div class="line">    this.fn = fn;</div><div class="line">    this.successor = null;</div><div class="line">&#125;;</div><div class="line">Chain.prototype.setNextSuccessor = function(successor) &#123;</div><div class="line">    return this.successor = successor;</div><div class="line">&#125;;</div><div class="line">Chain.prototype.passRequest = function() &#123;</div><div class="line">    var ret = this.fn.apply(this, arguments);</div><div class="line">    if (ret === &apos;nextSuccessor&apos;) &#123;</div><div class="line">        return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们把 3 个订单函数分别包装成职责链的节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var chainOrder500 = new Chain(order500);</div><div class="line">var chainOrder200 = new Chain(order200);</div><div class="line">var chainOrderNormal = new Chain(orderNormal);</div></pre></td></tr></table></figure>
<p>然后指定节点在职责链中的顺序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chainOrder500.setNextSuccessor(chainOrder200);</div><div class="line">chainOrder200.setNextSuccessor(chainOrderNormal);</div></pre></td></tr></table></figure>
<p>最后把请求传递给第一个节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">chainOrder500.passRequest(1, true, 500); // 输出:500 元定金预购，得到 100 优惠券</div><div class="line">chainOrder500.passRequest(2, true, 500); // 输出:200 元定金预购，得到 50 优惠券</div><div class="line">chainOrder500.passRequest(3, true, 500); // 输出:普通购买，无优惠券</div><div class="line">chainOrder500.passRequest(1, false, 0);  // 输出:手机库存不足</div></pre></td></tr></table></figure>
<p>通过改进，我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员 又想出了支持 300 元定金购买，那我们就在该链中增加一个节点即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var order300 = function()&#123;</div><div class="line">	// 具体实现略</div><div class="line">&#125;;</div><div class="line">chainOrder300= new Chain( order300 );</div><div class="line">chainOrder500.setNextSuccessor( chainOrder300);</div><div class="line">chainOrder300.setNextSuccessor( chainOrder200);</div></pre></td></tr></table></figure>
<p>在这里完全不用理会原来的订单函数代码，我们要做的只是增 加一个节点，然后重新设置链中相关节点的顺序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>职责链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。</p>
<p>无论是作用域链、原型链，还是 DOM 节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;职责链模式的定义&lt;/strong&gt;：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 5 的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;
&lt;p&gt;职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对 象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>call()、apply()、bind()的用法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-call-apply-bind.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-call-apply-bind.html</id>
    <published>2017-04-11T04:26:09.000Z</published>
    <updated>2017-04-11T02:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在javascript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中， 作为参数传入另外一个函数等。</p>
<h2 id="bind、call、apply"><a href="#bind、call、apply" class="headerlink" title="bind、call、apply"></a>bind、call、apply</h2><p>每一个函数都包含一个 prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。 每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p>
<h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p>call() 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法.</p>
<blockquote>
<p>注意：该方法的作用和 apply() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</div><div class="line"></div><div class="line">fun.apply(thisArg[, argsArray])</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>apply 与 call() 非常相似，不同之处在于提供参数的方式。</p>
<p>apply 使用参数数组而不是一组参数列表，apply 可以使用数组字面量（array literal），</p>
<p>如：fun.apply(this, [‘eat’, ‘bananas’])，或数组对象，</p>
<p>如：fun.apply(this, new Array(‘eat’, ‘bananas’))。</p>
<h3 id="使用call方法调用函数并且指定上下文的’this’"><a href="#使用call方法调用函数并且指定上下文的’this’" class="headerlink" title="使用call方法调用函数并且指定上下文的’this’"></a>使用call方法调用函数并且指定上下文的’this’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function greet() &#123;</div><div class="line">  var arr = [this.person, &apos;is age&apos;, this.age].join(&apos; &apos;);</div><div class="line">  console.log(arr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var i = &#123;</div><div class="line">  person: &quot;wang&quot;,</div><div class="line">  age: 20</div><div class="line">&#125;</div><div class="line"></div><div class="line">greet.call(i); // 这里的 this 会绑定到 i 对象上。</div></pre></td></tr></table></figure>
<h3 id="使用call方法调用匿名函数"><a href="#使用call方法调用匿名函数" class="headerlink" title="使用call方法调用匿名函数"></a>使用call方法调用匿名函数</h3><p>在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var animals = [</div><div class="line">  &#123;species: &apos;Lion&apos;, name: &apos;King&apos;&#125;,</div><div class="line">  &#123;species: &apos;Whale&apos;, name: &apos;Fail&apos;&#125;</div><div class="line">];</div><div class="line"></div><div class="line">for (var i = 0; i &lt; animals.length; i++) &#123;</div><div class="line">  (function (i) &#123;</div><div class="line">    this.print = function () &#123;</div><div class="line">      console.log(&apos;#&apos; + i  + &apos; &apos; + this.species + &apos;: &apos; + this.name);</div><div class="line">    &#125;</div><div class="line">    this.print();</div><div class="line">  &#125;).call(animals[i], i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用apply和内置函数"><a href="#使用apply和内置函数" class="headerlink" title="使用apply和内置函数"></a>使用apply和内置函数</h3><p>聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。在接下里的例子中我们会使用Math.max/Math.min来找出一个数组中的最大/最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var numbers = [5, 6, 2, 3, 7];</div><div class="line"></div><div class="line">var max = Math.max.apply(null, numbers); /* This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) */</div><div class="line">var min = Math.min.apply(null, numbers);</div><div class="line"></div><div class="line">max = -Infinity, min = +Infinity;</div><div class="line"></div><div class="line">for (var i = 0; i &lt; numbers.length; i++) &#123;</div><div class="line">  if (numbers[i] &gt; max)</div><div class="line">    max = numbers[i];</div><div class="line">  if (numbers[i] &lt; min)</div><div class="line">    min = numbers[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2><p><code>bind()</code> 方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
<p><code>bind()</code>是在ES5中新增的方法，从名字可以看出，这个方法的主要作用就是将函数绑定到某个对象。</p>
<h3 id="创建绑定函数"><a href="#创建绑定函数" class="headerlink" title="创建绑定函数"></a>创建绑定函数</h3><p>bind() 最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。</p>
<p>经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，希望方法中的 this 是原来的对象。（比如在回调中传入这个方法。）如果不做特殊处理的话，一般会丢失原来的对象。从原来的函数和原来的对象创建一个绑定函数，则能很漂亮地解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var x = 9;</div><div class="line">var obj = &#123;</div><div class="line">	x: 81,</div><div class="line">    getX: function() &#123;</div><div class="line">		return this.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.getX(); // 返回 81</div><div class="line"></div><div class="line">var b = obj.getX;</div><div class="line">b() // 返回 9, 在这种情况下，&quot;this&quot;指向全局作用域</div><div class="line"></div><div class="line">// 创建一个新函数，将&quot;this&quot;绑定到obj对象</div><div class="line">// 新手可能会被全局的x变量和obj里的属性x所迷惑</div><div class="line">var bindX = b.bind(obj);</div><div class="line">bindX(); // 返回 81</div></pre></td></tr></table></figure>
<p>当在函数f()上调用bind()方法并后传入一个对象o作为参数，这个方法将返回一个新函数： （以函数调用的方式）调用新的函数将会把原始的函数f()作为o的方法来调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function f(y) &#123;</div><div class="line">  return this.x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var o = &#123;</div><div class="line">  x: 1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var g = f.bind(o);  // 通过调用 g(x) 来调用 o.f(x)</div><div class="line">g(2); // 3</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考引用资料</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">MDN JavaScript 参考文档</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在javascript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中， 作为参数传入另外一个函数等。&lt;/p&gt;
&lt;h2 id=&quot;bind、call、apply&quot;&gt;&lt;a href=&quot;#bind、call、apply&quot; class=&quot;headerlink&quot; title=&quot;bind、call、apply&quot;&gt;&lt;/a&gt;bind、call、apply&lt;/h2&gt;&lt;p&gt;每一个函数都包含一个 prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。 每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。&lt;/p&gt;
&lt;h2 id=&quot;Function-prototype-call&quot;&gt;&lt;a href=&quot;#Function-prototype-call&quot; class=&quot;headerlink&quot; title=&quot;Function.prototype.call()&quot;&gt;&lt;/a&gt;Function.prototype.call()&lt;/h2&gt;&lt;p&gt;call() 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：该方法的作用和 apply() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fun.call(thisArg[, arg1[, arg2[, ...]]])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fun.apply(thisArg[, argsArray])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="call" scheme="http://www.imeetyou.net/tags/call/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式(Flyweight)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-flyweight.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-flyweight.html</id>
    <published>2017-04-07T04:36:39.000Z</published>
    <updated>2017-04-07T08:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。</p>
<p>享元模式可以避免大量非常相似类的开销，在程序设计中，有时需要生产大量细粒度的类实例来表示数据，如果能发现这些实例除了几个参数以外，开销基本相同的话，就可以大幅度较少需要实例化的类的数量。如果能把那些参数移动到类实例的外面，在方法调用的时候将他们传递进来，就可以通过共享大幅度第减少单个实例的数目。</p>
<p>那么如果在JavaScript中应用享元模式呢？有两种方式：</p>
<ul>
<li>第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；</li>
<li>第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄</li>
</ul>
<a id="more"></a>
<h2 id="享元与数据层"><a href="#享元与数据层" class="headerlink" title="享元与数据层"></a>享元与数据层</h2><p>享元模式要求将对象的属性划分为内部状态与外部状态(状态在这里通常指属性)。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。</p>
<ul>
<li>内部状态存储于对象内部。</li>
<li>内部状态可以被一些对象共享。</li>
<li>内部状态独立于具体的场景，通常不会改变。</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li>
</ul>
<p>说白点,就是先捏一个的原始模型，然后随着不同场合和环境,再产生各具特征的具体模型，很显然,在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式，Flyweight的内部状态是用来共享的，Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><strong>如下场景：</strong></p>
<p>图书馆有很多书，设计一个管理系统管理所有的借书信息</p>
<p>假定每个书的内容有：<code>title</code>、<code>author</code>、<code>id</code>、<code>site</code></p>
<p>每本书被借出时间、借书人、归还日期、是否可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">checkoutDate</div><div class="line">checkoutMember</div><div class="line">dueReturnDate</div><div class="line">availability</div></pre></td></tr></table></figure>
<p>我们可以将数据分成内部和外部两种数据，和book对象相关的数据（title, author 等）可以归结为内部属性，而（checkoutMember, dueReturnDate等）可以归结为外部属性。这样，如下代码就可以在同一本书里共享同一个对象了，因为不管谁借的书，只要书是同一本书，基本信息是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 内部公共属性</div><div class="line">var Book = function(title, author, id, ISBN) &#123;</div><div class="line">    this.title = title;</div><div class="line">    this.author = author;</div><div class="line">    this.id = id;</div><div class="line">    this.ISBN = ISBN</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定义基本工厂"><a href="#定义基本工厂" class="headerlink" title="定义基本工厂"></a>定义基本工厂</h3><p>让我们来定义一个基本工厂，用来检查之前是否创建该book的对象，如果有就返回，没有就重新创建并存储以便后面可以继续访问，这确保我们为每一种书只创建一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// book工厂</div><div class="line">var BookFactory = (function()&#123;</div><div class="line">    var existingBooks = &#123;&#125;;</div><div class="line">    return &#123;</div><div class="line">        createBook: function(title, author, id, ISBN) &#123;</div><div class="line">           // 查找之前是否创建</div><div class="line">           var existingBook = existingBooks[ISBN];</div><div class="line">           if (existingBook) &#123;</div><div class="line">                   return existingBook;</div><div class="line">               &#125; else &#123;</div><div class="line">               // 如果没有，就创建一个，然后保存</div><div class="line">               var book = new Book(title, author, id, ISBN);</div><div class="line">               existingBooks[ISBN] =  book;</div><div class="line">               return book;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="管理外部状态"><a href="#管理外部状态" class="headerlink" title="管理外部状态"></a>管理外部状态</h3><p>外部状态，相对就简单了，除了我们封装好的book，其它都需要在这里管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var BookRecord = (function() &#123;</div><div class="line">    var bookRecordDatabase = &#123;&#125;;</div><div class="line">    return &#123;</div><div class="line">        addBook: function(title, author, id, ISBN, checkoutDate, checkoutMember, dueReturnDate, availability) &#123;</div><div class="line">            var book = BookFactory.createBook(title, author, id, ISBN);</div><div class="line">            bookRecordDatabase[id] = &#123;</div><div class="line">               checkoutMember: checkoutMember,</div><div class="line">               checkoutDate: checkoutDate,</div><div class="line">               dueReturnDate: dueReturnDate,</div><div class="line">               availability: availability,</div><div class="line">               book: book</div><div class="line">           &#125;;</div><div class="line">           console.log(bookRecordDatabase);</div><div class="line">       &#125;,</div><div class="line">       updateCheckoutStatus: function(bookID, newStatus, checkoutDate, checkoutMember, newReturnDate)&#123;</div><div class="line">            var record = bookRecordDatabase[bookID];</div><div class="line">            record.availability = newStatus;</div><div class="line">            record.checkoutDate = checkoutDate;</div><div class="line">            record.checkoutMember = checkoutMember;</div><div class="line">            record.dueReturnDate = newReturnDate;</div><div class="line">       &#125;,</div><div class="line">       extendCheckoutPeriod: function(bookID, newReturnDate) &#123;</div><div class="line">           bookRecordDatabase[bookID].dueReturnDate = newReturnDate;</div><div class="line">       &#125;,</div><div class="line">       isPastDue: function(bookID) &#123;</div><div class="line">           var currentDate = new Date();</div><div class="line">           return currentDate.getTime() &gt; Date.parse(bookRecordDatabase[bookID].dueReturnDate);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>通过这种方式，我们做到了将同一种图书的相同信息保存在一个bookmanager对象里，而且只保存一份；相比之前的代码，就可以发现节约了很多内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样。在一个存在<br>大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。&lt;/p&gt;
&lt;p&gt;享元模式可以避免大量非常相似类的开销，在程序设计中，有时需要生产大量细粒度的类实例来表示数据，如果能发现这些实例除了几个参数以外，开销基本相同的话，就可以大幅度较少需要实例化的类的数量。如果能把那些参数移动到类实例的外面，在方法调用的时候将他们传递进来，就可以通过共享大幅度第减少单个实例的数目。&lt;/p&gt;
&lt;p&gt;那么如果在JavaScript中应用享元模式呢？有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；&lt;/li&gt;
&lt;li&gt;第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板模式(TemplateMethod)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-template.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-template.html</id>
    <published>2017-04-06T09:56:39.000Z</published>
    <updated>2017-04-06T07:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这不代表继承在 JavaScript 里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型 prototype 来变相地实现继承。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板方法模式是一种只需使用继承就可以实现的非常简单的模式。</p>
<p><strong>模板方法模式由两部分结构组成：</strong></p>
<ul>
<li>第一部分是抽象父类，</li>
<li>第二部分是具体的实现子类。</li>
</ul>
<p>通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="Coffee-or-Tea"><a href="#Coffee-or-Tea" class="headerlink" title="Coffee or Tea"></a>Coffee or Tea</h3><p>咖啡与茶是一个经典的例子，经常用来讲解模板方法模式</p>
<p>泡茶和泡咖啡有同样的步骤，比如烧开水（boilWater）、冲泡（brew）、倒在杯子里（pourInCup），加小料（addCondiments）等等。</p>
<p>但每种饮料冲泡的方法以及所加的小料不一样，所以我们可以利用模板方法实现这个主要步骤</p>
<p>首先先来定义抽象步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Beverage = function()&#123;&#125;;</div><div class="line">Beverage.prototype.boilWater = function()&#123;</div><div class="line">	 console.log( &apos;把水煮沸&apos; );</div><div class="line">&#125;;</div><div class="line">Beverage.prototype.brew = function()&#123;&#125;; // 空方法，应该由子类重写</div><div class="line">Beverage.prototype.pourInCup = function()&#123;&#125;; // 空方法，应该由子类重写</div><div class="line">Beverage.prototype.addCondiments = function()&#123;&#125;; // 空方法，应该由子类重写</div><div class="line">Beverage.prototype.init = function()&#123;</div><div class="line">	this.boilWater();</div><div class="line">	this.brew();</div><div class="line">	this.pourInCup();</div><div class="line">	this.addCondiments();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来我们要创建咖啡类和茶类，并让它们继承抽象类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 冲咖啡</div><div class="line">var Coffee = function()&#123;&#125;;</div><div class="line">Coffee.prototype = new Beverage();</div><div class="line">Coffee.prototype.brew = function() &#123;</div><div class="line">	console.log( &apos;用沸水冲泡咖啡&apos; );</div><div class="line">&#125;</div><div class="line">Coffee.prototype.pourInCup = function() &#123;</div><div class="line">	console.log( &apos;把咖啡倒进杯子&apos; );</div><div class="line">&#125;</div><div class="line">Coffee.prototype.addCondiments = function() &#123;</div><div class="line">	console.log( &apos;加糖和牛奶&apos; );</div><div class="line">&#125;</div><div class="line">var Coffee = new Coffee();</div><div class="line">Coffee.init();</div><div class="line"></div><div class="line">// 冲茶叶</div><div class="line">var Tea = function()&#123;&#125;;</div><div class="line">Tea.prototype = new Beverage();</div><div class="line">Tea.prototype.brew = function() &#123;</div><div class="line">	console.log( &apos;用沸水冲泡茶叶&apos; );</div><div class="line">&#125;</div><div class="line">Tea.prototype.pourInCup = function() &#123;</div><div class="line">	console.log( &apos;把茶倒进杯子&apos; );</div><div class="line">&#125;</div><div class="line">Tea.prototype.addCondiments = function() &#123;</div><div class="line">	console.log( &apos;加柠檬&apos; );</div><div class="line">&#125;</div><div class="line">var Tea = new Tea();</div><div class="line">Tea.init();</div></pre></td></tr></table></figure>
<p>那么在上面的例子中，到底谁才是所谓的模板方法呢?答案是 <code>Beverage.prototype.init</code>。</p>
<p><code>Beverage.prototype.init</code> 被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在 <code>Beverage.prototype.init</code> 方法中，算法内的每一个步骤都清楚地展示在我们眼前。</p>
<h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><p>我们要引入一个新的设计原则——著名的“好莱坞原则”。</p>
<p>好莱坞原则简单来说就是：“别找我们，我们来找你”，是一种反向的控制结构，指的是父类调用一个类的操作。</p>
<p>在这一原则的指导下，模板方法模式就是允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件。</p>
<p>在好莱坞原则的指导之下，下面这段代码可以达到和使用继承一样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">var Beverage = function(param) &#123;</div><div class="line"></div><div class="line">	var boilWater = function() &#123;</div><div class="line">		console.log( &apos;0 把水煮沸&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var brew = param.brew || function() &#123;</div><div class="line">		throw new Error( &apos;必须传递 brew 方法&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var pourInCup = param.pourInCup || function() &#123;</div><div class="line">		throw new Error( &apos;必须传递 pourInCup 方法&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var addCondiments = param.addCondiments || function() &#123;</div><div class="line">		throw new Error( &apos;必须传递 addCondiments 方法&apos; );</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	var F = function()&#123;&#125;;</div><div class="line"></div><div class="line">	F.prototype.init = function()&#123;</div><div class="line">		boilWater();</div><div class="line">	    brew();</div><div class="line">		pourInCup();</div><div class="line">		addCondiments();</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	return F;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Coffee = Beverage(&#123;</div><div class="line">	brew: function() &#123;</div><div class="line">		console.log( &apos;1 用沸水冲泡咖啡&apos; );</div><div class="line">	&#125;,</div><div class="line">	pourInCup: function() &#123;</div><div class="line">		console.log( &apos;2 把咖啡倒进杯子&apos; );</div><div class="line">	&#125;,</div><div class="line">	addCondiments: function() &#123;</div><div class="line">		console.log( &apos;3 加糖和牛奶&apos; );</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var coffee = new Coffee();</div><div class="line">coffee.init();</div><div class="line"></div><div class="line">var Tea = Beverage(&#123;</div><div class="line">	brew: function() &#123;</div><div class="line">		console.log( &apos;1 用沸水浸泡茶叶&apos; );</div><div class="line">	&#125;,</div><div class="line">	pourInCup: function()&#123;</div><div class="line">		console.log( &apos;2 把茶倒进杯子&apos; );</div><div class="line">	&#125;,</div><div class="line">	addCondiments: function() &#123;</div><div class="line">		console.log( &apos;3 加柠檬&apos; );</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var tea = new Tea();</div><div class="line">tea.init();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板方法应用于下列情况：</p>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复，不同之处分离为新的操作，最后，用一个钓鱼这些新操作的模板方法来替换这些不同的代码</li>
<li>控制子类扩展，模板方法只在特定点调用“hook”操作，这样就允许在这些点进行扩展</li>
</ul>
<p>和策略模式不同，模板方法使用继承来改变算法的一部分，而策略模式使用委托来改变整个算法。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这不代表继承在 JavaScript 里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型 prototype 来变相地实现继承。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;模板方法模式是一种只需使用继承就可以实现的非常简单的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式由两部分结构组成：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分是抽象父类，&lt;/li&gt;
&lt;li&gt;第二部分是具体的实现子类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之发布/订阅模式(Publish/Subscribe)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-publish-subscribe.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-publish-subscribe.html</id>
    <published>2017-04-05T04:36:29.000Z</published>
    <updated>2017-04-05T08:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>发布/订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布/订阅模式</p>
<h2 id="遍地的发布订阅现象"><a href="#遍地的发布订阅现象" class="headerlink" title="遍地的发布订阅现象"></a>遍地的发布订阅现象</h2><p>如今的信息化时代，发布/订阅模式的应用可以说非常广泛，比如微信公众号就是典型的发布/订阅模式，公众号发布一条信息，所有的订阅者都会收到。</p>
<p>有人可能也会想到经常收到的各种广告短信信息（有的可能是被动订阅），其实发送短信通知或广告也是一个典型的发布/订阅模式。</p>
<p>发布/订阅模式可以广泛用于异步编程中，代替传递回掉函数的方案，比如，我们可以订阅 ajax 请求的 error、succ 等事件。</p>
<p>另外发表订阅让两个对象松耦合在一起，不必了解彼此细节，当有新的订阅者出现时，发布者的代码不需要任何修改。同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>
<p>使用发布订阅模式的好处：</p>
<ul>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li>
<li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li>
<li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="自定义发表订阅"><a href="#自定义发表订阅" class="headerlink" title="自定义发表订阅"></a>自定义发表订阅</h3><p>我们来尝试一个自定义的发布订阅模式，那么如何实现发布订阅呢</p>
<ul>
<li>指定一个发布者</li>
<li>给发布者添加一个缓冲列表，用于存放回调函数以用于通知订阅者</li>
<li>发布消息时，发布者遍历缓存列表，依次触发每个订阅者的回调函数</li>
</ul>
<p><strong>一个简单的天气状态订阅</strong></p>
<pre><code>var Weather = {
    list: [], // 缓存列表
    listen: function(fn) { // 增加订阅者
        this.list.push(fn)
    },
    publish: function() { // 发布消息
        for(var i=0,fn; fn=this.list[i++];) {
            fn.apply(this,arguments);
        }
    }
};

// 订阅消息
Weather.listen(function(weather, wind){
    console.log(&apos;天气：&apos; + weather, &apos;风力：&apos;+ wind);
})

// 发布消息
Weather.publish(&quot;晴天&quot;,&quot;微风&quot;); // 天气：晴天 风力：微风
Weather.publish(&quot;雷阵雨&quot;,&quot;5级风&quot;); // 天气：雷阵雨 风力：5级风
</code></pre><p>以上，已经实现了一个最简单的发布—订阅模式，还可以为订阅者增加自选功能，订阅自己想要的消息，也可以增加取消订阅的事件。</p>
<pre><code>var PubSub = {
    list: [],
    listen: function(key, fn){
        if(!this.list[key]) {
            this.list[key]=[];
        }
        this.list[key].push(fn);
    },
    publish: function(){
        var key = Array.prototype.shift.call(arguments),
            fns = this.list[key];
        if(!fns || fns.length === 0) {
            return false;
        }
        for(var i = 0, fn; fn = fns[i++];){
            fn.apply(this, arguments);
        }
    }
}

//
var installEvent = function(obj) {
    for (var i in PubSub) {
        obj[i] = PubSub[i];
    }
};

var day = {}
installEvent(day);

day.listen(&apos;天气&apos;, function(wind) {
    console.log(&apos;风力：&apos;+ wind);
});

day.publish(&apos;天气&apos;, &quot;8级风&quot;);
</code></pre><h3 id="实战之网站登录"><a href="#实战之网站登录" class="headerlink" title="实战之网站登录"></a>实战之网站登录</h3><p>网站登录是最常见的形式，通常在登录以后我们会ajax异步请求获取用户信息，比如显示用户名字、头像等信息在header模块，而这两个字段都是来自用户登录后返回的信息。至于 ajax 请求什么时候能成功返回用户信息，这点我们没有办法确定，虽然现在看起来和发布订阅模式没关系，因为异步的问题通常也可以回调函数来解决。</p>
<p>我们不知道除了 header 头部、nav 导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式:</p>
<pre><code>login.succ(function(data){
    header.setAvatar( data.avatar);  // 设置 header 模块的头像
    nav.setAvatar( data.avatar ); // 设置导航模块的头像
    message.refresh(); // 刷新消息列表
    cart.refresh(); // 刷新购物车列表
});
</code></pre><p>现在登录模块是我们负责编写的，但我们还必须了解 header 模块里设置头像的方法叫 setAvatar、购物车模块里刷新的方法叫 refresh，这种耦合性会使程序变得僵硬，header 模块不能随意再改变 setAvatar 的方法名，它自身的名字也不能被改为 header1、header2。 这是针对具 体实现编程的典型例子，针对具体实现编程是不被赞同的。</p>
<p>某一个，项目新增加收获地址管理模块：</p>
<pre><code>login.succ(function(data){
    header.setAvatar( data.avatar);
    nav.setAvatar( data.avatar );
    message.refresh();
    address.refresh(); // 新增加收获地址
});
</code></pre><p>现在我们用发布订阅重写，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。 当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码如下:</p>
<pre><code>$.ajax( &apos;http://xxx.com?login&apos;, function(data){ // 登录成功
    login.trigger( &apos;loginSucc&apos;, data); // 发布登录成功的消息
});
</code></pre><p>各模块监听登录成功的消息:</p>
<pre><code>var header = (function() { // header 模块
    login.listen( &apos;loginSucc&apos;, function(data) {
        header.setAvatar( data.avatar );
    });
    return {
        setAvatar: function(data) {
            console.log( &apos;设置 header 模块的头像&apos;);
        }
    }
})();

var nav = (function() {  // nav 模块
    login.listen(&apos;loginSucc&apos;, function(data) {
        nav.setAvatar( data.avatar );
    });
    return {
        setAvatar: function(avatar) {
            console.log( &apos;设置 nav 模块的头像&apos;);
        }
    }
})();
</code></pre><p>如果有一天在登录完成之 后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用再关心这些行为了</p>
<pre><code>var address = (function(){ // 收获地址模块
    login.listen(&apos;loginSucc&apos;, function(obj){
        address.refresh(obj);
    });
    return {
        refresh: function( avatar ){
            console.log( &apos;刷新收货地址列表&apos; );
        }
    }
})();
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发布订阅的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p>
<p>总的来说，发布订阅模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>
<p>另外， 发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发布/订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布/订阅模式&lt;/p&gt;
&lt;h2 id=&quot;遍地的发布订阅现象&quot;&gt;&lt;a href=&quot;#遍地的发布订阅现象&quot; class=&quot;headerlink&quot; title=&quot;遍地的发布订阅现象&quot;&gt;&lt;/a&gt;遍地的发布订阅现象&lt;/h2&gt;&lt;p&gt;如今的信息化时代，发布/订阅模式的应用可以说非常广泛，比如微信公众号就是典型的发布/订阅模式，公众号发布一条信息，所有的订阅者都会收到。&lt;/p&gt;
&lt;p&gt;有人可能也会想到经常收到的各种广告短信信息（有的可能是被动订阅），其实发送短信通知或广告也是一个典型的发布/订阅模式。&lt;/p&gt;
&lt;p&gt;发布/订阅模式可以广泛用于异步编程中，代替传递回掉函数的方案，比如，我们可以订阅 ajax 请求的 error、succ 等事件。&lt;/p&gt;
&lt;p&gt;另外发表订阅让两个对象松耦合在一起，不必了解彼此细节，当有新的订阅者出现时，发布者的代码不需要任何修改。同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式(Strategy)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-strategy.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-strategy.html</id>
    <published>2017-04-01T04:53:39.000Z</published>
    <updated>2017-04-20T08:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在程序设计中，我们也常常遇到这样的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。<br>这些算法灵活多样，而且可以随意互相替换。这种解决方案就是将要介绍的策略模式。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<p>从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p>在一个 Web 项目中，注册、登录、修改用户信息等功能的实现都离不开提交表单。</p>
<p>在将用户输入的数据交给后台之前，常常要做一些客户端力所能及的校验工作，比如注册的时候需要校验是否填写了用户名，密码的长度是否符合规定等等。这样可以避免因为提交不合法数据而带来的不必要网络开销。</p>
<p>假设我们正在编写一个注册的页面，在点击注册按钮之前，有如下几条校验逻辑。</p>
<ul>
<li>用户名不能为空。</li>
<li>密码长度不能少于 6 位</li>
<li>手机号码必须符合格式。</li>
</ul>
<p>在理解策略模式之前，通常我们遇到类似多条件的业务，按照swith语句来判断，但是这就带来几个问题，首先如果增加需求的话，我们还要再次修改这段代码以增加逻辑，而且在进行单元测试的时候也会越来越复杂，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var validator = &#123;</div><div class="line">    validate: function (value, type) &#123;</div><div class="line">        switch (type) &#123;</div><div class="line">            case &apos;isNonEmpty &apos;:</div><div class="line">                    return true; // NonEmpty 验证结果</div><div class="line">            case &apos;minLength &apos;:</div><div class="line">                    return true; // minLength 验证结果</div><div class="line">                    break;</div><div class="line">            case &apos;isMobile &apos;:</div><div class="line">                    return true; // isMobile 验证结果</div><div class="line">            default:</div><div class="line">                    return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// 测试</div><div class="line">alert(validator.validate(&quot;123&quot;, &quot;isNonEmpty&quot;));</div></pre></td></tr></table></figure>
<h3 id="用策略模式重构表单校验"><a href="#用策略模式重构表单校验" class="headerlink" title="用策略模式重构表单校验"></a>用策略模式重构表单校验</h3><p>用策略模式来重构表单校验的代码，我们可以将相同的工作代码单独封装成不同的类，然后通过统一的策略处理类来处理，OK，我们先来定义策略处理类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">var validator = &#123;</div><div class="line"></div><div class="line">    // 所有可以的验证规则处理类存放的地方，后面会单独定义</div><div class="line">    types: &#123;&#125;,</div><div class="line"></div><div class="line">    // 验证类型所对应的错误消息</div><div class="line">    messages: [],</div><div class="line"></div><div class="line">    // 当然需要使用的验证类型</div><div class="line">    config: &#123;&#125;,</div><div class="line"></div><div class="line">    // 暴露的公开验证方法</div><div class="line">    // 传入的参数是 key =&gt; value对</div><div class="line">    validate: function (data) &#123;</div><div class="line"></div><div class="line">        var i, msg, type, checker, result_ok;</div><div class="line"></div><div class="line">        // 清空所有的错误信息</div><div class="line">        this.messages = [];</div><div class="line"></div><div class="line">        for (i in data) &#123;</div><div class="line">            if (data.hasOwnProperty(i)) &#123;</div><div class="line"></div><div class="line">                type = this.config[i];  // 根据key查询是否有存在的验证规则</div><div class="line">                checker = this.types[type]; // 获取验证规则的验证类</div><div class="line"></div><div class="line">                if (!type) &#123;</div><div class="line">                    continue; // 如果验证规则不存在，则不处理</div><div class="line">                &#125;</div><div class="line">                if (!checker) &#123; // 如果验证规则类不存在，抛出异常</div><div class="line">                    throw &#123;</div><div class="line">                        name: &quot;ValidationError&quot;,</div><div class="line">                        message: &quot;No handler to validate type &quot; + type</div><div class="line">                    &#125;;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                result_ok = checker.validate(data[i]); // 使用查到到的单个验证类进行验证</div><div class="line">                if (!result_ok) &#123;</div><div class="line">                    msg = &quot;Invalid value for *&quot; + i + &quot;*, &quot; + checker.instructions;</div><div class="line">                    this.messages.push(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return this.hasErrors();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    // helper</div><div class="line">    hasErrors: function () &#123;</div><div class="line">        return this.messages.length !== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后剩下的工作，就是定义types里存放的各种验证类了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 验证给定的值是否不为空</div><div class="line">validator.types.isNonEmpty = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return value !== &quot;&quot;;</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值不能为空&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否是数字</div><div class="line">validator.types.isNumber = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !isNaN(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能是合法的数字，例如：1, 3.14 or 2010&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 验证给定的值是否只是字母或数字</div><div class="line">validator.types.isAlphaNum = &#123;</div><div class="line">    validate: function (value) &#123;</div><div class="line">        return !/[^a-z0-9]/i.test(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &quot;传入的值只能保护字母和数字，不能包含特殊字符&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用的时候，我们首先要定义需要验证的数据集合，然后还需要定义每种数据需要验证的规则类型，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var data = &#123;</div><div class="line">    first_name: &quot;Tom&quot;,</div><div class="line">    last_name: &quot;Xu&quot;,</div><div class="line">    age: &quot;unknown&quot;,</div><div class="line">    username: &quot;TomXu&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">validator.config = &#123;</div><div class="line">    first_name: &apos;isNonEmpty&apos;,</div><div class="line">    age: &apos;isNumber&apos;,</div><div class="line">    username: &apos;isAlphaNum&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后，获取验证结果的代码就简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">validator.validate(data);</div><div class="line"></div><div class="line">if (validator.hasErrors()) &#123;</div><div class="line">    console.log(validator.messages.join(&quot;\n&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><p>策略模式是一种常用且有效的设计模式，我们可以总结出策略模式的一些优点：</p>
<ol>
<li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li>
<li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。</li>
<li>策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li>
<li>在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。</li>
</ol>
<p>当然，策略模式也有一些缺点，但这些缺点并不严重。</p>
<p>首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的 逻辑堆砌在 Context 中要好。</p>
<p>其次，要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点， 这样才能选择一个合适的 strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选 择飞机、火车、自行车等方案的细节。此时 strategy 要向客户暴露它的所有实现，这是违反最少 知识原则的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>策略模式定义了一系列算法，从概念上来说，所有的这些算法都是做相同的事情，只是实现不同，他可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合。</p>
<p>从另外一个层面上来说，单独定义算法类，也方便了单元测试，因为可以通过自己的算法进行单独测试。</p>
<p>实践中，不仅可以封装算法，也可以用来封装几乎任何类型的规则，是要在分析过程中需要在不同时间应用不同的业务规则，就可以考虑是要策略模式来处理各种变化。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序设计中，我们也常常遇到这样的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。&lt;br&gt;这些算法灵活多样，而且可以随意互相替换。这种解决方案就是将要介绍的策略模式。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p&gt;
&lt;p&gt;从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Strategy" scheme="http://www.imeetyou.net/tags/Strategy/"/>
    
  </entry>
  
  <entry>
    <title>safari浏览器fixed后，被软键盘遮盖的问题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/html-safari-fixed.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/html-safari-fixed.html</id>
    <published>2017-03-31T10:12:19.000Z</published>
    <updated>2017-03-31T09:57:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>safari浏览器fixed后，被软键盘遮盖的问题，暂未有更好解决方案，度娘了好多方案，发现他们并未解决此问题，下文会叙述。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>测试环境：ios 10.2/10.3</strong></p>
<p>简单来说就是在html5页面中底部有个fixed的区域，如图</p>
<a id="more"></a>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix1.png" alt="safari-fix"></p>
<p>在点击输入框的时候，软键盘弹出，遮盖了fixed区域，如图</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix2.png" alt="safari-fix"></p>
<p>但是当你点击“完成”让软键盘收起，再次点击输入框的时候，what？一切正常了～！如图（就是要这样子的嘛，之后收起弹出软键盘都正常了，不会遮盖fixed底部区域了！）</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix3.png" alt="safari-fix"></p>
<p>但是，但是，还没完，在输入框里随便输入点内容，点击“提交”，关闭软键盘，之后再次点击输入框，问题依旧～，软键盘再次遮挡fixed区域。</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/safari-fix4.png" alt="safari-fix"></p>
<p>如上循环，问题无法解决。</p>
<h2 id="测试代码如下"><a href="#测试代码如下" class="headerlink" title="测试代码如下"></a>测试代码如下</h2><p>代码很简单，但还是贴一下，方便测试，只需要复制粘贴到本机即可测试上述现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</div><div class="line">    &lt;title&gt;fixed测试页面&lt;/title&gt;</div><div class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1&quot;&gt;</div><div class="line">    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</div><div class="line">    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</div><div class="line"></div><div class="line">	&lt;style&gt;</div><div class="line">		.head &#123;</div><div class="line">			top: 0;</div><div class="line">			height: 50px;</div><div class="line">			line-height: 50px;</div><div class="line">			text-align: center;</div><div class="line">			position: fixed;</div><div class="line">			left: 0;</div><div class="line">			width: 100%;</div><div class="line">			z-index: 10;</div><div class="line">			background-color: #99CC00;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.foot &#123;</div><div class="line">			bottom: 0;</div><div class="line">			padding: 10px;</div><div class="line">			position: fixed;</div><div class="line">			left: 0;</div><div class="line">			width: 100%;</div><div class="line">			background-color: #99CC00;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.main &#123;</div><div class="line">			width: 100%;</div><div class="line">			height: 100%;</div><div class="line">			overflow-y: scroll;</div><div class="line">			-webkit-overflow-scrolling: touch;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.list &#123;</div><div class="line">			padding: 0;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.list li &#123;</div><div class="line">			list-style: none;</div><div class="line">			background: #ccc;</div><div class="line">			height: 140px;</div><div class="line">			margin-bottom: 10px;</div><div class="line">			width: 100%;</div><div class="line">			padding:10px;</div><div class="line">		&#125;</div><div class="line">		.list a &#123;</div><div class="line">			border:2px solid #999;</div><div class="line">			display: block;</div><div class="line">			width:88%;</div><div class="line">			position: absolute;</div><div class="line">			height:140px;</div><div class="line">		&#125;</div><div class="line">		.input &#123;</div><div class="line">			width: 76%;</div><div class="line">			line-height: 30px;</div><div class="line">			border: none;</div><div class="line">			float: left;</div><div class="line">			border-radius:5px;</div><div class="line">		&#125;</div><div class="line">		.btn &#123;</div><div class="line">			float:right;</div><div class="line">			margin-right:15px;</div><div class="line">			border-radius:5px;</div><div class="line">			height:34px;</div><div class="line">			line-height: 32px;</div><div class="line">			padding: 0 10px;</div><div class="line">			border: none;</div><div class="line">			background: #000;</div><div class="line">			color: #fff;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">	&lt;header class=&quot;head&quot;&gt;顶部固定区域&lt;/header&gt;</div><div class="line"></div><div class="line">	&lt;main class=&quot;main&quot;&gt;</div><div class="line">		&lt;div class=&quot;content&quot;&gt;</div><div class="line">			&lt;ul class=&quot;list&quot;&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class="line">			&lt;/ul&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/main&gt;</div><div class="line"></div><div class="line">	&lt;footer class=&quot;foot&quot; id=&quot;footer-fixed&quot;&gt;</div><div class="line">		&lt;button type=&quot;button&quot; id=&quot;btn-submit&quot; class=&quot;btn&quot; name=&quot;button&quot;&gt;提交&lt;/button&gt;</div><div class="line">		&lt;input type=&quot;text&quot; id=&quot;input-txt&quot; class=&quot;input&quot; name=&quot;&quot; value=&quot;&quot; placeholder=&quot;我来说两句...(200字内)&quot;&gt;</div><div class="line">	&lt;/footer&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="尝试过的解决方案"><a href="#尝试过的解决方案" class="headerlink" title="尝试过的解决方案"></a>尝试过的解决方案</h2><p>搜索后有很多解决方法，但发现他们都没解决上述问题，</p>
<p><strong>暂时的想法，绕过fixed点击输入框后，隐藏此区域，在顶部出现更大的输入区域以让用户输入内容。</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000005370182#articleHeader2" target="_blank" rel="external">IOS中弹出键盘后出现fixed失效现象的解决方案</a></li>
<li><a href="http://blog.csdn.net/kongjiea/article/details/46545351" target="_blank" rel="external">移动端解决fixed和input获取焦点软键盘弹出影响定位的问题</a></li>
<li><a href="http://www.cnblogs.com/yexiaochai/p/3561939.html" target="_blank" rel="external">虚拟键盘与fixed带给移动端的痛</a></li>
<li><a href="http://www.cnblogs.com/PeunZhang/archive/2013/06/14/3117589.html" target="_blank" rel="external">使用iScroll.js解决ios4下不支持position:fixed的问题</a></li>
</ul>
<p>好，至此，问题描述完毕，期待有牛人更好解决方案</p>
<hr>
<blockquote>
<p>segmentfault 专栏提出了问题</p>
<p><a href="https://segmentfault.com/a/1190000008906437?_ea=1772278" target="_blank" rel="external">https://segmentfault.com/a/1190000008906437?_ea=1772278</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;safari浏览器fixed后，被软键盘遮盖的问题，暂未有更好解决方案，度娘了好多方案，发现他们并未解决此问题，下文会叙述。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;测试环境：ios 10.2/10.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是在html5页面中底部有个fixed的区域，如图&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="css" scheme="http://www.imeetyou.net/tags/css/"/>
    
      <category term="html" scheme="http://www.imeetyou.net/tags/html/"/>
    
      <category term="safari" scheme="http://www.imeetyou.net/tags/safari/"/>
    
      <category term="fixed" scheme="http://www.imeetyou.net/tags/fixed/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式(Iterator)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-iterator.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-iterator.html</id>
    <published>2017-03-31T09:56:19.000Z</published>
    <updated>2017-04-20T08:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。</p>
<p>比如：JavaScript 的 <code>Array.prototype.forEach</code></p>
<p>jQuery里一个非常有名的迭代器就是 <code>$.each</code> 方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.each( [1, 2, 3], function( i, n )&#123;</div><div class="line">	console.log( &apos;当前下标为： &apos;+ i,&apos;当前值为:&apos; + n );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 下标： 0 当前值:1</div><div class="line">// 下标： 1 当前值:2</div><div class="line">// 下标： 2 当前值:3</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式(Iterator)：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。</p>
<p>迭代器的几个特点是：</p>
<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h3><p>参照jQuery的<code>$.each</code> 方法, 我们来自己实现一个 each 函数，each 函数接受 2 个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var each = function( ary, callback ) &#123;</div><div class="line">	for ( var i = 0, l = ary.length; i &lt; l; i++ )&#123;</div><div class="line">		callback.call( ary[i], i, ary[ i ] );</div><div class="line">		// 把下标和元素当作参数传给callback 函数</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">each( [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ], function( i, n )&#123;</div><div class="line">	console.log( &apos;自定义下标为： &apos;+ i,&apos;自定义值为:&apos; + n );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 自定义下标为： 0 自定义值为:a</div><div class="line">// 自定义下标为： 1 自定义值为:b</div><div class="line">// 自定义下标为： 2 自定义值为:c</div></pre></td></tr></table></figure>
<h3 id="迭代器模式的应用举例"><a href="#迭代器模式的应用举例" class="headerlink" title="迭代器模式的应用举例"></a>迭代器模式的应用举例</h3><p>以常用的上传文件功能为例，在不同的浏览器环境下，选择的上传方式是不一样的。因为使用浏览器的上传控件进行上传速度快，可以暂停和续传，所以我们首先会优先使用控件上传。如果浏览器没有安装上传控件， 则使用 Flash 上传， 如果连 Flash 也没安装，那就只好使用浏览器原生的表单上传了，代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var getUploadObj = function() &#123;</div><div class="line">	try &#123;</div><div class="line">		return new ActiveXObject(&quot;TXFTNActiveX.FTNUpload&quot;); // IE 上传控件</div><div class="line">	&#125; catch (e) &#123;</div><div class="line">		if (supportFlash()) &#123; // supportFlash 函数未提供</div><div class="line">			var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class="line">			return $(str).appendTo($(&apos;body&apos;));</div><div class="line">		&#125; else &#123;</div><div class="line">			var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot;/&gt;&apos;; // 表单上传</div><div class="line">			return $(str).appendTo($(&apos;body&apos;));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看看上面的代码，为了得到一个 upload 对象，这个 getUploadObj 函数里面充斥了 try，catch 以及 if 条件分支。缺点是显而易见的。</p>
<p>现在来梳理一下问题，目前一共有 3 种可能的上传方式，我们不知道目前浏览器支持那种上传方式，那就需要逐个尝试，直到成功为止，分别定义以下几个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// IE 上传控件</div><div class="line">var getActiveUploadObj = function() &#123;</div><div class="line">	try &#123;</div><div class="line">		return new ActiveXObject(&quot;TXFTNActiveX.FTNUpload&quot;);</div><div class="line">	&#125; catch (e) &#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Flash 上传</div><div class="line">var getFlashUploadObj = function() &#123;</div><div class="line">	if (supportFlash()) &#123; // supportFlash 函数未提供</div><div class="line">		var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class="line">		return $(str).appendTo($(&apos;body&apos;));</div><div class="line">	&#125;;</div><div class="line">	return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 表单上传</div><div class="line">var getFormUpladObj = function() &#123;</div><div class="line">	var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; class=&quot;ui-file&quot;/&gt;&apos;;</div><div class="line">	return $(str).appendTo($(&apos;body&apos;));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在以上三个函数中，如果该函数里面的 upload 对象是可用的，则让函数返回该对象，反之返回 false，提示迭代器继续往后面进行迭代。</p>
<p>那么迭代器只需进行下面这几步工作：</p>
<ul>
<li>提供一个可以被迭代的方法，使得 getActiveUploadObj，getFlashUploadObj 以及 getFlashUploadObj 依照优先级被循环迭代。</li>
<li>如果正在被迭代的函数返回一个对象，则表示找到了正确的 upload 对象，反之如果该函数返回 false，则让迭代器继续工作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var iteratorUpload = function() &#123;</div><div class="line">	for (var i = 0, fn; fn = arguments[i++];) &#123;</div><div class="line">		var upload = fn();</div><div class="line">		if (upload !== false) &#123;</div><div class="line">			return upload;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var uploadObj = iteratorUpload( getActiveUploadObj, getFlashUploadObj, getFormUpladObj )</div></pre></td></tr></table></figure>
<p>重构代码之后，可以看到，上传对象的各个函数彼此分离互补干扰，很方便维护和扩展，如果后期增加了 Webkit 控件上传和 HTML5 上传，我们就增加对应的函数功能并在迭代器里添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var getWebkitUploadObj = function()&#123;</div><div class="line"> // 具体代码略</div><div class="line">&#125;</div><div class="line"></div><div class="line">var getHtml5UploadObj = function()&#123;</div><div class="line"> // 具体代码略</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 依照优先级把它们添加进迭代器</div><div class="line">var uploadObj = iteratorUploadObj( getActiveUploadObj, getWebkitUploadObj,</div><div class="line">getFlashUploadObj, getHtml5UploadObj, getFormUpladObj );</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迭代器的使用场景是：对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又想让客户代码透明地访问其中的元素，这种情况下我们可以使用迭代器模式。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p>《JavaScript设计模式与开发实践》</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。&lt;/p&gt;
&lt;p&gt;比如：JavaScript 的 &lt;code&gt;Array.prototype.forEach&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;jQuery里一个非常有名的迭代器就是 &lt;code&gt;$.each&lt;/code&gt; 方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$.each( [1, 2, 3], function( i, n )&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log( &amp;apos;当前下标为： &amp;apos;+ i,&amp;apos;当前值为:&amp;apos; + n );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 下标： 0 当前值:1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 下标： 1 当前值:2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 下标： 2 当前值:3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Iterator" scheme="http://www.imeetyou.net/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式（Proxy）</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-proxy.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-proxy.html</id>
    <published>2017-03-29T10:16:09.000Z</published>
    <updated>2017-04-20T08:29:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>代理，顾名思义就是帮助别人做事，GoF对代理模式的定义如下：</p>
<blockquote>
<p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们来举一个简单的例子，假如小明要送酸奶小妹玫瑰花，却不知道她的联系方式或者不好意思，想委托大叔去送这些玫瑰，那大叔就是个代理，那我们如何来做呢？</p>
<pre><code>// 先声明美女对象
var girl = function (name) {
    this.name = name;
};

// 这是小明
var xiaoMing = function (girl) {
    this.girl = girl;
    this.sendGift = function (gift) {
        alert(&quot;Hi &quot; + girl.name + &quot;, 小明送你一个礼物：&quot; + gift);
    }
};

// 大叔是代理
var proxyTom = function (girl) {
    this.girl = girl;
    this.sendGift = function (gift) {
        (new xiaoMing(girl)).sendGift(gift); // 替dudu送花咯
    }
};
</code></pre><p>调用方式：</p>
<pre><code>var proxy = new proxyTom(new girl(&quot;酸奶小妹&quot;));
proxy.sendGift(&quot;999朵玫瑰&quot;);
</code></pre><h3 id="虚拟代理实现图片预加载"><a href="#虚拟代理实现图片预加载" class="headerlink" title="虚拟代理实现图片预加载"></a>虚拟代理实现图片预加载</h3><p>在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性， 由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种 场景就很适合使用虚拟代理。</p>
<p>下面我们来实现这个虚拟代理，首先创建一个普通的本体对象，这个对象负责往页面中创建 一个 img 标签，并且提供一个对外的 setSrc 接口，外界调用这个接口，便可以给该 img 标签设置<br>src 属性:</p>
<pre><code>var myImage = (function(){
    var imgNode = document.createElement( &apos;img&apos; );
    document.body.appendChild( imgNode );
    return {
        setSrc: function( src ) {
            imgNode.src = src;
        }
    }
})();
</code></pre><p>我们把网速调至 5KB/s，然后通过 MyImage.setSrc 给该 img 节点设置 src，可以看到，在图片</p>
<p>被加载好之前，页面中有一段长长的空白时间。</p>
<p>现在开始引入代理对象 proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中<br>将出现一张占位的菊花图 loading.gif, 来提示用户图片正在加载。代码如下:</p>
<pre><code>var myImage = (function(){
    var imgNode = document.createElement( &apos;img&apos; );
    document.body.appendChild( imgNode );
    return {
        setSrc: function( src ) {
            imgNode.src = src;
        }
    }
})();

var proxyImage = (function() {
    var img = new Image;
    img.onload = function() {
        myImage.setSrc( this.src );
    }
    return {
        setSrc: function( src ) {
            myImage.setSrc( &apos;./pic.jpg&apos; );
            img.src = src;
        }
    }
})();

proxyImage.setSrc( &apos;./loading.gif&apos; );
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。 当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。</p>
<hr>
<blockquote>
<p>参考引用资料</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔的博客——深入理解JavaScript系列</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。&lt;/p&gt;
&lt;p&gt;代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;代理，顾名思义就是帮助别人做事，GoF对代理模式的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式(Singleton)</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-dp-singleton.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-dp-singleton.html</id>
    <published>2017-03-29T03:36:29.000Z</published>
    <updated>2017-04-20T08:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 开发中，单例模式的用途非常广泛。比如，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式的定义是：<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong></p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>经典Singleton模式的实现方式是，如果实例不存在，通过一个方法创建一个实例。如果已经存在，则返回实例的引用。</p>
<p>Singleton与静态类（对象）不同的是，它可以被延迟生成，只有在需要的时候才会生成实例。</p>
<p>在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var singleton = (function() &#123;</div><div class="line">	var instance;</div><div class="line"></div><div class="line">	function init() &#123;</div><div class="line">		// define private methods and properties</div><div class="line">		// do something</div><div class="line">		return &#123;</div><div class="line">			// define public methods and properties</div><div class="line">			publicMethod: function() &#123;</div><div class="line">				console.log(&apos;hello singleton!&apos;)</div><div class="line">			&#125;,</div><div class="line">			publicProperty: &apos;test&apos;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	return &#123;</div><div class="line">		getInstance: function() &#123;</div><div class="line">			if (!instance) &#123;</div><div class="line">				instance = init()</div><div class="line">			&#125;</div><div class="line">			return instance</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">singleton.getInstance().publicMethod(); // hello singleton!</div><div class="line">console.log(singleton.getInstance().publicProperty); // test</div></pre></td></tr></table></figure>
<h2 id="其它实现方法"><a href="#其它实现方法" class="headerlink" title="其它实现方法"></a>其它实现方法</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 判断是否存在实例</div><div class="line">    if (typeof Universe.instance === &apos;object&apos;) &#123;</div><div class="line">        return Universe.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 缓存</div><div class="line">    Universe.instance = this;</div><div class="line"></div><div class="line">    // 隐式返回this</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni === uni2); // true</div><div class="line">`</div></pre></td></tr></table></figure>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存的实例</div><div class="line">    var instance = this;</div><div class="line"></div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    // 重写构造函数</div><div class="line">    Universe = function () &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">uni.bang = &quot;123&quot;;</div><div class="line">console.log(uni === uni2); // true</div><div class="line">console.log(uni2.bang); // 123</div><div class="line">`</div></pre></td></tr></table></figure>
<h3 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line"></div><div class="line">    // 缓存实例</div><div class="line">    var instance;</div><div class="line"></div><div class="line">    // 重新构造函数</div><div class="line">    Universe = function Universe() &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // 后期处理原型属性</div><div class="line">    Universe.prototype = this;</div><div class="line"></div><div class="line">    // 实例</div><div class="line">    instance = new Universe();</div><div class="line"></div><div class="line">    // 重设构造函数指针</div><div class="line">    instance.constructor = Universe;</div><div class="line"></div><div class="line">    // 其它功能</div><div class="line">    instance.start_time = 0;</div><div class="line">    instance.bang = &quot;Big&quot;;</div><div class="line"></div><div class="line">    return instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni === uni2); // true</div><div class="line"></div><div class="line">// 添加原型属性</div><div class="line">Universe.prototype.nothing = true;</div><div class="line"></div><div class="line">var uni = new Universe();</div><div class="line"></div><div class="line">Universe.prototype.everything = true;</div><div class="line"></div><div class="line">var uni2 = new Universe();</div><div class="line"></div><div class="line">console.log(uni.nothing); // true</div><div class="line">console.log(uni2.nothing); // true</div><div class="line">console.log(uni.everything); // true</div><div class="line">console.log(uni2.everything); // true</div><div class="line">console.log(uni.constructor === Universe); // true</div></pre></td></tr></table></figure>
<h3 id="方式4"><a href="#方式4" class="headerlink" title="方式4:"></a>方式4:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var Universe;</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line"></div><div class="line">    var instance;</div><div class="line"></div><div class="line">    Universe = function Universe() &#123;</div><div class="line"></div><div class="line">        if (instance) &#123;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        instance = this;</div><div class="line"></div><div class="line">        // 其它内容</div><div class="line">        this.start_time = 0;</div><div class="line">        this.bang = &quot;Big&quot;;</div><div class="line">    &#125;;</div><div class="line">&#125; ());</div><div class="line"></div><div class="line">//测试代码</div><div class="line">var a = new Universe();</div><div class="line">var b = new Universe();</div><div class="line">alert(a === b); // true</div><div class="line">a.bang = &quot;123&quot;;</div><div class="line">alert(b.bang); // 123</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考及引用资料：</p>
<p><a href="https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/singleton.html" target="_blank" rel="external">https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/singleton.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 开发中，单例模式的用途非常广泛。比如，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;单例模式的定义是：&lt;strong&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现方法&quot;&gt;&lt;a href=&quot;#实现方法&quot; class=&quot;headerlink&quot; title=&quot;实现方法&quot;&gt;&lt;/a&gt;实现方法&lt;/h2&gt;&lt;p&gt;经典Singleton模式的实现方式是，如果实例不存在，通过一个方法创建一个实例。如果已经存在，则返回实例的引用。&lt;/p&gt;
&lt;p&gt;Singleton与静态类（对象）不同的是，它可以被延迟生成，只有在需要的时候才会生成实例。&lt;/p&gt;
&lt;p&gt;在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="设计模式" scheme="http://www.imeetyou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="singleton" scheme="http://www.imeetyou.net/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>Kindle 书籍源下载推荐</title>
    <link href="http://www.imeetyou.net/posts/life/2017/kindle-book.html"/>
    <id>http://www.imeetyou.net/posts/life/2017/kindle-book.html</id>
    <published>2017-03-28T04:35:39.000Z</published>
    <updated>2017-03-28T05:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>近日重拾公司所发kindle，之前一度觉得手机阅读完全可以替代这个产品，但手机看pdf文件，还是不够舒适，虽然是无背光版的，但在上下班路上的几个小时，用kindle阅读一些书籍感觉还是挺不错的，愉快的加入kindle大家庭，多刷秘籍吧。</p>
<h2 id="新手入门介绍"><a href="#新手入门介绍" class="headerlink" title="新手入门介绍"></a>新手入门介绍</h2><p><a href="https://kindlefere.com/" target="_blank" rel="external">Kindle伴侣 为静心阅读而生</a></p>
<p>将近日下载 Kindle 书籍源地址等整理分享一下，也算服务大众吧。</p>
<a id="more"></a>
<h2 id="推送及下载网站"><a href="#推送及下载网站" class="headerlink" title="推送及下载网站"></a>推送及下载网站</h2><p>除了<a href="https://www.amazon.cn/Kindle%E5%85%8D%E8%B4%B9%E7%94%B5%E5%AD%90%E4%B9%A6/b/ref=sa_menu_kindle_l3_b116175071?ie=UTF8&amp;node=116175071" target="_blank" rel="external">亚马逊 Kindle 商店免费电子书</a>,还有很多下载地址， 个人觉得比较方便全面的整理了一下：</p>
<ol>
<li><a href="http://readfree.me/" target="_blank" rel="external">readfree</a> 每日可以下载或推送2个书籍</li>
<li><a href="https://book.90xz.com/" target="_blank" rel="external">90图书网</a> 每日推送一个</li>
<li><a href="http://www.kindlepush.com/main" target="_blank" rel="external">kindle推</a> 普通会员下载4个，推送2个，这个挺不错</li>
<li><a href="http://forfrigg.com/" target="_blank" rel="external">forfrigg</a> 搜索需要科学上网，你懂的</li>
<li><a href="http://mebook.cc/" target="_blank" rel="external">我的小书屋</a> 可直接下载，多格式，图书有简介。</li>
<li><a href="https://www.gitbook.com/explore" target="_blank" rel="external">GitBook</a> 怎能忘了程序员的出书平台呢</li>
</ol>
<h2 id="书籍转换及制作工具"><a href="#书籍转换及制作工具" class="headerlink" title="书籍转换及制作工具"></a>书籍转换及制作工具</h2><ul>
<li>阅读 azw3 用 <a href="http://mac.softpedia.com/get/Utilities/Clearview-Reader.shtml" target="_blank" rel="external">clearview</a></li>
<li>转换格式用 <a href="http://www.calibre-ebook.com/download_osx" target="_blank" rel="external">calibre</a>，很方便将通常pdf格式转换为 azw3 格式</li>
</ul>
<p>更多格式转换技巧查看：<a href="https://kindlefere.com/skills/convert" target="_blank" rel="external">格式转换 – Kindle伴侣</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日重拾公司所发kindle，之前一度觉得手机阅读完全可以替代这个产品，但手机看pdf文件，还是不够舒适，虽然是无背光版的，但在上下班路上的几个小时，用kindle阅读一些书籍感觉还是挺不错的，愉快的加入kindle大家庭，多刷秘籍吧。&lt;/p&gt;
&lt;h2 id=&quot;新手入门介绍&quot;&gt;&lt;a href=&quot;#新手入门介绍&quot; class=&quot;headerlink&quot; title=&quot;新手入门介绍&quot;&gt;&lt;/a&gt;新手入门介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://kindlefere.com/&quot;&gt;Kindle伴侣 为静心阅读而生&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将近日下载 Kindle 书籍源地址等整理分享一下，也算服务大众吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.imeetyou.net/categories/life/"/>
    
    
      <category term="kindle" scheme="http://www.imeetyou.net/tags/kindle/"/>
    
      <category term="life" scheme="http://www.imeetyou.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>typeof与instanceof的区别</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-typeof-instanceof.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-typeof-instanceof.html</id>
    <published>2017-03-26T09:24:36.000Z</published>
    <updated>2017-03-28T08:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>typeof和instanceof都可以用来判断变量，它们的用法有很大区别：</p>
<ul>
<li><strong>typeof：返回一个变量的基本类型，检测的是基本数据类型</strong></li>
<li><strong>instanceof：返回的是一个布尔值，检测的是引用类型</strong></li>
</ul>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(typeof 1); // number</div><div class="line">console.log(typeof &quot;abc&quot;); // string</div><div class="line">console.log(typeof true); // boolean</div><div class="line">console.log(typeof a); // undefined</div><div class="line">console.log(typeof new Object()); // object</div><div class="line">console.log(typeof null); // object</div><div class="line">console.log(typeof []); // object</div></pre></td></tr></table></figure>
<p>可以看到 <code>typeof</code> 无法判断数组、null，不管是数组还是对象，都会返回 object </p>
<p>更多方法具体可查看 <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html" target="_blank" rel="external">《Javascript基础之数组》</a>—数组检测方法</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof返回的是一个布尔值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&#125;;</div><div class="line">console.log(a instanceof Object);  // true</div><div class="line">var b = [];</div><div class="line">console.log(b instanceof Array);  // true</div></pre></td></tr></table></figure>
<p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,所以可以用来判断数组。</p>
<p>需要注意的是，<strong>instanceof只能用来判断对象和函数，不能用来判断字符串和数字等</strong>，如：</p>
<p>```<br>var b = ‘123’;<br>console.log(b instanceof String);  // false<br>console.log(typeof b);  // string</p>
<p>var c = new String(“123”);<br>console.log(c instanceof String);  // true<br>console.log(typeof c);  // object</p>
<p>更多格式转换技巧查看：<a href="https://kindlefere.com/skills/convert" target="_blank" rel="external">格式转换 – Kindle伴侣</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;typeof和instanceof都可以用来判断变量，它们的用法有很大区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;typeof：返回一个变量的基本类型，检测的是基本数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;instanceof：返回的是一个布尔值，检测的是引用类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h2&gt;&lt;p&gt;typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例：&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="typeof" scheme="http://www.imeetyou.net/tags/typeof/"/>
    
      <category term="instanceof" scheme="http://www.imeetyou.net/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>Javascript数组常见问题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-array-issue.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-array-issue.html</id>
    <published>2017-03-23T09:24:23.000Z</published>
    <updated>2017-03-23T08:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、删除数组里指定的某个元素"><a href="#1、删除数组里指定的某个元素" class="headerlink" title="1、删除数组里指定的某个元素"></a>1、删除数组里指定的某个元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var arr = [3,2,3,3,5,3],</div><div class="line">	val = 3;</div><div class="line"></div><div class="line">var removeElement = function(arr, elm) &#123;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		if (arr[i] == elm) &#123;</div><div class="line">			arr.splice(i, 1);</div><div class="line">			i--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(removeElement(arr, val)); // [2, 5]</div></pre></td></tr></table></figure>
<p><strong>注意：这里for循环里的length是动态的，随着splice删除数组元素而变小，这里不能用forEach，因为forEach方法它一开始执行就自动缓存数组的长度，删除数组元素会出现意外。</strong></p>
<a id="more"></a>
<h2 id="2、数组去重的方法"><a href="#2、数组去重的方法" class="headerlink" title="2、数组去重的方法"></a>2、数组去重的方法</h2><h3 id="第一种，双重遍历去重法"><a href="#第一种，双重遍历去重法" class="headerlink" title="第一种，双重遍历去重法"></a>第一种，双重遍历去重法</h3><ol>
<li>构建一个新的数组存放结果</li>
<li>for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比</li>
<li>若结果数组中没有该元素，则存到结果数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 去除数组里的重复元素</div><div class="line">function unique(arr) &#123;</div><div class="line">    var ret = [];</div><div class="line">    var len = arr.length;</div><div class="line">    var isRepeat;</div><div class="line">    for(var i=0; i&lt;len; i++) &#123;</div><div class="line">        isRepeat = false;</div><div class="line">        for(var j=i+1; j&lt;len; j++) &#123;</div><div class="line">            if(arr[i] === arr[j])&#123;</div><div class="line">                isRepeat = true;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(!isRepeat)&#123;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">var arr = [3, 3, 2, 3];</div><div class="line">console.log(unique(arr)); // [2, 3]</div></pre></td></tr></table></figure>
<h3 id="第二种，对象键值对法"><a href="#第二种，对象键值对法" class="headerlink" title="第二种，对象键值对法"></a>第二种，对象键值对法</h3><ol>
<li>创建一个新的数组存放结果</li>
<li>创建一个空对象</li>
<li>for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。</li>
</ol>
<p><strong>说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">	var res = [];</div><div class="line">	var json = &#123;&#125;;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		if (!json[arr[i]]) &#123;</div><div class="line">			res.push(arr[i]);</div><div class="line">			json[arr[i]] = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [3, 3, 2, &quot;3&quot;, &quot;a&quot;, &quot;a&quot;];</div><div class="line">console.log(unique(arr)); // [3, 2, &quot;a&quot;]</div></pre></td></tr></table></figure>
<h3 id="第三种，ES5方法"><a href="#第三种，ES5方法" class="headerlink" title="第三种，ES5方法"></a>第三种，ES5方法</h3><p>利用 ES5 里的方法, indexOf、filter</p>
<p>arr.indexOf(要查找的元素)，返回被找到的元素在数组中的索引位置，如果没有则返回-1。</p>
<p>arr.filter(元素的值，元素的索引，被遍历的数组)，返回一个通过测试的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">  var res = arr.filter(function(item, index, array) &#123;</div><div class="line">    return array.indexOf(item) === index;</div><div class="line">  &#125;);</div><div class="line">  return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 1, &apos;1&apos;, &apos;2&apos;, 1];</div><div class="line">var ans = unique(arr);</div><div class="line">console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</div></pre></td></tr></table></figure>
<h3 id="第四种，ES6方法"><a href="#第四种，ES6方法" class="headerlink" title="第四种，ES6方法"></a>第四种，ES6方法</h3><p>ES6 部署了 Set 以及 Array.from 方法，如果浏览器支持，完全可以这样：</p>
<p>ES2015还引入了一种叫作Set的数据类型，它不允许重复元素出现，如果你重复添加同一个元素的话，Set中只会存在一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">  return Array.from(new Set(arr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 2, &quot;a&quot;, &quot;1&quot;, 2 ,&quot;a&quot;];</div><div class="line">console.log(unique(arr)) // [1, 2, &quot;a&quot;, &quot;1&quot;]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>关于数组去重更多详细方法参看</p>
<p><a href="https://github.com/hanzichi/underscore-analysis/issues/9" target="_blank" rel="external">JavaScript 数组去重</a></p>
<p><a href="http://www.jstips.co/zh_cn/deduplicate-an-array/" target="_blank" rel="external">数组去重 – JS Tips – A JS tip per day!</a></p>
<p><a href="http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array" target="_blank" rel="external">Remove Duplicates from JavaScript Array</a></p>
<p><a href="https://github.com/lifesinger/blog/issues/113" target="_blank" rel="external">从 JavaScript 数组去重谈性能优化</a></p>
<p><a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank" rel="external">也谈 JavaScript 数组去重</a></p>
</blockquote>
<h2 id="3、取数组中最大值最小值"><a href="#3、取数组中最大值最小值" class="headerlink" title="3、取数组中最大值最小值"></a>3、取数组中最大值最小值</h2><h3 id="遍历比较方法"><a href="#遍历比较方法" class="headerlink" title="遍历比较方法"></a>遍历比较方法</h3><ol>
<li>设一个变量存放最大值，将数组中第一个值赋值给该变量</li>
<li>遍历数组与最大值变量比较，如果大于最大值，则将该值赋值最大值变量</li>
<li>遍历结束后，变量里储存的就是数组里的最大值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function arrayMax(arr) &#123;</div><div class="line">   var max = arr[0];</div><div class="line">   arr.forEach(function(v)&#123;</div><div class="line">   	  if(v &gt; max) &#123;</div><div class="line">	     max = v</div><div class="line">      &#125;</div><div class="line">   &#125;)</div><div class="line">   return max;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(arrayMax(arr)); // 45</div></pre></td></tr></table></figure>
<h3 id="利用-Math-max-与-Math-min-方法"><a href="#利用-Math-max-与-Math-min-方法" class="headerlink" title="利用 Math.max() 与 Math.min() 方法"></a>利用 Math.max() 与 Math.min() 方法</h3><p>将数组转换成参数传进Math.max()或Math.min()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function max(arr) &#123;</div><div class="line">  return Math.max.apply(&#123;&#125;,arr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(max(arr)); // 45</div></pre></td></tr></table></figure>
<h3 id="ES5方法"><a href="#ES5方法" class="headerlink" title="ES5方法"></a>ES5方法</h3><ol>
<li>利用数组实例的 reduce(function(prev,curv,index,arr))  方法</li>
<li>依次比较回调函数中参数 prev 与 curv 的大小，返回大的那个</li>
</ol>
<p><strong>reduce(function(上一次调用回调返回的值, 数组中正在处理的元素, 当前元素索引, 调用reduce的数组))</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function max(arr) &#123;</div><div class="line">  return arr.reduce(function(prev,curv)&#123;</div><div class="line">      return prev &gt; curv ? prev : curv</div><div class="line">  &#125;) </div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(max(arr)); // 45</div></pre></td></tr></table></figure>
<h2 id="4、多维数组扁平化"><a href="#4、多维数组扁平化" class="headerlink" title="4、多维数组扁平化"></a>4、多维数组扁平化</h2><p>将多维数组”拍平”</p>
<p>将下列数组转为单一数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div></pre></td></tr></table></figure>
<h3 id="1、双层遍历法"><a href="#1、双层遍历法" class="headerlink" title="1、双层遍历法"></a>1、双层遍历法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [];</div><div class="line">for (var i = 0; i &lt; myArray.length; ++i) &#123;</div><div class="line">  for (var j = 0; j &lt; myArray[i].length; ++j)</div><div class="line">    newArray.push(myArray[i][j]);</div><div class="line">&#125;</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="2、使用concat-和apply"><a href="#2、使用concat-和apply" class="headerlink" title="2、使用concat()和apply()"></a>2、使用concat()和apply()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [].concat.apply([], myArray);</div><div class="line"></div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="3、使用reduce"><a href="#3、使用reduce" class="headerlink" title="3、使用reduce()"></a>3、使用reduce()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = myArray.reduce(function(prev, curr) &#123;</div><div class="line">  return prev.concat(curr);</div><div class="line">&#125;);</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="4、使用-ES6-的展开运算符"><a href="#4、使用-ES6-的展开运算符" class="headerlink" title="4、使用 ES6 的展开运算符"></a>4、使用 ES6 的展开运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [].concat(...myArray);</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>引用参考列表</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN 的 JavaScript 标准库 Array 部分</a></p>
<p><a href="http://www.jstips.co/zh_CN/" target="_blank" rel="external">Js Tips</a></p>
<p><a href="http://www.ferecord.com/lujs-array.html#_13" target="_blank" rel="external">撸js基础之数组</a></p>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-issue.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-array-issue.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、删除数组里指定的某个元素&quot;&gt;&lt;a href=&quot;#1、删除数组里指定的某个元素&quot; class=&quot;headerlink&quot; title=&quot;1、删除数组里指定的某个元素&quot;&gt;&lt;/a&gt;1、删除数组里指定的某个元素&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = [3,2,3,3,5,3],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	val = 3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var removeElement = function(arr, elm) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (var i = 0; i &amp;lt; arr.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (arr[i] == elm) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			arr.splice(i, 1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			i--;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	return arr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(removeElement(arr, val)); // [2, 5]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：这里for循环里的length是动态的，随着splice删除数组元素而变小，这里不能用forEach，因为forEach方法它一开始执行就自动缓存数组的长度，删除数组元素会出现意外。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="array" scheme="http://www.imeetyou.net/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-class3.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-class3.html</id>
    <published>2017-03-23T01:22:23.000Z</published>
    <updated>2017-03-23T01:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。</p>
<p>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</p>
<h2 id="1、构造函数法"><a href="#1、构造函数法" class="headerlink" title="1、构造函数法"></a>1、构造函数法</h2><p>第一种是经典方法，它用构造函数模拟”类”，在其内部用this关键字指代实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Dog() &#123;</div><div class="line">　　this.name = &quot;旺财&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成实例的时候，使用new关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dog = new Dog();</div><div class="line">console.log(dog.name); // 旺财</div></pre></td></tr></table></figure>
<p>类的属性和方法，还可以定义在构造函数的prototype对象之上。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Dog.prototype.wow = function()&#123;</div><div class="line">　 console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于这种方法的详细介绍，请看《Javascript 面向对象编程》，这里就不多说了。</p>
<p>它的主要缺点是，比较复杂，用到了this和prototype，编写和阅读都很费力。</p>
<h2 id="2、Object-create-法"><a href="#2、Object-create-法" class="headerlink" title="2、Object.create()法"></a>2、Object.create()法</h2><p>在ECM5中，加入一个新的方法 <code>Object.create()</code>,用这个方法，”类”就是一个对象，不是函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">	this.name = &quot;旺财&quot;;</div><div class="line">    wow: function() &#123;</div><div class="line">		console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，直接用Object.create()生成实例，不需要用到new。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dog = Object.create(Dog);</div><div class="line">console.log(dog.name); // 旺财</div><div class="line">dog.wow(); // 汪～汪～汪！</div></pre></td></tr></table></figure>
<p>这种方法不能实现私有属性和私有方法，实例对象之间也不能共享数据。</p>
<h2 id="3、BlackScript-法"><a href="#3、BlackScript-法" class="headerlink" title="3、BlackScript 法"></a>3、BlackScript 法</h2><p>荷兰程序员Gabor de Mooij提出了一种比Object.create()更好的<a href="http://www.gabordemooij.com/index.php?p=/blackscript" target="_blank" rel="external">新方法</a>。</p>
<p>事实上就是用一个对象模拟类，在这个类里，定义一个构造函数 createNew() 用来生成实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      //some code</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在 createNew() 里面，定义一个实例对象，把这个实例对象作为返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.wow(); // 汪～汪～汪！</div></pre></td></tr></table></figure>
<p>这种方法简单易学，可以实现OOP的特性，继承、私有属性和方法、数据共享。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>比如让 Dog 继承 Animal,只要在 Dog的 createNew()方法中，调用后者的createNew()方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Animal = &#123;</div><div class="line">　　　　createNew: function()&#123;</div><div class="line">　　　　　　var animal = &#123;&#125;;</div><div class="line">　　　　　　animal.sleep = function()&#123; </div><div class="line">				console.log(&quot;睡懒觉&quot;);</div><div class="line">		  &#125;;</div><div class="line">　　　　　　return animal;</div><div class="line">　　　　&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后，在 Dog 的 createNew() 方法中，调用 Animal 的 createNew() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = Animal.createNew();</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样得到的 Dog 实例，就会同时继承 Dog 类和Animal类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.sleep() // 睡懒觉 </div><div class="line">dog1.wow() // 汪～汪～汪！</div></pre></td></tr></table></figure>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>在 createNew() 方法中，只要不是定义在 dog 对象上的方法和属性，都是私有的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">      var sound = &quot;汪汪汪&quot;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(sound);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上例的内部变量 sound，外部无法读取，只有通过 dog 的公有方法 wow() 来读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.name // 旺财</div><div class="line">dog1.sound // undefined </div><div class="line">dog1.wow() // 汪汪汪</div></pre></td></tr></table></figure>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>有时候，我们需要所有实例对象，能够读写同一项内部数据。</p>
<p>这个时候，只要把这个内部数据，封装在类对象的里面、createNew()方法的外面即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   sound: &quot;汪汪汪&quot;,</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.sound = function() &#123;</div><div class="line">         console.log(Dog.sound);</div><div class="line">      &#125;</div><div class="line">      dog.changSound = function(para)&#123;</div><div class="line">         Dog.sound = para</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>生成两个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">var dog2 = Dog.createNew();</div><div class="line">dog1.sound(); // 汪汪汪</div><div class="line">dog2.sound(); // 汪汪汪</div></pre></td></tr></table></figure>
<p>这时，如果有一个实例对象，修改了共享的数据，另一个实例对象也会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dog2.changSound(&quot;呱呱呱&quot;);</div><div class="line">dog1.sound(); // 呱呱呱</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文转载引用自 <a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="external">Javascript定义类（class）的三种方法</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。&lt;/p&gt;
&lt;p&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/p&gt;
&lt;h2 id=&quot;1、构造函数法&quot;&gt;&lt;a href=&quot;#1、构造函数法&quot; class=&quot;headerlink&quot; title=&quot;1、构造函数法&quot;&gt;&lt;/a&gt;1、构造函数法&lt;/h2&gt;&lt;p&gt;第一种是经典方法，它用构造函数模拟”类”，在其内部用this关键字指代实例对象。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Dog() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　this.name = &amp;quot;旺财&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成实例的时候，使用new关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var dog = new Dog();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(dog.name); // 旺财&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类的属性和方法，还可以定义在构造函数的prototype对象之上。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="class" scheme="http://www.imeetyou.net/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基础之数组</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-array-base.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-array-base.html</id>
    <published>2017-03-22T03:34:42.000Z</published>
    <updated>2017-03-22T08:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。</p>
<h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><ul>
<li>constructor 表示引用数组对象的构造函数</li>
<li>length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。</li>
<li>prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="一、创建方法"><a href="#一、创建方法" class="headerlink" title="一、创建方法"></a>一、创建方法</h3><h4 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">var arr = new Array(); // 创建一个空数组</div><div class="line">`</div></pre></td></tr></table></figure>
<h4 id="创建一个指定长度的数组"><a href="#创建一个指定长度的数组" class="headerlink" title="创建一个指定长度的数组"></a>创建一个指定长度的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array(size) // size 表示数组的长度</div></pre></td></tr></table></figure>
<h4 id="创建一个指定元素的数组"><a href="#创建一个指定元素的数组" class="headerlink" title="创建一个指定元素的数组"></a>创建一个指定元素的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、检测方法"><a href="#二、检测方法" class="headerlink" title="二、检测方法"></a>二、检测方法</h3><h4 id="1、利用-instanceof-操作符"><a href="#1、利用-instanceof-操作符" class="headerlink" title="1、利用 instanceof 操作符"></a>1、利用 instanceof 操作符</h4><p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(arr instanceof Array) // true</div></pre></td></tr></table></figure>
<h4 id="2、通过对象自身的-constructor-属性"><a href="#2、通过对象自身的-constructor-属性" class="headerlink" title="2、通过对象自身的 constructor 属性"></a>2、通过对象自身的 constructor 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(arr.constructor === Array) // true</div></pre></td></tr></table></figure>
<p><strong>跨frame实例化对象带来的问题</strong></p>
<p><code>constructor</code> 和 <code>instanceof</code> 貌似很好的两个检测数组的方法，但实际上还是有些漏洞的，当你在多个frame中回来跳的时候，这两种方法就惨了。</p>
<p>由于每一个frame都有自己的一套执行环境，跨frame实例化的对象彼此并不共享原型链，通过 <code>instanceof</code> 操作符和 <code>constructor</code> 属性检测的方法自然会失败。</p>
<p>那么第三种方法就比较好了，如下</p>
<h4 id="3、对象原生toString检测"><a href="#3、对象原生toString检测" class="headerlink" title="3、对象原生toString检测"></a>3、对象原生toString检测</h4><p><code>Object.prototype.toString</code> 的行为：首先，取得对象的一个内部属性 [[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //true</div></pre></td></tr></table></figure>
<p>可以将判断方法封装一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function isArray(obj) &#123;</div><div class="line">   return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</div><div class="line">&#125;</div><div class="line">var arr =[1,2,3];</div><div class="line">console.log(isArray(arr)); // true</div></pre></td></tr></table></figure>
<h4 id="4、ECMAScript-5的isArray函数"><a href="#4、ECMAScript-5的isArray函数" class="headerlink" title="4、ECMAScript 5的isArray函数"></a>4、ECMAScript 5的isArray函数</h4><p>为了让数组检测更方便，ECMAScript5新增了Array.isArray()方法。该方法的目的是最终确定某个值到底是不是数组，而不管它在哪个全局环境中创建的。</p>
<p><strong>注：此方法在IE8之前的版本是不支持的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(Array.isArray(arr)); // true</div></pre></td></tr></table></figure>
<h2 id="ECM3方法"><a href="#ECM3方法" class="headerlink" title="ECM3方法"></a>ECM3方法</h2><h3 id="1、Array-prototype-join"><a href="#1、Array-prototype-join" class="headerlink" title="1、Array.prototype.join()"></a>1、Array.prototype.join()</h3><p><code>join()</code> 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。此方法不会改变原数组。也就是说所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。</p>
<p><code>arr.join(separator)</code> 参数 <code>separator</code></p>
<ul>
<li>指定一个字符串来分隔数组的每个元素</li>
<li>如果省略()，数组元素用逗号分隔。默认为 “,”</li>
<li>如果separator是空字符串(“”)，则所有元素之间都没有任何字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a1&apos;, &apos;b2&apos;, &apos;c3&apos;];</div><div class="line">var myArr1 = arr.join();</div><div class="line">var myArr2 = arr.join(&apos;, &apos;);</div><div class="line">var myArr3 = arr.join(&apos; + &apos;);</div><div class="line">var myArr4 = arr.join(&apos;&apos;);</div><div class="line"></div><div class="line">console.log(myArr1);  // a1,b2,c3</div><div class="line">console.log(myArr2);  // a1, b2, c3</div><div class="line">console.log(myArr3);  // a1 + b2 + c3</div><div class="line">console.log(myArr4);  // a1b2c3</div></pre></td></tr></table></figure>
<h3 id="2、Array-prototype-push"><a href="#2、Array-prototype-push" class="headerlink" title="2、Array.prototype.push()"></a>2、Array.prototype.push()</h3><p>push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。</p>
<p><strong>添加元素：</strong>可以添加新的元素到数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 添加元素</div><div class="line">var letter = [&quot;a&quot;, &quot;b&quot;];</div><div class="line">var total = letter.push(&quot;c&quot;,&quot;d&quot;);</div><div class="line">console.log(total); // 4</div><div class="line">console.log(letter); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</div></pre></td></tr></table></figure>
<p><strong>合并数组</strong>：可以使用 apply() 添加第二个数组的所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 合并数组</div><div class="line">var arr1 = [1, 2];</div><div class="line">var arr2 = [&quot;a&quot;, &quot;b&quot;];</div><div class="line"></div><div class="line">// 将第二个数组融合进第一个数组</div><div class="line">// 相当于 arr1.push(&apos;a&apos;, &apos;b&apos;);</div><div class="line">Array.prototype.push.apply(arr1, arr2);</div><div class="line"></div><div class="line">console.log(arr1); // [1, 2, &quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure>
<h3 id="3、Array-prototype-pop"><a href="#3、Array-prototype-pop" class="headerlink" title="3、Array.prototype.pop()"></a>3、Array.prototype.pop()</h3><p>pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<p>如果你在一个空数组上调用 pop()，它返回  undefined。</p>
<h3 id="4、Array-prototype-unshift"><a href="#4、Array-prototype-unshift" class="headerlink" title="4、Array.prototype.unshift()"></a>4、Array.prototype.unshift()</h3><p>unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2];</div><div class="line"></div><div class="line">arr.unshift(0);</div><div class="line">//arr is [0, 1, 2]</div><div class="line"></div><div class="line">arr.unshift(-2, -1); // = 5</div><div class="line">//arr is [-2, -1, 0, 1, 2]</div><div class="line"></div><div class="line">arr.unshift( [-3] );</div><div class="line">//arr is [[-3], -2, -1, 0, 1, 2]</div></pre></td></tr></table></figure>
<h3 id="5、Array-prototype-shift"><a href="#5、Array-prototype-shift" class="headerlink" title="5、Array.prototype.shift()"></a>5、Array.prototype.shift()</h3><p>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;surgeon&apos;];</div><div class="line"></div><div class="line">console.log(&apos;调用 shift 之前: &apos; + myFish);</div><div class="line">// &quot;调用 shift 之前: angel,clown,mandarin,surgeon&quot;</div><div class="line"></div><div class="line">var shifted = myFish.shift();</div><div class="line"></div><div class="line">console.log(&apos;调用 shift 之后: &apos; + myFish);</div><div class="line">// &quot;调用 shift 之后: clown,mandarin,surgeon&quot;</div><div class="line"></div><div class="line">console.log(&apos;被删除的元素: &apos; + shifted);</div><div class="line">// &quot;被删除的元素: angel&quot;</div></pre></td></tr></table></figure>
<h3 id="6、Array-prototype-sort"><a href="#6、Array-prototype-sort" class="headerlink" title="6、Array.prototype.sort()"></a>6、Array.prototype.sort()</h3><p>sort(compareFunction) 方法在适当的位置对数组的元素进行排序，并返回数组。</p>
<p>sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。</p>
<p>一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数:</p>
<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</li>
<li>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [4, 2, 5, 1, 3];</div><div class="line">numbers.sort(function(a, b) &#123;</div><div class="line">  return a - b;</div><div class="line">&#125;);</div><div class="line">console.log(numbers); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h3 id="7、Array-prototype-reverse"><a href="#7、Array-prototype-reverse" class="headerlink" title="7、Array.prototype.reverse()"></a>7、Array.prototype.reverse()</h3><p>reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。</p>
<p>下例将会创建一个数组 myArray，其包含三个元素，然后颠倒该数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">myArray.reverse();</div><div class="line">console.log(myArray);  // [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</div></pre></td></tr></table></figure>
<h3 id="8、Array-prototype-concat"><a href="#8、Array-prototype-concat" class="headerlink" title="8、Array.prototype.concat()"></a>8、Array.prototype.concat()</h3><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</div><div class="line">var arr2 = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</div><div class="line"></div><div class="line">var arr3 = arr1.concat(arr2);</div><div class="line"></div><div class="line">console.log(arr3);</div><div class="line">// 返回结果是一个新数组</div><div class="line">// [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</div><div class="line"></div><div class="line">// 原数组没有改变</div><div class="line">console.log(arr1); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">console.log(arr2); // [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</div></pre></td></tr></table></figure>
<h3 id="9、Array-prototype-slice"><a href="#9、Array-prototype-slice" class="headerlink" title="9、Array.prototype.slice()"></a>9、Array.prototype.slice()</h3><p><code>slice(start, end)</code> 方法将数组的一部分浅拷贝, 返回到从开始到结束（不包括结束）选择的新数组对象。原始数组不会被修改。</p>
<ul>
<li>slice()</li>
<li>slice(start)</li>
<li>slice(start,end)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;];</div><div class="line"></div><div class="line">//如果不传参数，表示从数组0开始到到end（包含end）</div><div class="line">var newArr1 = arr.slice();</div><div class="line">console.log(newArr1)  // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div><div class="line"></div><div class="line">//如果省略 end，则表示从start开始到end（包含end）</div><div class="line">var newArr2 = arr.slice(1);</div><div class="line">console.log(newArr2) // [&quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div><div class="line"></div><div class="line">//如果传人star、end，则表示从start到end不包含end</div><div class="line">var newArr3 = arr.slice(1, 3);</div><div class="line">console.log(newArr3) // [&quot;two&quot;, &quot;three&quot;]</div><div class="line"></div><div class="line">console.log(arr)    // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div></pre></td></tr></table></figure>
<h3 id="10、Array-prototype-splice"><a href="#10、Array-prototype-splice" class="headerlink" title="10、Array.prototype.splice()"></a>10、Array.prototype.splice()</h3><p>splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。</p>
<p><strong>注意：splice 方法直接更改原数组内容</strong></p>
<ul>
<li>array.splice(start)</li>
<li>array.splice(start, deleteCount)</li>
<li>array.splice(start, deleteCount, item1, item2, …)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];</div><div class="line"></div><div class="line">//从第 2 位开始删除 0 个元素，插入 &quot;drum&quot;</div><div class="line">var removed = myFish.splice(2, 0, &quot;drum&quot;);</div><div class="line">console.log(myFish);</div><div class="line">//运算后的 myFish:[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[]，没有元素被删除</div><div class="line"></div><div class="line">//从第 3 位开始删除 1 个元素</div><div class="line">removed = myFish.splice(3, 1);</div><div class="line">//运算后的myFish：[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[&quot;mandarin&quot;]</div><div class="line"></div><div class="line">//从第 2 位开始删除 1 个元素，然后插入 &quot;trumpet&quot;</div><div class="line">removed = myFish.splice(2, 1, &quot;trumpet&quot;);</div><div class="line">//运算后的myFish: [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[&quot;drum&quot;]</div><div class="line"></div><div class="line">//从第 0 位开始删除 2 个元素，然后插入 &quot;parrot&quot;, &quot;anemone&quot; 和 &quot;blue&quot;</div><div class="line">removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;);</div><div class="line">//运算后的myFish：[&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素的数组：[&quot;angel&quot;, &quot;clown&quot;]</div><div class="line"></div><div class="line">//从第 3 位开始删除 2 个元素</div><div class="line">removed = myFish.splice(3, Number.MAX_VALUE);</div><div class="line">//运算后的myFish: [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;]</div><div class="line">//被删除元素的数组：[&quot;trumpet&quot;, &quot;surgeon&quot;]</div></pre></td></tr></table></figure>
<hr>
<h2 id="ECM5方法"><a href="#ECM5方法" class="headerlink" title="ECM5方法"></a>ECM5方法</h2><h3 id="1、Array-prototype-indexOf"><a href="#1、Array-prototype-indexOf" class="headerlink" title="1、Array.prototype.indexOf()"></a>1、Array.prototype.indexOf()</h3><p>indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [2, 6, 9, 6];</div><div class="line"></div><div class="line">a.indexOf(2); // 0</div><div class="line">a.indexOf(7); // -1 不存在</div><div class="line">a.indexOf(6); // 1 返回指定元素的第一个索引值</div></pre></td></tr></table></figure>
<p><strong>找出指定元素出现的所有位置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 找出 a 在 array 里的所有位置</div><div class="line">var str = &apos;a&apos;;</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;a&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line"></div><div class="line">var indices = [];</div><div class="line">var idx = array.indexOf(str);</div><div class="line"></div><div class="line">while (idx != -1) &#123;</div><div class="line">  indices.push(idx);</div><div class="line">  idx = array.indexOf(str, idx + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(indices);</div><div class="line">// [0, 2, 4]</div></pre></td></tr></table></figure>
<h3 id="2、Array-prototype-lastIndexOf"><a href="#2、Array-prototype-lastIndexOf" class="headerlink" title="2、Array.prototype.lastIndexOf()"></a>2、Array.prototype.lastIndexOf()</h3><p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</div></pre></td></tr></table></figure>
<p><strong>定位数组中的值：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9, 2];</div><div class="line">var index = array.lastIndexOf(2);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(7);</div><div class="line">// index is -1</div><div class="line">index = array.lastIndexOf(2, 3);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(2, 2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -1);</div><div class="line">// index is 3</div></pre></td></tr></table></figure>
<p><strong>查找所有元素</strong></p>
<p>下例使用 lastIndexOf 查找到一个元素在数组中所有的索引（下标），并使用 push 将所有添加到另一个数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var element = &apos;a&apos;;</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;a&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line">var indices = [];</div><div class="line">var idx = array.lastIndexOf(element);</div><div class="line"></div><div class="line">while (idx != -1) &#123;</div><div class="line">  indices.push(idx);</div><div class="line">  idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(indices);</div><div class="line">// [4, 2, 0];</div></pre></td></tr></table></figure>
<h3 id="3、Array-prototype-every"><a href="#3、Array-prototype-every" class="headerlink" title="3、Array.prototype.every()"></a>3、Array.prototype.every()</h3><p>every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>
<p>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</p>
<p>如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。</p>
<p>every 不会改变原数组。</p>
<p>every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。</p>
<p><strong>检测所有数组元素的大小</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [12, 5, 8, 130, 44].every(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 54, 18, 130, 44].every(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
<h3 id="4、Array-prototype-some"><a href="#4、Array-prototype-some" class="headerlink" title="4、Array.prototype.some()"></a>4、Array.prototype.some()</h3><p>some() 方法测试数组中的某些元素是否通过了指定函数的测试。</p>
<p>some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p>callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.some(callback[, thisArg])</div></pre></td></tr></table></figure>
<p>如果为 some 提供了一个 thisArg 参数，将会把它传给被调用的 callback，作为 this 值。否则，在非严格模式下将会是全局对象，严格模式下是 undefined。</p>
<p>some 被调用时不会改变数组。</p>
<p><strong>测试数组元素的值</strong></p>
<p>下面的例子检测在数组中是否有元素大于 10。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [2, 5, 8, 1, 4].some(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 5, 8, 1, 4].some(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
<h3 id="5、Array-prototype-filter"><a href="#5、Array-prototype-filter" class="headerlink" title="5、Array.prototype.filter()"></a>5、Array.prototype.filter()</h3><p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<p>对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var new_array = arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>
<p><strong>筛选排除掉所有的小值</strong></p>
<p>下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(value) &#123;</div><div class="line">  return value &gt;= 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);</div><div class="line">// filtered is [12, 130, 44]</div></pre></td></tr></table></figure>
<h3 id="6、Array-prototype-map"><a href="#6、Array-prototype-map" class="headerlink" title="6、Array.prototype.map()"></a>6、Array.prototype.map()</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数，<strong>返回这个新数组</strong>。</p>
<p><strong>求数组中每个元素的平方根</strong></p>
<p>下面的代码创建了一个新数组，值为原数组中对应数字的平方根。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 4, 9];</div><div class="line">var roots = numbers.map(Math.sqrt);</div><div class="line">/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */</div></pre></td></tr></table></figure>
<p><strong>问答题</strong></p>
<p>问题：<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt)</code> 答案是多少？</p>
<p>答案是<code>[1,NaN,NaN]</code></p>
<h3 id="7、Array-prototype-forEach"><a href="#7、Array-prototype-forEach" class="headerlink" title="7、Array.prototype.forEach()"></a>7、Array.prototype.forEach()</h3><p>forEach() 方法对数组的每个元素执行一次提供的函数。</p>
<p>对数组中的每一项运行给定函数，这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, this)</div></pre></td></tr></table></figure>
<ul>
<li>currentValue(当前值) 数组中正在处理的当前元素。</li>
<li>index(索引) 数组中正在处理的当前元素的索引。</li>
<li>array forEach()方法正在操作的数组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr=[2, 4, 5];</div><div class="line">arr.forEach(function(elm,index, array) &#123;</div><div class="line">   console.log(index, elm);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 0 2</div><div class="line">// 1 4</div><div class="line">// 2 5</div></pre></td></tr></table></figure>
<h3 id="8、Array-prototype-reduce"><a href="#8、Array-prototype-reduce" class="headerlink" title="8、Array.prototype.reduce()"></a>8、Array.prototype.reduce()</h3><p>reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<p><strong>将数组所有项相加</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var sum = [0, 1, 2, 3].reduce(function(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;, 0);</div><div class="line">// sum is 6</div></pre></td></tr></table></figure>
<p><strong>数组扁平化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</div><div class="line">    return a.concat(b);</div><div class="line">&#125;, []);</div><div class="line">// flattened is [0, 1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h3 id="9、Array-prototype-reduceRight"><a href="#9、Array-prototype-reduceRight" class="headerlink" title="9、Array.prototype.reduceRight()"></a>9、Array.prototype.reduceRight()</h3><p>reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(function(a, b) &#123;</div><div class="line">    return a.concat(b);</div><div class="line">&#125;, []);</div><div class="line"></div><div class="line">// flattened is [4, 5, 2, 3, 0, 1]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文主要内容引用：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN 的 JavaScript 标准库 Array 部分</a></li>
<li><a href="http://www.w3cplus.com/" target="_blank" rel="external">W3cplus 博客</a></li>
</ul>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-array-base.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。&lt;/p&gt;
&lt;h2 id=&quot;数组属性&quot;&gt;&lt;a href=&quot;#数组属性&quot; class=&quot;headerlink&quot; title=&quot;数组属性&quot;&gt;&lt;/a&gt;数组属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;constructor 表示引用数组对象的构造函数&lt;/li&gt;
&lt;li&gt;length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。&lt;/li&gt;
&lt;li&gt;prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&quot;一、创建方法&quot;&gt;&lt;a href=&quot;#一、创建方法&quot; class=&quot;headerlink&quot; title=&quot;一、创建方法&quot;&gt;&lt;/a&gt;一、创建方法&lt;/h3&gt;&lt;h4 id=&quot;创建一个空数组&quot;&gt;&lt;a href=&quot;#创建一个空数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个空数组&quot;&gt;&lt;/a&gt;创建一个空数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(); // 创建一个空数组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;`&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;创建一个指定长度的数组&quot;&gt;&lt;a href=&quot;#创建一个指定长度的数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个指定长度的数组&quot;&gt;&lt;/a&gt;创建一个指定长度的数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(size) // size 表示数组的长度&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;创建一个指定元素的数组&quot;&gt;&lt;a href=&quot;#创建一个指定元素的数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个指定元素的数组&quot;&gt;&lt;/a&gt;创建一个指定元素的数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="array" scheme="http://www.imeetyou.net/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 面向对象编程详解</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-oop.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-oop.html</id>
    <published>2017-03-18T10:25:34.000Z</published>
    <updated>2017-04-25T08:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript是一种基于对象的语言，秉承一切皆对象的理念。</p>
<p>但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态</p>
<p>那么如何用 Javascript 来实现面向对象编程呢</p>
<h1 id="1、利用Prototype模式实现封装"><a href="#1、利用Prototype模式实现封装" class="headerlink" title="1、利用Prototype模式实现封装"></a>1、利用Prototype模式实现封装</h1><p>在Javascript里每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这样，我们把那些不变的属性和方法，直接定义在<code>prototype</code>对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.legs = 2</div><div class="line">Person.prototype.speak = function() &#123;</div><div class="line">	console.log(&quot;我的名字是：&quot; + this.name + &quot;，年龄：&quot; + this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，生成实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var jack = new Person(&quot;jack&quot;, 26);</div><div class="line">var lily = new Person(&quot;lily&quot;, 25);</div><div class="line"></div><div class="line">jack.legs; // 2</div><div class="line">lily.speak() // 我的名字是：lily，年龄：25</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2、实现构造函数继承的五种方法"><a href="#2、实现构造函数继承的五种方法" class="headerlink" title="2、实现构造函数继承的五种方法"></a>2、实现构造函数继承的五种方法</h1><p>举例，有一个水果的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有个“苹果”的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>怎么使得 <code>Apple</code> 继承 <code>Fruit</code> 呢？</p>
<h2 id="第一种，借用构造函数（经典继承）"><a href="#第一种，借用构造函数（经典继承）" class="headerlink" title="第一种，借用构造函数（经典继承）"></a>第一种，借用构造函数（经典继承）</h2><p><strong>使用call/apply，构造函数绑定</strong>，如题，使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行</p>
<blockquote>
<p>基本思想:即在子类型构造函数的内部调用超类型构造函数.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name,color) &#123;</div><div class="line">    // 继承了Fruit，且向父类传递参数</div><div class="line">	Fruit.apply(this, arguments); // 这里用call也可以</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new Apple(&quot;苹果&quot;, &quot;红色&quot;);</div><div class="line">console.log(a.type) // 水果</div><div class="line">a.type = &quot;南瓜&quot; // 这里修改父类的属性值</div><div class="line">console.log(a.type) // 南瓜</div><div class="line"></div><div class="line">var b = new Apple();</div><div class="line">console.log(b.type); // 水果 可见引用类型值是独立的</div></pre></td></tr></table></figure>
<p>在这里，借用构造函数解决了原型链的两个问题：</p>
<ul>
<li>保证了原型链中引用类型值的独立,不再被所有实例共享;</li>
<li>子类型创建时也能够向父类型传递参数.</li>
</ul>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Fruit)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.</p>
<h2 id="第二种，原型prototype继承"><a href="#第二种，原型prototype继承" class="headerlink" title="第二种，原型prototype继承"></a>第二种，原型prototype继承</h2><h3 id="1、使用prototype属性继承"><a href="#1、使用prototype属性继承" class="headerlink" title="1、使用prototype属性继承"></a>1、使用prototype属性继承</h3><p>第二种方法比较常见，使用prototype属性。</p>
<p>如果水果的prototype对象，指向一个Fruit的实例，那么所有”水果”的实例，就能继承Fruit了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* </div><div class="line">* 将 Apple 的 prototype 对象指向 Fruit实例，</div><div class="line">* 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值</div><div class="line">*／</div><div class="line">Apple.prototype = new Fruit();</div><div class="line"></div><div class="line">// 将 Apple 的 prototype 对象的构造函数指回原来的构造函数</div><div class="line">Apple.prototype.constructor = Apple;</div><div class="line"></div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<h3 id="2、直接继承prototype"><a href="#2、直接继承prototype" class="headerlink" title="2、直接继承prototype"></a>2、直接继承prototype</h3><p>这里第2种方法是对第1种方法的改进。由于Fruit对象中，不变的属性都可以直接写入Fruit.prototype。<br>所以，我们也可以让Apple()跳过 Fruit()，直接继承Fruit.prototype。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Apple.prototype = Fruit.prototype;</div><div class="line">Apple.prototype.constructor = Apple; // 实际上把Fruit.prototype对象的constructor属性也改掉了</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Fruit的实例了），比较省内存。缺点是 <code>Apple.prototype</code>和<code>Fruit.prototype</code>现在指向了同一个对象，那么任何对<code>Apple.prototype</code>的修改，都会反映到<code>Fruit.prototype</code>。</p>
<p>所以，上面这一段代码其实是有问题的。请看这行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Apple.prototype.constructor = Apple;</div></pre></td></tr></table></figure>
<p>这一句实际上把 <code>Fruit.prototype</code> 对象的 <code>constructor</code> 属性也改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Fruit.prototype.constructor); // Apple</div></pre></td></tr></table></figure>
<h2 id="第三种-组合继承"><a href="#第三种-组合继承" class="headerlink" title="第三种 组合继承"></a>第三种 组合继承</h2><p>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.</p>
<blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &apos;水果&apos;;</div><div class="line">&#125;</div><div class="line">Fruit.prototype.getType = function() &#123;</div><div class="line">    console.log(this.type);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name,color) &#123;</div><div class="line">	Fruit.apply(this, arguments); // 继承实例属性，第一次调用Fruit，</div><div class="line">    this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Apple.prototype = new Fruit(name); // 继承父类方法，第二次调用Fruit</div><div class="line">Apple.prototype.getColor = function() &#123;</div><div class="line">    console.log(this.color)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var ap1 = new Apple(&quot;苹果&quot;, &quot;红色&quot;);</div><div class="line">ap1.type = &apos;红富士&apos;</div><div class="line">ap1.getType(); // &apos;红富士&apos;</div><div class="line">ap1.getColor(); // &apos;红色&apos;</div><div class="line"></div><div class="line">var ap2 = new Apple(&apos;香蕉苹果&apos;,&quot;黄色&quot;)</div><div class="line">console.log(ap2.type); // 水果</div><div class="line">ap2.getType(); // &apos;水果&apos;</div><div class="line">ap2.getColor(); // &apos;红色&apos;</div></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中<strong>最常用的继承模式</strong>. 而且, <code>instanceof</code> 和 <code>isPrototypeOf()</code> 也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢?</p>
<h2 id="第四种，利用空对象作为中介-寄生组合式继承"><a href="#第四种，利用空对象作为中介-寄生组合式继承" class="headerlink" title="第四种，利用空对象作为中介(寄生组合式继承)"></a>第四种，利用空对象作为中介(寄生组合式继承)</h2><p>由于前面的 “直接继承prototype” 存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var F = function()&#123;&#125;; // F是空对象，所以几乎不占内存</div><div class="line">F.prototype = Fruit.prototype;</div><div class="line">Apple.prototype = new F(); // 修改Apple的prototype对象，就不会影响到Fruit的prototype对象</div><div class="line">Apple.prototype.constructor = Apple;</div><div class="line"></div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>将上面方法，封装一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function extend(Child, Parent) &#123;</div><div class="line">　　var F = function()&#123;&#125;;</div><div class="line">　　F.prototype = Parent.prototype;</div><div class="line">　　Child.prototype = new F();</div><div class="line">　　Child.prototype.constructor = Child;</div><div class="line">　　Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候，方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend(Apple,Fruit)</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>这个extend函数，就是YUI库如何实现继承的方法。<br>另外，说明一点，函数体最后一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Child.uber = Parent.prototype;</div></pre></td></tr></table></figure>
<p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<p>##第五种， 拷贝继承</p>
<p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Fruit的所有不变属性，都放到它的prototype对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Fruit()&#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div></pre></td></tr></table></figure>
<p>然后，写一个函数，实现属性拷贝的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extend2(Child, Parent) &#123;</div><div class="line">　　var p = Parent.prototype;</div><div class="line">　　var c = Child.prototype;</div><div class="line">　  for (var i in p) &#123;</div><div class="line">　　　　	c[i] = p[i];</div><div class="line">　　&#125;</div><div class="line">　　c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父对象的 prototype 对象中的属性，一一拷贝给 Child 对象的 prototype 对象。</p>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend2(Apple, Fruit);</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<h1 id="3、不使用构造函数实现”继承”的方法"><a href="#3、不使用构造函数实现”继承”的方法" class="headerlink" title="3、不使用构造函数实现”继承”的方法"></a>3、不使用构造函数实现”继承”的方法</h1><p><strong>什么是”非构造函数”的继承？</strong></p>
<p>比如，现在有一个对象，叫做”中国人”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>还有一个对象，叫做”医生”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor =&#123;</div><div class="line">　　career:&apos;医生&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<h3 id="第一种-object-方法"><a href="#第一种-object-方法" class="headerlink" title="第一种 object()方法"></a>第一种 object()方法</h3><p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">　　function F() &#123;&#125;</div><div class="line">　　F.prototype = o;</div><div class="line">　　return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = object(Chinese);</div></pre></td></tr></table></figure>
<p>然后，再加上子对象本身的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.career = &apos;医生&apos;;</div></pre></td></tr></table></figure>
<p>这时，子对象已经继承了父对象的属性了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Doctor =&#123;</div><div class="line">　　　career:&apos;医生&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function object(o) &#123;</div><div class="line">　　function F() &#123;&#125;</div><div class="line">　　F.prototype = o;</div><div class="line">　　return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Doctor = object(Chinese);</div><div class="line"></div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line"></div><div class="line">alert(Doctor.nation); //中国</div></pre></td></tr></table></figure>
<p>在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承.</p>
<p>object.create() 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Doctor =&#123;</div><div class="line">　　　career:&apos;医生&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Doctor = Object.create(Chinese);</div><div class="line"></div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line"></div><div class="line">alert(Doctor.nation); //中国</div></pre></td></tr></table></figure>
<p><code>object.create()</code> 只有一个参数时功能与上述<code>object</code>方法相同，目前支持 <code>Object.create()</code> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<h3 id="第二种-浅拷贝"><a href="#第二种-浅拷贝" class="headerlink" title="第二种 浅拷贝"></a>第二种 浅拷贝</h3><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extendCopy(p) &#123;</div><div class="line">　　var c = &#123;&#125;;</div><div class="line">　　for (var i in p) &#123;</div><div class="line">　　　　c[i] = p[i];</div><div class="line">　　&#125;</div><div class="line">　　c.uber = p;</div><div class="line">　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div></pre></td></tr></table></figure>
<p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div></pre></td></tr></table></figure>
<p>然后，我们为Doctor的”出生地”添加一个城市</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>发生了什么事？Chinese的”出生地”也被改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门</div></pre></td></tr></table></figure>
<p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<h3 id="第三种-深拷贝"><a href="#第三种-深拷贝" class="headerlink" title="第三种 深拷贝"></a>第三种 深拷贝</h3><p>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p, c) &#123;</div><div class="line">　　　　var c = c || &#123;&#125;;</div><div class="line">　　　　for (var i in p) &#123;</div><div class="line">　　　　　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">　　　　　　　　deepCopy(p[i], c[i]);</div><div class="line">　　　　　　&#125; else &#123;</div><div class="line">　　　　　　　　　c[i] = p[i];</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = deepCopy(Chinese);</div></pre></td></tr></table></figure>
<p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>这时，父对象就不会受到影响了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港</div></pre></td></tr></table></figure>
<p>目前，jQuery库使用的就是这种继承方法。</p>
<hr>
<blockquote>
<p>以上文章内容，转载修改自<a href="http://www.ruanyifeng.com/blog/javascript/" target="_blank" rel="external">阮一峰的网络日志</a>，仅作学习总结，原文链接如下：</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">Javascript面向对象编程（三）：非构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">Javascript面向对象编程（二）：构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">Javascript 面向对象编程（一）：封装</a></p>
</blockquote>
<p>本文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-oop.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-oop.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript是一种基于对象的语言，秉承一切皆对象的理念。&lt;/p&gt;
&lt;p&gt;但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态&lt;/p&gt;
&lt;p&gt;那么如何用 Javascript 来实现面向对象编程呢&lt;/p&gt;
&lt;h1 id=&quot;1、利用Prototype模式实现封装&quot;&gt;&lt;a href=&quot;#1、利用Prototype模式实现封装&quot; class=&quot;headerlink&quot; title=&quot;1、利用Prototype模式实现封装&quot;&gt;&lt;/a&gt;1、利用Prototype模式实现封装&lt;/h1&gt;&lt;p&gt;在Javascript里每一个构造函数都有一个&lt;code&gt;prototype&lt;/code&gt;属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。&lt;/p&gt;
&lt;p&gt;这样，我们把那些不变的属性和方法，直接定义在&lt;code&gt;prototype&lt;/code&gt;对象上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Person(name,age) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.age = age;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Person.prototype.legs = 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Person.prototype.speak = function() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(&amp;quot;我的名字是：&amp;quot; + this.name + &amp;quot;，年龄：&amp;quot; + this.age);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，生成实例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var jack = new Person(&amp;quot;jack&amp;quot;, 26);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var lily = new Person(&amp;quot;lily&amp;quot;, 25);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jack.legs; // 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lily.speak() // 我的名字是：lily，年龄：25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="oop" scheme="http://www.imeetyou.net/tags/oop/"/>
    
  </entry>
  
</feed>
