<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>智的前端之路</title>
  <subtitle>若有智，事可为</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.imeetyou.net/"/>
  <updated>2017-03-28T05:38:24.000Z</updated>
  <id>http://www.imeetyou.net/</id>
  
  <author>
    <name>KINGZHI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kindle 书籍源下载推荐</title>
    <link href="http://www.imeetyou.net/posts/life/2017/kindle-book.html"/>
    <id>http://www.imeetyou.net/posts/life/2017/kindle-book.html</id>
    <published>2017-03-28T04:35:39.000Z</published>
    <updated>2017-03-28T05:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>近日重拾公司所发kindle，之前一度觉得手机阅读完全可以替代这个产品，但手机看pdf文件，还是不够舒适，虽然是无背光版的，但在上下班路上的几个小时，用kindle阅读一些书籍感觉还是挺不错的，愉快的加入kindle大家庭，多刷秘籍吧。</p>
<h2 id="新手入门介绍"><a href="#新手入门介绍" class="headerlink" title="新手入门介绍"></a>新手入门介绍</h2><p><a href="https://kindlefere.com/" target="_blank" rel="external">Kindle伴侣 为静心阅读而生</a></p>
<p>将近日下载 Kindle 书籍源地址等整理分享一下，也算服务大众吧。</p>
<a id="more"></a>
<h2 id="推送及下载网站"><a href="#推送及下载网站" class="headerlink" title="推送及下载网站"></a>推送及下载网站</h2><p>除了<a href="https://www.amazon.cn/Kindle%E5%85%8D%E8%B4%B9%E7%94%B5%E5%AD%90%E4%B9%A6/b/ref=sa_menu_kindle_l3_b116175071?ie=UTF8&amp;node=116175071" target="_blank" rel="external">亚马逊 Kindle 商店免费电子书</a>,还有很多下载地址， 个人觉得比较方便全面的整理了一下：</p>
<ol>
<li><a href="http://readfree.me/" target="_blank" rel="external">readfree</a> 每日可以下载或推送2个书籍</li>
<li><a href="https://book.90xz.com/" target="_blank" rel="external">90图书网</a> 每日推送一个</li>
<li><a href="http://www.kindlepush.com/main" target="_blank" rel="external">kindle推</a> 普通会员下载4个，推送2个，这个挺不错</li>
<li><a href="http://forfrigg.com/" target="_blank" rel="external">forfrigg</a> 搜索需要科学上网，你懂的</li>
<li><a href="http://mebook.cc/" target="_blank" rel="external">我的小书屋</a> 可直接下载，多格式，图书有简介。</li>
<li><a href="https://www.gitbook.com/explore" target="_blank" rel="external">GitBook</a> 怎能忘了程序员的出书平台呢</li>
</ol>
<h2 id="书籍转换及制作工具"><a href="#书籍转换及制作工具" class="headerlink" title="书籍转换及制作工具"></a>书籍转换及制作工具</h2><ul>
<li>阅读 azw3 用 <a href="http://mac.softpedia.com/get/Utilities/Clearview-Reader.shtml" target="_blank" rel="external">clearview</a></li>
<li>转换格式用 <a href="http://www.calibre-ebook.com/download_osx" target="_blank" rel="external">calibre</a>，很方便将通常pdf格式转换为 azw3 格式</li>
</ul>
<p>更多格式转换技巧查看：<a href="https://kindlefere.com/skills/convert" target="_blank" rel="external">格式转换 – Kindle伴侣</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日重拾公司所发kindle，之前一度觉得手机阅读完全可以替代这个产品，但手机看pdf文件，还是不够舒适，虽然是无背光版的，但在上下班路上的几个小时，用kindle阅读一些书籍感觉还是挺不错的，愉快的加入kindle大家庭，多刷秘籍吧。&lt;/p&gt;
&lt;h2 id=&quot;新手入门介绍&quot;&gt;&lt;a href=&quot;#新手入门介绍&quot; class=&quot;headerlink&quot; title=&quot;新手入门介绍&quot;&gt;&lt;/a&gt;新手入门介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://kindlefere.com/&quot;&gt;Kindle伴侣 为静心阅读而生&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将近日下载 Kindle 书籍源地址等整理分享一下，也算服务大众吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.imeetyou.net/categories/life/"/>
    
    
      <category term="kindle" scheme="http://www.imeetyou.net/tags/kindle/"/>
    
      <category term="life" scheme="http://www.imeetyou.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>typeof与instanceof的区别</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-typeof-instanceof.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-typeof-instanceof.html</id>
    <published>2017-03-26T09:24:36.000Z</published>
    <updated>2017-03-28T08:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>typeof和instanceof都可以用来判断变量，它们的用法有很大区别：</p>
<ul>
<li><strong>typeof：返回一个变量的基本类型，检测的是基本数据类型</strong></li>
<li><strong>instanceof：返回的是一个布尔值，检测的是引用类型</strong></li>
</ul>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(typeof 1); // number</div><div class="line">console.log(typeof &quot;abc&quot;); // string</div><div class="line">console.log(typeof true); // boolean</div><div class="line">console.log(typeof a); // undefined</div><div class="line">console.log(typeof new Object()); // object</div><div class="line">console.log(typeof null); // object</div><div class="line">console.log(typeof []); // object</div></pre></td></tr></table></figure>
<p>可以看到 <code>typeof</code> 无法判断数组、null，不管是数组还是对象，都会返回 object </p>
<p>更多方法具体可查看 <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html" target="_blank" rel="external">《Javascript基础之数组》</a>—数组检测方法</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof返回的是一个布尔值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&#125;;</div><div class="line">console.log(a instanceof Object);  // true</div><div class="line">var b = [];</div><div class="line">console.log(b instanceof Array);  // true</div></pre></td></tr></table></figure>
<p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,所以可以用来判断数组。</p>
<p>需要注意的是，<strong>instanceof只能用来判断对象和函数，不能用来判断字符串和数字等</strong>，如：</p>
<p>```<br>var b = ‘123’;<br>console.log(b instanceof String);  // false<br>console.log(typeof b);  // string</p>
<p>var c = new String(“123”);<br>console.log(c instanceof String);  // true<br>console.log(typeof c);  // object</p>
<p>更多格式转换技巧查看：<a href="https://kindlefere.com/skills/convert" target="_blank" rel="external">格式转换 – Kindle伴侣</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;typeof和instanceof都可以用来判断变量，它们的用法有很大区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;typeof：返回一个变量的基本类型，检测的是基本数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;instanceof：返回的是一个布尔值，检测的是引用类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h2&gt;&lt;p&gt;typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例：&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="typeof" scheme="http://www.imeetyou.net/tags/typeof/"/>
    
      <category term="instanceof" scheme="http://www.imeetyou.net/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>Javascript数组常见问题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-array-issue.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-array-issue.html</id>
    <published>2017-03-23T09:24:23.000Z</published>
    <updated>2017-03-23T08:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、删除数组里指定的某个元素"><a href="#1、删除数组里指定的某个元素" class="headerlink" title="1、删除数组里指定的某个元素"></a>1、删除数组里指定的某个元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var arr = [3,2,3,3,5,3],</div><div class="line">	val = 3;</div><div class="line"></div><div class="line">var removeElement = function(arr, elm) &#123;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		if (arr[i] == elm) &#123;</div><div class="line">			arr.splice(i, 1);</div><div class="line">			i--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(removeElement(arr, val)); // [2, 5]</div></pre></td></tr></table></figure>
<p><strong>注意：这里for循环里的length是动态的，随着splice删除数组元素而变小，这里不能用forEach，因为forEach方法它一开始执行就自动缓存数组的长度，删除数组元素会出现意外。</strong></p>
<a id="more"></a>
<h2 id="2、数组去重的方法"><a href="#2、数组去重的方法" class="headerlink" title="2、数组去重的方法"></a>2、数组去重的方法</h2><h3 id="第一种，双重遍历去重法"><a href="#第一种，双重遍历去重法" class="headerlink" title="第一种，双重遍历去重法"></a>第一种，双重遍历去重法</h3><ol>
<li>构建一个新的数组存放结果</li>
<li>for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比</li>
<li>若结果数组中没有该元素，则存到结果数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 去除数组里的重复元素</div><div class="line">function unique(arr) &#123;</div><div class="line">    var ret = [];</div><div class="line">    var len = arr.length;</div><div class="line">    var isRepeat;</div><div class="line">    for(var i=0; i&lt;len; i++) &#123;</div><div class="line">        isRepeat = false;</div><div class="line">        for(var j=i+1; j&lt;len; j++) &#123;</div><div class="line">            if(arr[i] === arr[j])&#123;</div><div class="line">                isRepeat = true;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(!isRepeat)&#123;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">var arr = [3, 3, 2, 3];</div><div class="line">console.log(unique(arr)); // [2, 3]</div></pre></td></tr></table></figure>
<h3 id="第二种，对象键值对法"><a href="#第二种，对象键值对法" class="headerlink" title="第二种，对象键值对法"></a>第二种，对象键值对法</h3><ol>
<li>创建一个新的数组存放结果</li>
<li>创建一个空对象</li>
<li>for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。</li>
</ol>
<p><strong>说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">	var res = [];</div><div class="line">	var json = &#123;&#125;;</div><div class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		if (!json[arr[i]]) &#123;</div><div class="line">			res.push(arr[i]);</div><div class="line">			json[arr[i]] = 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [3, 3, 2, &quot;3&quot;, &quot;a&quot;, &quot;a&quot;];</div><div class="line">console.log(unique(arr)); // [3, 2, &quot;a&quot;]</div></pre></td></tr></table></figure>
<h3 id="第三种，ES5方法"><a href="#第三种，ES5方法" class="headerlink" title="第三种，ES5方法"></a>第三种，ES5方法</h3><p>利用 ES5 里的方法, indexOf、filter</p>
<p>arr.indexOf(要查找的元素)，返回被找到的元素在数组中的索引位置，如果没有则返回-1。</p>
<p>arr.filter(元素的值，元素的索引，被遍历的数组)，返回一个通过测试的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">  var res = arr.filter(function(item, index, array) &#123;</div><div class="line">    return array.indexOf(item) === index;</div><div class="line">  &#125;);</div><div class="line">  return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 1, &apos;1&apos;, &apos;2&apos;, 1];</div><div class="line">var ans = unique(arr);</div><div class="line">console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</div></pre></td></tr></table></figure>
<h3 id="第四种，ES6方法"><a href="#第四种，ES6方法" class="headerlink" title="第四种，ES6方法"></a>第四种，ES6方法</h3><p>ES6 部署了 Set 以及 Array.from 方法，如果浏览器支持，完全可以这样：</p>
<p>ES2015还引入了一种叫作Set的数据类型，它不允许重复元素出现，如果你重复添加同一个元素的话，Set中只会存在一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">  return Array.from(new Set(arr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 2, &quot;a&quot;, &quot;1&quot;, 2 ,&quot;a&quot;];</div><div class="line">console.log(unique(arr)) // [1, 2, &quot;a&quot;, &quot;1&quot;]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>关于数组去重更多详细方法参看</p>
<p><a href="https://github.com/hanzichi/underscore-analysis/issues/9" target="_blank" rel="external">JavaScript 数组去重</a></p>
<p><a href="http://www.jstips.co/zh_cn/deduplicate-an-array/" target="_blank" rel="external">数组去重 – JS Tips – A JS tip per day!</a></p>
<p><a href="http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array" target="_blank" rel="external">Remove Duplicates from JavaScript Array</a></p>
<p><a href="https://github.com/lifesinger/blog/issues/113" target="_blank" rel="external">从 JavaScript 数组去重谈性能优化</a></p>
<p><a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank" rel="external">也谈 JavaScript 数组去重</a></p>
</blockquote>
<h2 id="3、取数组中最大值最小值"><a href="#3、取数组中最大值最小值" class="headerlink" title="3、取数组中最大值最小值"></a>3、取数组中最大值最小值</h2><h3 id="遍历比较方法"><a href="#遍历比较方法" class="headerlink" title="遍历比较方法"></a>遍历比较方法</h3><ol>
<li>设一个变量存放最大值，将数组中第一个值赋值给该变量</li>
<li>遍历数组与最大值变量比较，如果大于最大值，则将该值赋值最大值变量</li>
<li>遍历结束后，变量里储存的就是数组里的最大值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function arrayMax(arr) &#123;</div><div class="line">   var max = arr[0];</div><div class="line">   arr.forEach(function(v)&#123;</div><div class="line">   	  if(v &gt; max) &#123;</div><div class="line">	     max = v</div><div class="line">      &#125;</div><div class="line">   &#125;)</div><div class="line">   return max;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(arrayMax(arr)); // 45</div></pre></td></tr></table></figure>
<h3 id="利用-Math-max-与-Math-min-方法"><a href="#利用-Math-max-与-Math-min-方法" class="headerlink" title="利用 Math.max() 与 Math.min() 方法"></a>利用 Math.max() 与 Math.min() 方法</h3><p>将数组转换成参数传进Math.max()或Math.min()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function max(arr) &#123;</div><div class="line">  return Math.max.apply(&#123;&#125;,arr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(max(arr)); // 45</div></pre></td></tr></table></figure>
<h3 id="ES5方法"><a href="#ES5方法" class="headerlink" title="ES5方法"></a>ES5方法</h3><ol>
<li>利用数组实例的 reduce(function(prev,curv,index,arr))  方法</li>
<li>依次比较回调函数中参数 prev 与 curv 的大小，返回大的那个</li>
</ol>
<p><strong>reduce(function(上一次调用回调返回的值, 数组中正在处理的元素, 当前元素索引, 调用reduce的数组))</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function max(arr) &#123;</div><div class="line">  return arr.reduce(function(prev,curv)&#123;</div><div class="line">      return prev &gt; curv ? prev : curv</div><div class="line">  &#125;) </div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [1, 3, 45, 24, 8, 20];</div><div class="line">console.log(max(arr)); // 45</div></pre></td></tr></table></figure>
<h2 id="4、多维数组扁平化"><a href="#4、多维数组扁平化" class="headerlink" title="4、多维数组扁平化"></a>4、多维数组扁平化</h2><p>将多维数组”拍平”</p>
<p>将下列数组转为单一数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div></pre></td></tr></table></figure>
<h3 id="1、双层遍历法"><a href="#1、双层遍历法" class="headerlink" title="1、双层遍历法"></a>1、双层遍历法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [];</div><div class="line">for (var i = 0; i &lt; myArray.length; ++i) &#123;</div><div class="line">  for (var j = 0; j &lt; myArray[i].length; ++j)</div><div class="line">    newArray.push(myArray[i][j]);</div><div class="line">&#125;</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="2、使用concat-和apply"><a href="#2、使用concat-和apply" class="headerlink" title="2、使用concat()和apply()"></a>2、使用concat()和apply()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [].concat.apply([], myArray);</div><div class="line"></div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="3、使用reduce"><a href="#3、使用reduce" class="headerlink" title="3、使用reduce()"></a>3、使用reduce()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = myArray.reduce(function(prev, curr) &#123;</div><div class="line">  return prev.concat(curr);</div><div class="line">&#125;);</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<h3 id="4、使用-ES6-的展开运算符"><a href="#4、使用-ES6-的展开运算符" class="headerlink" title="4、使用 ES6 的展开运算符"></a>4、使用 ES6 的展开运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];</div><div class="line">var newArray = [].concat(...myArray);</div><div class="line">console.log(newArray);</div><div class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>引用参考列表</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN 的 JavaScript 标准库 Array 部分</a></p>
<p><a href="http://www.jstips.co/zh_CN/" target="_blank" rel="external">Js Tips</a></p>
<p><a href="http://www.ferecord.com/lujs-array.html#_13" target="_blank" rel="external">撸js基础之数组</a></p>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-issue.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-array-issue.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、删除数组里指定的某个元素&quot;&gt;&lt;a href=&quot;#1、删除数组里指定的某个元素&quot; class=&quot;headerlink&quot; title=&quot;1、删除数组里指定的某个元素&quot;&gt;&lt;/a&gt;1、删除数组里指定的某个元素&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = [3,2,3,3,5,3],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	val = 3;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var removeElement = function(arr, elm) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	for (var i = 0; i &amp;lt; arr.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		if (arr[i] == elm) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			arr.splice(i, 1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			i--;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	return arr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(removeElement(arr, val)); // [2, 5]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：这里for循环里的length是动态的，随着splice删除数组元素而变小，这里不能用forEach，因为forEach方法它一开始执行就自动缓存数组的长度，删除数组元素会出现意外。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="array" scheme="http://www.imeetyou.net/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-class3.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-class3.html</id>
    <published>2017-03-23T01:22:23.000Z</published>
    <updated>2017-03-23T01:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。</p>
<p>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</p>
<h2 id="1、构造函数法"><a href="#1、构造函数法" class="headerlink" title="1、构造函数法"></a>1、构造函数法</h2><p>第一种是经典方法，它用构造函数模拟”类”，在其内部用this关键字指代实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Dog() &#123;</div><div class="line">　　this.name = &quot;旺财&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成实例的时候，使用new关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dog = new Dog();</div><div class="line">console.log(dog.name); // 旺财</div></pre></td></tr></table></figure>
<p>类的属性和方法，还可以定义在构造函数的prototype对象之上。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Dog.prototype.wow = function()&#123;</div><div class="line">　 console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于这种方法的详细介绍，请看《Javascript 面向对象编程》，这里就不多说了。</p>
<p>它的主要缺点是，比较复杂，用到了this和prototype，编写和阅读都很费力。</p>
<h2 id="2、Object-create-法"><a href="#2、Object-create-法" class="headerlink" title="2、Object.create()法"></a>2、Object.create()法</h2><p>在ECM5中，加入一个新的方法 <code>Object.create()</code>,用这个方法，”类”就是一个对象，不是函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">	this.name = &quot;旺财&quot;;</div><div class="line">    wow: function() &#123;</div><div class="line">		console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，直接用Object.create()生成实例，不需要用到new。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dog = Object.create(Dog);</div><div class="line">console.log(dog.name); // 旺财</div><div class="line">dog.wow(); // 汪～汪～汪！</div></pre></td></tr></table></figure>
<p>这种方法不能实现私有属性和私有方法，实例对象之间也不能共享数据。</p>
<h2 id="3、BlackScript-法"><a href="#3、BlackScript-法" class="headerlink" title="3、BlackScript 法"></a>3、BlackScript 法</h2><p>荷兰程序员Gabor de Mooij提出了一种比Object.create()更好的<a href="http://www.gabordemooij.com/index.php?p=/blackscript" target="_blank" rel="external">新方法</a>。</p>
<p>事实上就是用一个对象模拟类，在这个类里，定义一个构造函数 createNew() 用来生成实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      //some code</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在 createNew() 里面，定义一个实例对象，把这个实例对象作为返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.wow(); // 汪～汪～汪！</div></pre></td></tr></table></figure>
<p>这种方法简单易学，可以实现OOP的特性，继承、私有属性和方法、数据共享。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>比如让 Dog 继承 Animal,只要在 Dog的 createNew()方法中，调用后者的createNew()方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Animal = &#123;</div><div class="line">　　　　createNew: function()&#123;</div><div class="line">　　　　　　var animal = &#123;&#125;;</div><div class="line">　　　　　　animal.sleep = function()&#123; </div><div class="line">				console.log(&quot;睡懒觉&quot;);</div><div class="line">		  &#125;;</div><div class="line">　　　　　　return animal;</div><div class="line">　　　　&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后，在 Dog 的 createNew() 方法中，调用 Animal 的 createNew() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = Animal.createNew();</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(&quot;汪～汪～汪！&quot;);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样得到的 Dog 实例，就会同时继承 Dog 类和Animal类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.sleep() // 睡懒觉 </div><div class="line">dog1.wow() // 汪～汪～汪！</div></pre></td></tr></table></figure>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>在 createNew() 方法中，只要不是定义在 dog 对象上的方法和属性，都是私有的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">      var sound = &quot;汪汪汪&quot;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.wow = function() &#123;</div><div class="line">         console.log(sound);</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上例的内部变量 sound，外部无法读取，只有通过 dog 的公有方法 wow() 来读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">dog1.name // 旺财</div><div class="line">dog1.sound // undefined </div><div class="line">dog1.wow() // 汪汪汪</div></pre></td></tr></table></figure>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>有时候，我们需要所有实例对象，能够读写同一项内部数据。</p>
<p>这个时候，只要把这个内部数据，封装在类对象的里面、createNew()方法的外面即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var Dog = &#123;</div><div class="line">   sound: &quot;汪汪汪&quot;,</div><div class="line">   createNew: function()&#123;</div><div class="line">      var dog = &#123;&#125;;</div><div class="line">	  dog.name = &quot;旺财&quot;;</div><div class="line">      dog.sound = function() &#123;</div><div class="line">         console.log(Dog.sound);</div><div class="line">      &#125;</div><div class="line">      dog.changSound = function(para)&#123;</div><div class="line">         Dog.sound = para</div><div class="line">      &#125;</div><div class="line">      return dog;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>生成两个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var dog1 = Dog.createNew();</div><div class="line">var dog2 = Dog.createNew();</div><div class="line">dog1.sound(); // 汪汪汪</div><div class="line">dog2.sound(); // 汪汪汪</div></pre></td></tr></table></figure>
<p>这时，如果有一个实例对象，修改了共享的数据，另一个实例对象也会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dog2.changSound(&quot;呱呱呱&quot;);</div><div class="line">dog1.sound(); // 呱呱呱</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文转载引用自 <a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="external">Javascript定义类（class）的三种方法</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。&lt;/p&gt;
&lt;p&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/p&gt;
&lt;h2 id=&quot;1、构造函数法&quot;&gt;&lt;a href=&quot;#1、构造函数法&quot; class=&quot;headerlink&quot; title=&quot;1、构造函数法&quot;&gt;&lt;/a&gt;1、构造函数法&lt;/h2&gt;&lt;p&gt;第一种是经典方法，它用构造函数模拟”类”，在其内部用this关键字指代实例对象。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Dog() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　this.name = &amp;quot;旺财&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成实例的时候，使用new关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var dog = new Dog();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(dog.name); // 旺财&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类的属性和方法，还可以定义在构造函数的prototype对象之上。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="class" scheme="http://www.imeetyou.net/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>Javascript基础之数组</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-array-base.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-array-base.html</id>
    <published>2017-03-22T03:34:42.000Z</published>
    <updated>2017-03-22T08:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。</p>
<h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><ul>
<li>constructor 表示引用数组对象的构造函数</li>
<li>length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。</li>
<li>prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="一、创建方法"><a href="#一、创建方法" class="headerlink" title="一、创建方法"></a>一、创建方法</h3><h4 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [];</div><div class="line">var arr = new Array(); // 创建一个空数组</div><div class="line">`</div></pre></td></tr></table></figure>
<h4 id="创建一个指定长度的数组"><a href="#创建一个指定长度的数组" class="headerlink" title="创建一个指定长度的数组"></a>创建一个指定长度的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array(size) // size 表示数组的长度</div></pre></td></tr></table></figure>
<h4 id="创建一个指定元素的数组"><a href="#创建一个指定元素的数组" class="headerlink" title="创建一个指定元素的数组"></a>创建一个指定元素的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、检测方法"><a href="#二、检测方法" class="headerlink" title="二、检测方法"></a>二、检测方法</h3><h4 id="1、利用-instanceof-操作符"><a href="#1、利用-instanceof-操作符" class="headerlink" title="1、利用 instanceof 操作符"></a>1、利用 instanceof 操作符</h4><p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(arr instanceof Array) // true</div></pre></td></tr></table></figure>
<h4 id="2、通过对象自身的-constructor-属性"><a href="#2、通过对象自身的-constructor-属性" class="headerlink" title="2、通过对象自身的 constructor 属性"></a>2、通过对象自身的 constructor 属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(arr.constructor === Array) // true</div></pre></td></tr></table></figure>
<p><strong>跨frame实例化对象带来的问题</strong></p>
<p><code>constructor</code> 和 <code>instanceof</code> 貌似很好的两个检测数组的方法，但实际上还是有些漏洞的，当你在多个frame中回来跳的时候，这两种方法就惨了。</p>
<p>由于每一个frame都有自己的一套执行环境，跨frame实例化的对象彼此并不共享原型链，通过 <code>instanceof</code> 操作符和 <code>constructor</code> 属性检测的方法自然会失败。</p>
<p>那么第三种方法就比较好了，如下</p>
<h4 id="3、对象原生toString检测"><a href="#3、对象原生toString检测" class="headerlink" title="3、对象原生toString检测"></a>3、对象原生toString检测</h4><p><code>Object.prototype.toString</code> 的行为：首先，取得对象的一个内部属性 [[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //true</div></pre></td></tr></table></figure>
<p>可以将判断方法封装一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function isArray(obj) &#123;</div><div class="line">   return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</div><div class="line">&#125;</div><div class="line">var arr =[1,2,3];</div><div class="line">console.log(isArray(arr)); // true</div></pre></td></tr></table></figure>
<h4 id="4、ECMAScript-5的isArray函数"><a href="#4、ECMAScript-5的isArray函数" class="headerlink" title="4、ECMAScript 5的isArray函数"></a>4、ECMAScript 5的isArray函数</h4><p>为了让数组检测更方便，ECMAScript5新增了Array.isArray()方法。该方法的目的是最终确定某个值到底是不是数组，而不管它在哪个全局环境中创建的。</p>
<p><strong>注：此方法在IE8之前的版本是不支持的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr =[1,2,3];</div><div class="line">console.log(Array.isArray(arr)); // true</div></pre></td></tr></table></figure>
<h2 id="ECM3方法"><a href="#ECM3方法" class="headerlink" title="ECM3方法"></a>ECM3方法</h2><h3 id="1、Array-prototype-join"><a href="#1、Array-prototype-join" class="headerlink" title="1、Array.prototype.join()"></a>1、Array.prototype.join()</h3><p><code>join()</code> 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。此方法不会改变原数组。也就是说所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。</p>
<p><code>arr.join(separator)</code> 参数 <code>separator</code></p>
<ul>
<li>指定一个字符串来分隔数组的每个元素</li>
<li>如果省略()，数组元素用逗号分隔。默认为 “,”</li>
<li>如果separator是空字符串(“”)，则所有元素之间都没有任何字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a1&apos;, &apos;b2&apos;, &apos;c3&apos;];</div><div class="line">var myArr1 = arr.join();</div><div class="line">var myArr2 = arr.join(&apos;, &apos;);</div><div class="line">var myArr3 = arr.join(&apos; + &apos;);</div><div class="line">var myArr4 = arr.join(&apos;&apos;);</div><div class="line"></div><div class="line">console.log(myArr1);  // a1,b2,c3</div><div class="line">console.log(myArr2);  // a1, b2, c3</div><div class="line">console.log(myArr3);  // a1 + b2 + c3</div><div class="line">console.log(myArr4);  // a1b2c3</div></pre></td></tr></table></figure>
<h3 id="2、Array-prototype-push"><a href="#2、Array-prototype-push" class="headerlink" title="2、Array.prototype.push()"></a>2、Array.prototype.push()</h3><p>push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。</p>
<p><strong>添加元素：</strong>可以添加新的元素到数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 添加元素</div><div class="line">var letter = [&quot;a&quot;, &quot;b&quot;];</div><div class="line">var total = letter.push(&quot;c&quot;,&quot;d&quot;);</div><div class="line">console.log(total); // 4</div><div class="line">console.log(letter); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</div></pre></td></tr></table></figure>
<p><strong>合并数组</strong>：可以使用 apply() 添加第二个数组的所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 合并数组</div><div class="line">var arr1 = [1, 2];</div><div class="line">var arr2 = [&quot;a&quot;, &quot;b&quot;];</div><div class="line"></div><div class="line">// 将第二个数组融合进第一个数组</div><div class="line">// 相当于 arr1.push(&apos;a&apos;, &apos;b&apos;);</div><div class="line">Array.prototype.push.apply(arr1, arr2);</div><div class="line"></div><div class="line">console.log(arr1); // [1, 2, &quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure>
<h3 id="3、Array-prototype-pop"><a href="#3、Array-prototype-pop" class="headerlink" title="3、Array.prototype.pop()"></a>3、Array.prototype.pop()</h3><p>pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<p>如果你在一个空数组上调用 pop()，它返回  undefined。</p>
<h3 id="4、Array-prototype-unshift"><a href="#4、Array-prototype-unshift" class="headerlink" title="4、Array.prototype.unshift()"></a>4、Array.prototype.unshift()</h3><p>unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2];</div><div class="line"></div><div class="line">arr.unshift(0);</div><div class="line">//arr is [0, 1, 2]</div><div class="line"></div><div class="line">arr.unshift(-2, -1); // = 5</div><div class="line">//arr is [-2, -1, 0, 1, 2]</div><div class="line"></div><div class="line">arr.unshift( [-3] );</div><div class="line">//arr is [[-3], -2, -1, 0, 1, 2]</div></pre></td></tr></table></figure>
<h3 id="5、Array-prototype-shift"><a href="#5、Array-prototype-shift" class="headerlink" title="5、Array.prototype.shift()"></a>5、Array.prototype.shift()</h3><p>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;surgeon&apos;];</div><div class="line"></div><div class="line">console.log(&apos;调用 shift 之前: &apos; + myFish);</div><div class="line">// &quot;调用 shift 之前: angel,clown,mandarin,surgeon&quot;</div><div class="line"></div><div class="line">var shifted = myFish.shift();</div><div class="line"></div><div class="line">console.log(&apos;调用 shift 之后: &apos; + myFish);</div><div class="line">// &quot;调用 shift 之后: clown,mandarin,surgeon&quot;</div><div class="line"></div><div class="line">console.log(&apos;被删除的元素: &apos; + shifted);</div><div class="line">// &quot;被删除的元素: angel&quot;</div></pre></td></tr></table></figure>
<h3 id="6、Array-prototype-sort"><a href="#6、Array-prototype-sort" class="headerlink" title="6、Array.prototype.sort()"></a>6、Array.prototype.sort()</h3><p>sort(compareFunction) 方法在适当的位置对数组的元素进行排序，并返回数组。</p>
<p>sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。</p>
<p>一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数:</p>
<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</li>
<li>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [4, 2, 5, 1, 3];</div><div class="line">numbers.sort(function(a, b) &#123;</div><div class="line">  return a - b;</div><div class="line">&#125;);</div><div class="line">console.log(numbers); // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h3 id="7、Array-prototype-reverse"><a href="#7、Array-prototype-reverse" class="headerlink" title="7、Array.prototype.reverse()"></a>7、Array.prototype.reverse()</h3><p>reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。</p>
<p>下例将会创建一个数组 myArray，其包含三个元素，然后颠倒该数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">myArray.reverse();</div><div class="line">console.log(myArray);  // [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</div></pre></td></tr></table></figure>
<h3 id="8、Array-prototype-concat"><a href="#8、Array-prototype-concat" class="headerlink" title="8、Array.prototype.concat()"></a>8、Array.prototype.concat()</h3><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</div><div class="line">var arr2 = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</div><div class="line"></div><div class="line">var arr3 = arr1.concat(arr2);</div><div class="line"></div><div class="line">console.log(arr3);</div><div class="line">// 返回结果是一个新数组</div><div class="line">// [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</div><div class="line"></div><div class="line">// 原数组没有改变</div><div class="line">console.log(arr1); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">console.log(arr2); // [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</div></pre></td></tr></table></figure>
<h3 id="9、Array-prototype-slice"><a href="#9、Array-prototype-slice" class="headerlink" title="9、Array.prototype.slice()"></a>9、Array.prototype.slice()</h3><p><code>slice(start, end)</code> 方法将数组的一部分浅拷贝, 返回到从开始到结束（不包括结束）选择的新数组对象。原始数组不会被修改。</p>
<ul>
<li>slice()</li>
<li>slice(start)</li>
<li>slice(start,end)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;];</div><div class="line"></div><div class="line">//如果不传参数，表示从数组0开始到到end（包含end）</div><div class="line">var newArr1 = arr.slice();</div><div class="line">console.log(newArr1)  // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div><div class="line"></div><div class="line">//如果省略 end，则表示从start开始到end（包含end）</div><div class="line">var newArr2 = arr.slice(1);</div><div class="line">console.log(newArr2) // [&quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div><div class="line"></div><div class="line">//如果传人star、end，则表示从start到end不包含end</div><div class="line">var newArr3 = arr.slice(1, 3);</div><div class="line">console.log(newArr3) // [&quot;two&quot;, &quot;three&quot;]</div><div class="line"></div><div class="line">console.log(arr)    // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</div></pre></td></tr></table></figure>
<h3 id="10、Array-prototype-splice"><a href="#10、Array-prototype-splice" class="headerlink" title="10、Array.prototype.splice()"></a>10、Array.prototype.splice()</h3><p>splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。</p>
<p><strong>注意：splice 方法直接更改原数组内容</strong></p>
<ul>
<li>array.splice(start)</li>
<li>array.splice(start, deleteCount)</li>
<li>array.splice(start, deleteCount, item1, item2, …)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];</div><div class="line"></div><div class="line">//从第 2 位开始删除 0 个元素，插入 &quot;drum&quot;</div><div class="line">var removed = myFish.splice(2, 0, &quot;drum&quot;);</div><div class="line">console.log(myFish);</div><div class="line">//运算后的 myFish:[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[]，没有元素被删除</div><div class="line"></div><div class="line">//从第 3 位开始删除 1 个元素</div><div class="line">removed = myFish.splice(3, 1);</div><div class="line">//运算后的myFish：[&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[&quot;mandarin&quot;]</div><div class="line"></div><div class="line">//从第 2 位开始删除 1 个元素，然后插入 &quot;trumpet&quot;</div><div class="line">removed = myFish.splice(2, 1, &quot;trumpet&quot;);</div><div class="line">//运算后的myFish: [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素数组：[&quot;drum&quot;]</div><div class="line"></div><div class="line">//从第 0 位开始删除 2 个元素，然后插入 &quot;parrot&quot;, &quot;anemone&quot; 和 &quot;blue&quot;</div><div class="line">removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;);</div><div class="line">//运算后的myFish：[&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]</div><div class="line">//被删除元素的数组：[&quot;angel&quot;, &quot;clown&quot;]</div><div class="line"></div><div class="line">//从第 3 位开始删除 2 个元素</div><div class="line">removed = myFish.splice(3, Number.MAX_VALUE);</div><div class="line">//运算后的myFish: [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;]</div><div class="line">//被删除元素的数组：[&quot;trumpet&quot;, &quot;surgeon&quot;]</div></pre></td></tr></table></figure>
<hr>
<h2 id="ECM5方法"><a href="#ECM5方法" class="headerlink" title="ECM5方法"></a>ECM5方法</h2><h3 id="1、Array-prototype-indexOf"><a href="#1、Array-prototype-indexOf" class="headerlink" title="1、Array.prototype.indexOf()"></a>1、Array.prototype.indexOf()</h3><p>indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [2, 6, 9, 6];</div><div class="line"></div><div class="line">a.indexOf(2); // 0</div><div class="line">a.indexOf(7); // -1 不存在</div><div class="line">a.indexOf(6); // 1 返回指定元素的第一个索引值</div></pre></td></tr></table></figure>
<p><strong>找出指定元素出现的所有位置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 找出 a 在 array 里的所有位置</div><div class="line">var str = &apos;a&apos;;</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;a&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line"></div><div class="line">var indices = [];</div><div class="line">var idx = array.indexOf(str);</div><div class="line"></div><div class="line">while (idx != -1) &#123;</div><div class="line">  indices.push(idx);</div><div class="line">  idx = array.indexOf(str, idx + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(indices);</div><div class="line">// [0, 2, 4]</div></pre></td></tr></table></figure>
<h3 id="2、Array-prototype-lastIndexOf"><a href="#2、Array-prototype-lastIndexOf" class="headerlink" title="2、Array.prototype.lastIndexOf()"></a>2、Array.prototype.lastIndexOf()</h3><p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</div></pre></td></tr></table></figure>
<p><strong>定位数组中的值：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9, 2];</div><div class="line">var index = array.lastIndexOf(2);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(7);</div><div class="line">// index is -1</div><div class="line">index = array.lastIndexOf(2, 3);</div><div class="line">// index is 3</div><div class="line">index = array.lastIndexOf(2, 2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -2);</div><div class="line">// index is 0</div><div class="line">index = array.lastIndexOf(2, -1);</div><div class="line">// index is 3</div></pre></td></tr></table></figure>
<p><strong>查找所有元素</strong></p>
<p>下例使用 lastIndexOf 查找到一个元素在数组中所有的索引（下标），并使用 push 将所有添加到另一个数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var element = &apos;a&apos;;</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;a&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line">var indices = [];</div><div class="line">var idx = array.lastIndexOf(element);</div><div class="line"></div><div class="line">while (idx != -1) &#123;</div><div class="line">  indices.push(idx);</div><div class="line">  idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(indices);</div><div class="line">// [4, 2, 0];</div></pre></td></tr></table></figure>
<h3 id="3、Array-prototype-every"><a href="#3、Array-prototype-every" class="headerlink" title="3、Array.prototype.every()"></a>3、Array.prototype.every()</h3><p>every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>
<p>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</p>
<p>如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。</p>
<p>every 不会改变原数组。</p>
<p>every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。</p>
<p><strong>检测所有数组元素的大小</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [12, 5, 8, 130, 44].every(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 54, 18, 130, 44].every(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
<h3 id="4、Array-prototype-some"><a href="#4、Array-prototype-some" class="headerlink" title="4、Array.prototype.some()"></a>4、Array.prototype.some()</h3><p>some() 方法测试数组中的某些元素是否通过了指定函数的测试。</p>
<p>some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p>callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.some(callback[, thisArg])</div></pre></td></tr></table></figure>
<p>如果为 some 提供了一个 thisArg 参数，将会把它传给被调用的 callback，作为 this 值。否则，在非严格模式下将会是全局对象，严格模式下是 undefined。</p>
<p>some 被调用时不会改变数组。</p>
<p><strong>测试数组元素的值</strong></p>
<p>下面的例子检测在数组中是否有元素大于 10。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(element, index, array) &#123;</div><div class="line">  return (element &gt;= 10);</div><div class="line">&#125;</div><div class="line">var passed = [2, 5, 8, 1, 4].some(isBigEnough);</div><div class="line">// passed is false</div><div class="line">passed = [12, 5, 8, 1, 4].some(isBigEnough);</div><div class="line">// passed is true</div></pre></td></tr></table></figure>
<h3 id="5、Array-prototype-filter"><a href="#5、Array-prototype-filter" class="headerlink" title="5、Array.prototype.filter()"></a>5、Array.prototype.filter()</h3><p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<p>对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var new_array = arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>
<p><strong>筛选排除掉所有的小值</strong></p>
<p>下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function isBigEnough(value) &#123;</div><div class="line">  return value &gt;= 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);</div><div class="line">// filtered is [12, 130, 44]</div></pre></td></tr></table></figure>
<h3 id="6、Array-prototype-map"><a href="#6、Array-prototype-map" class="headerlink" title="6、Array.prototype.map()"></a>6、Array.prototype.map()</h3><p>map() 方法创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数，<strong>返回这个新数组</strong>。</p>
<p><strong>求数组中每个元素的平方根</strong></p>
<p>下面的代码创建了一个新数组，值为原数组中对应数字的平方根。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var numbers = [1, 4, 9];</div><div class="line">var roots = numbers.map(Math.sqrt);</div><div class="line">/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */</div></pre></td></tr></table></figure>
<p><strong>问答题</strong></p>
<p>问题：<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt)</code> 答案是多少？</p>
<p>答案是<code>[1,NaN,NaN]</code></p>
<h3 id="7、Array-prototype-forEach"><a href="#7、Array-prototype-forEach" class="headerlink" title="7、Array.prototype.forEach()"></a>7、Array.prototype.forEach()</h3><p>forEach() 方法对数组的每个元素执行一次提供的函数。</p>
<p>对数组中的每一项运行给定函数，这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, this)</div></pre></td></tr></table></figure>
<ul>
<li>currentValue(当前值) 数组中正在处理的当前元素。</li>
<li>index(索引) 数组中正在处理的当前元素的索引。</li>
<li>array forEach()方法正在操作的数组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr=[2, 4, 5];</div><div class="line">arr.forEach(function(elm,index, array) &#123;</div><div class="line">   console.log(index, elm);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 0 2</div><div class="line">// 1 4</div><div class="line">// 2 5</div></pre></td></tr></table></figure>
<h3 id="8、Array-prototype-reduce"><a href="#8、Array-prototype-reduce" class="headerlink" title="8、Array.prototype.reduce()"></a>8、Array.prototype.reduce()</h3><p>reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<p><strong>将数组所有项相加</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var sum = [0, 1, 2, 3].reduce(function(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;, 0);</div><div class="line">// sum is 6</div></pre></td></tr></table></figure>
<p><strong>数组扁平化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</div><div class="line">    return a.concat(b);</div><div class="line">&#125;, []);</div><div class="line">// flattened is [0, 1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h3 id="9、Array-prototype-reduceRight"><a href="#9、Array-prototype-reduceRight" class="headerlink" title="9、Array.prototype.reduceRight()"></a>9、Array.prototype.reduceRight()</h3><p>reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(function(a, b) &#123;</div><div class="line">    return a.concat(b);</div><div class="line">&#125;, []);</div><div class="line"></div><div class="line">// flattened is [4, 5, 2, 3, 0, 1]</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>本文主要内容引用：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN 的 JavaScript 标准库 Array 部分</a></li>
<li><a href="http://www.w3cplus.com/" target="_blank" rel="external">W3cplus 博客</a></li>
</ul>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-array-base.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。&lt;/p&gt;
&lt;h2 id=&quot;数组属性&quot;&gt;&lt;a href=&quot;#数组属性&quot; class=&quot;headerlink&quot; title=&quot;数组属性&quot;&gt;&lt;/a&gt;数组属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;constructor 表示引用数组对象的构造函数&lt;/li&gt;
&lt;li&gt;length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。&lt;/li&gt;
&lt;li&gt;prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&quot;一、创建方法&quot;&gt;&lt;a href=&quot;#一、创建方法&quot; class=&quot;headerlink&quot; title=&quot;一、创建方法&quot;&gt;&lt;/a&gt;一、创建方法&lt;/h3&gt;&lt;h4 id=&quot;创建一个空数组&quot;&gt;&lt;a href=&quot;#创建一个空数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个空数组&quot;&gt;&lt;/a&gt;创建一个空数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(); // 创建一个空数组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;`&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;创建一个指定长度的数组&quot;&gt;&lt;a href=&quot;#创建一个指定长度的数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个指定长度的数组&quot;&gt;&lt;/a&gt;创建一个指定长度的数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(size) // size 表示数组的长度&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;创建一个指定元素的数组&quot;&gt;&lt;a href=&quot;#创建一个指定元素的数组&quot; class=&quot;headerlink&quot; title=&quot;创建一个指定元素的数组&quot;&gt;&lt;/a&gt;创建一个指定元素的数组&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="array" scheme="http://www.imeetyou.net/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 面向对象编程详解</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/js-oop.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/js-oop.html</id>
    <published>2017-03-18T10:25:34.000Z</published>
    <updated>2017-03-23T01:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript是一种基于对象的语言，秉承一切皆对象的理念。</p>
<p>但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态</p>
<p>那么如何用 Javascript 来实现面向对象编程呢</p>
<h1 id="1、利用Prototype模式实现封装"><a href="#1、利用Prototype模式实现封装" class="headerlink" title="1、利用Prototype模式实现封装"></a>1、利用Prototype模式实现封装</h1><p>在Javascript里每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这样，我们把那些不变的属性和方法，直接定义在<code>prototype</code>对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.legs = 2</div><div class="line">Person.prototype.speak = function() &#123;</div><div class="line">	console.log(&quot;我的名字是：&quot; + this.name + &quot;，年龄：&quot; + this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，生成实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var jack = new Person(&quot;jack&quot;, 26);</div><div class="line">var lily = new Person(&quot;lily&quot;, 25);</div><div class="line"></div><div class="line">jack.legs; // 2</div><div class="line">lily.speak() // 我的名字是：lily，年龄：25</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2、实现构造函数继承的五种方法"><a href="#2、实现构造函数继承的五种方法" class="headerlink" title="2、实现构造函数继承的五种方法"></a>2、实现构造函数继承的五种方法</h1><p>举例，有一个水果的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有个“苹果”的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>怎么使得 <code>Apple</code> 继承 <code>Fruit</code> 呢？</p>
<h2 id="第一种，使用call-apply，构造函数绑定"><a href="#第一种，使用call-apply，构造函数绑定" class="headerlink" title="第一种，使用call/apply，构造函数绑定"></a>第一种，使用call/apply，构造函数绑定</h2><p>如题，使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name,color) &#123;</div><div class="line">	Fruit.apply(this, arguments); // 这里用call也可以</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new Apple(&quot;苹果&quot;, &quot;红色&quot;);</div><div class="line">console.log(a.type) // 水果</div></pre></td></tr></table></figure>
<h2 id="第二种，-使用prototype属性继承"><a href="#第二种，-使用prototype属性继承" class="headerlink" title="第二种， 使用prototype属性继承"></a>第二种， 使用prototype属性继承</h2><p>第二种方法比较常见，使用prototype属性。</p>
<p>如果水果的prototype对象，指向一个Fruit的实例，那么所有”水果”的实例，就能继承Fruit了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;</div><div class="line">  this.type = &quot;水果&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将 Apple 的 prototype 对象指向 Fruit实例</div><div class="line">Apple.prototype = new Fruit();</div><div class="line">// 将 Apple 的 prototype 对象的构造函数指回原来的构造函数</div><div class="line">Apple.prototype.constructor = Apple;</div><div class="line"></div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<h2 id="第三种-直接继承prototype"><a href="#第三种-直接继承prototype" class="headerlink" title="第三种 直接继承prototype"></a>第三种 直接继承prototype</h2><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Apple()跳过 Fruit()，直接继承Fruit.prototype。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Apple.prototype = Fruit.prototype;</div><div class="line">Apple.prototype.constructor = Apple; //</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Fruit的实例了），比较省内存。缺点是 <code>Apple.prototype</code>和<code>Fruit.prototype</code>现在指向了同一个对象，那么任何对<code>Apple.prototype</code>的修改，都会反映到<code>Fruit.prototype</code>。</p>
<p>所以，上面这一段代码其实是有问题的。请看第二行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Apple.prototype.constructor = Apple;</div></pre></td></tr></table></figure>
<p>这一句实际上把 <code>Fruit.prototype</code> 对象的 <code>constructor</code> 属性也改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Fruit.prototype.constructor); // Apple</div></pre></td></tr></table></figure>
<h2 id="第四种，-利用空对象作为中介"><a href="#第四种，-利用空对象作为中介" class="headerlink" title="第四种， 利用空对象作为中介"></a>第四种， 利用空对象作为中介</h2><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Fruit() &#123;&#125;</div><div class="line">Fruit.prototype.type = &quot;水果&quot;;</div><div class="line"></div><div class="line">function Apple(name, color) &#123;</div><div class="line">	this.name = name;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var F = function()&#123;&#125;;</div><div class="line">F.prototype = Fruit.prototype;</div><div class="line">Apple.prototype = new F();</div><div class="line">Apple.prototype.constructor = Apple;</div><div class="line"></div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<p>##第五种， 拷贝继承</p>
<p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p>
<p>写一个函数，实现属性拷贝的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extend2(Child, Parent) &#123;</div><div class="line">　　var p = Parent.prototype;</div><div class="line">　　var c = Child.prototype;</div><div class="line">　  for (var i in p) &#123;</div><div class="line">　　　　	c[i] = p[i];</div><div class="line">　　&#125;</div><div class="line">　　c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父对象的 prototype 对象中的属性，一一拷贝给 Child 对象的 prototype 对象。</p>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend2(Apple, Fruit);</div><div class="line">var a2 = new Apple(&quot;香蕉苹果&quot;, &quot;黄色&quot;);</div><div class="line">console.log(a2.type) // 水果</div></pre></td></tr></table></figure>
<h1 id="3、不使用构造函数实现”继承”的方法"><a href="#3、不使用构造函数实现”继承”的方法" class="headerlink" title="3、不使用构造函数实现”继承”的方法"></a>3、不使用构造函数实现”继承”的方法</h1><p><strong>什么是”非构造函数”的继承？</strong></p>
<p>比如，现在有一个对象，叫做”中国人”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>还有一个对象，叫做”医生”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor =&#123;</div><div class="line">　　career:&apos;医生&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<h3 id="第一种-object-方法"><a href="#第一种-object-方法" class="headerlink" title="第一种 object()方法"></a>第一种 object()方法</h3><p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">　　function F() &#123;&#125;</div><div class="line">　　F.prototype = o;</div><div class="line">　　return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = object(Chinese);</div></pre></td></tr></table></figure>
<p>然后，再加上子对象本身的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.career = &apos;医生&apos;;</div></pre></td></tr></table></figure>
<p>这时，子对象已经继承了父对象的属性了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">　　　nation:&apos;中国&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Doctor =&#123;</div><div class="line">　　　career:&apos;医生&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function object(o) &#123;</div><div class="line">　　function F() &#123;&#125;</div><div class="line">　　F.prototype = o;</div><div class="line">　　return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Doctor = object(Chinese);</div><div class="line"></div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line"></div><div class="line">alert(Doctor.nation); //中国</div></pre></td></tr></table></figure>
<h3 id="第二种-浅拷贝"><a href="#第二种-浅拷贝" class="headerlink" title="第二种 浅拷贝"></a>第二种 浅拷贝</h3><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extendCopy(p) &#123;</div><div class="line">　　var c = &#123;&#125;;</div><div class="line">　　for (var i in p) &#123;</div><div class="line">　　　　c[i] = p[i];</div><div class="line">　　&#125;</div><div class="line">　　c.uber = p;</div><div class="line">　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div></pre></td></tr></table></figure>
<p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div></pre></td></tr></table></figure>
<p>然后，我们为Doctor的”出生地”添加一个城市</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>发生了什么事？Chinese的”出生地”也被改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门</div></pre></td></tr></table></figure>
<p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<h3 id="第三种-深拷贝"><a href="#第三种-深拷贝" class="headerlink" title="第三种 深拷贝"></a>第三种 深拷贝</h3><p>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p, c) &#123;</div><div class="line">　　　　var c = c || &#123;&#125;;</div><div class="line">　　　　for (var i in p) &#123;</div><div class="line">　　　　　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">　　　　　　　　deepCopy(p[i], c[i]);</div><div class="line">　　　　　　&#125; else &#123;</div><div class="line">　　　　　　　　　c[i] = p[i];</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = deepCopy(Chinese);</div></pre></td></tr></table></figure>
<p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>这时，父对象就不会受到影响了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港</div></pre></td></tr></table></figure>
<p>目前，jQuery库使用的就是这种继承方法。</p>
<hr>
<blockquote>
<p>以上文章内容，转载修改自<a href="http://www.ruanyifeng.com/blog/javascript/" target="_blank" rel="external">阮一峰的网络日志</a>，仅作学习总结，原文链接如下：</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">Javascript面向对象编程（三）：非构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">Javascript面向对象编程（二）：构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">Javascript 面向对象编程（一）：封装</a></p>
</blockquote>
<p>本文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-oop.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/js-oop.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript是一种基于对象的语言，秉承一切皆对象的理念。&lt;/p&gt;
&lt;p&gt;但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态&lt;/p&gt;
&lt;p&gt;那么如何用 Javascript 来实现面向对象编程呢&lt;/p&gt;
&lt;h1 id=&quot;1、利用Prototype模式实现封装&quot;&gt;&lt;a href=&quot;#1、利用Prototype模式实现封装&quot; class=&quot;headerlink&quot; title=&quot;1、利用Prototype模式实现封装&quot;&gt;&lt;/a&gt;1、利用Prototype模式实现封装&lt;/h1&gt;&lt;p&gt;在Javascript里每一个构造函数都有一个&lt;code&gt;prototype&lt;/code&gt;属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。&lt;/p&gt;
&lt;p&gt;这样，我们把那些不变的属性和方法，直接定义在&lt;code&gt;prototype&lt;/code&gt;对象上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function Person(name,age) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.age = age;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Person.prototype.legs = 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Person.prototype.speak = function() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(&amp;quot;我的名字是：&amp;quot; + this.name + &amp;quot;，年龄：&amp;quot; + this.age);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，生成实例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var jack = new Person(&amp;quot;jack&amp;quot;, 26);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var lily = new Person(&amp;quot;lily&amp;quot;, 25);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jack.legs; // 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lily.speak() // 我的名字是：lily，年龄：25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="js" scheme="http://www.imeetyou.net/tags/js/"/>
    
      <category term="oop" scheme="http://www.imeetyou.net/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>div嵌套水平垂直居中方法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/div-center-middle.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/div-center-middle.html</id>
    <published>2017-03-12T09:24:54.000Z</published>
    <updated>2017-03-22T07:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。<br>首先给需要实现水平垂直居中的两个div设置统一的样式，<a href="/demos/div-center-middle.html"><strong>查看demo</strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl &#123;</div><div class="line">	width: 100%;</div><div class="line">	height: 300px;</div><div class="line">	background: #ccc;</div><div class="line">	margin: 30px auto;</div><div class="line">	position: relative;</div><div class="line">	border: 1px solid #000;</div><div class="line">&#125;</div><div class="line">.box &#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 100px;</div><div class="line">	background: #333;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法一：父标签-table-cell-法"><a href="#方法一：父标签-table-cell-法" class="headerlink" title="方法一：父标签 table-cell 法"></a>方法一：父标签 table-cell 法</h2><p>看题目就知道是利用父标签的 <code>display: table-cell</code>,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。<br>那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性<code>vertical-align: middle;</code> 来使得内部元素垂直居中了，然后再给子标签 <code>margin:0 auto;</code> 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">.styl1 &#123;</div><div class="line">	width: 1000px;</div><div class="line">	display: table-cell;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl1 .box &#123;</div><div class="line">	margin: 0 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html代码只要用我们上面的样式即可，之后的class名只要修改 <code>styl1</code> 为对应的样式名即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* html */</div><div class="line">&lt;div class=&quot;styl styl1&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="方法二：常规-position-及子元素偏移方法"><a href="#方法二：常规-position-及子元素偏移方法" class="headerlink" title="方法二：常规 position 及子元素偏移方法"></a>方法二：常规 position 及子元素偏移方法</h2><p>父标签设置 <code>position:relative</code>,子标签设置 <code>position:absolute</code>,同时设置 <code>left:50%</code>,<code>top:50%</code>,这个时候子标签的左上角已经垂直水平居中，再设置<code>margin</code>的负值为子元素宽高的50%即可将中心点对齐。<br>此方法缺点，需要动态调整 margin 偏移量为子标签宽高度的一半这个值，无法自动匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl2 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	margin: -50px 0 0 -100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法三：CSS3新属性-transform-的-translate-方法"><a href="#方法三：CSS3新属性-transform-的-translate-方法" class="headerlink" title="方法三：CSS3新属性 transform 的 translate 方法"></a>方法三：CSS3新属性 transform 的 translate 方法</h2><p>首先 <code>transform</code> 是css3的新属性，该属性是让我们对元素进行旋转、缩放、<strong>移动</strong>或倾斜。那么再看属性值 <code>translate</code> 是定义2D转换，就是平面的x,y喽。知道这些，那么我们在 方法二的基础上将偏移量通过 <code>transform</code> 来设置即可。<br>此属性支持IE9以上属性，而且需要兼容不同浏览器写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.styl3 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	transform: translate(-50%, -50%);</div><div class="line">	-webkit-transform: translate(-50%, -50%);</div><div class="line">	-moz-transform: translate(-50%, -50%);</div><div class="line">	-ms-transform: translate(-50%, -50%)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法四：margin-auto-方法"><a href="#方法四：margin-auto-方法" class="headerlink" title="方法四：margin:auto 方法"></a>方法四：margin:auto 方法</h2><p>此方法依然是在方法二的基础上修改，将子元素的left、top、right、bottom都设置为0，然后再 <code>margin:auto</code>,即可实现子元素的水平垂直居中。<br>此方法好处是自适应父标签的宽高，也就是说，无论父标签宽高怎么变都水平垂直居中哦。<br>此方法支持IE8+以及其他浏览器。是不是很神奇，具体原因查看 <strong><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" target="_blank" rel="external">margin:auto实现绝对定位元素的水平垂直居中</a></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.styl4 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	margin: auto;</div><div class="line">	left: 0;</div><div class="line">	top: 0;</div><div class="line">	bottom: 0;</div><div class="line">	right: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法五：flex-布局方法"><a href="#方法五：flex-布局方法" class="headerlink" title="方法五：flex 布局方法"></a>方法五：flex 布局方法</h2><p>flex意为弹性布局，不同于盒模型布局，子元素实现垂直居中就比较容易了，具体教程可以参看 <strong><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰的flex布局教程</a></strong>，这里只说怎么实现。<br>在此我们只要将父标签设置为 <code>display: flex</code>,并进行相应的主轴 <code>justify-content: center</code> 和交叉轴上的 <code>align-items: center</code> 对齐方式就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl5 &#123;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">	display: -webkit-flex;</div><div class="line">	display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html结构同上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;styl styl5&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="方法六：伪元素-inline-block-vertical-align-方法"><a href="#方法六：伪元素-inline-block-vertical-align-方法" class="headerlink" title="方法六：伪元素 inline-block/vertical-align 方法"></a>方法六：伪元素 inline-block/vertical-align 方法</h2><p>这个方法主要利用父标签的 <code>::before</code> 伪元素的 <code>inline-block</code> <code>vertical-align</code>来实现，比较巧妙，但这个方法要求子元素的属性必须是 <code>display: inline-block</code>, 好处依然是父子元素都可以自适应宽高并保持水平垂直居中。css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl6 &#123;</div><div class="line">	text-align: center;</div><div class="line">&#125;</div><div class="line">.styl6:before &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	display: inline-block;</div><div class="line">	height: 100%;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl6 .box &#123;</div><div class="line">	display: inline-block;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好，至此总结了div内部元素水平垂直居中的方法。</p>
<hr>
<blockquote>
<p>本文主要内容引用：</p>
<ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-绝对定位-水平垂直居中/" target="_blank" rel="external">margin:auto 实现绝对定位元素的水平垂直居中</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰的flex布局教程</a></li>
</ul>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/div-center-middle.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/div-center-middle.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。&lt;br&gt;首先给需要实现水平垂直居中的两个div设置统一的样式，&lt;a href=&quot;/demos/div-center-middle.html&quot;&gt;&lt;strong&gt;查看demo&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.styl &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 100%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 300px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #ccc;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	margin: 30px auto;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	position: relative;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	border: 1px solid #000;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.box &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 200px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 100px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #333;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;方法一：父标签-table-cell-法&quot;&gt;&lt;a href=&quot;#方法一：父标签-table-cell-法&quot; class=&quot;headerlink&quot; title=&quot;方法一：父标签 table-cell 法&quot;&gt;&lt;/a&gt;方法一：父标签 table-cell 法&lt;/h2&gt;&lt;p&gt;看题目就知道是利用父标签的 &lt;code&gt;display: table-cell&lt;/code&gt;,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。&lt;br&gt;那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性&lt;code&gt;vertical-align: middle;&lt;/code&gt; 来使得内部元素垂直居中了，然后再给子标签 &lt;code&gt;margin:0 auto;&lt;/code&gt; 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="html" scheme="http://www.imeetyou.net/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局和双飞翼布局详解</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/div-the-holy-grail.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/div-the-holy-grail.html</id>
    <published>2017-03-06T04:35:54.000Z</published>
    <updated>2017-03-22T07:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。<br>首先给需要实现水平垂直居中的两个div设置统一的样式，<a href="/demos/the-holy-grail.html"><strong>查看demo</strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl &#123;</div><div class="line">	width: 100%;</div><div class="line">	height: 300px;</div><div class="line">	background: #ccc;</div><div class="line">	margin: 30px auto;</div><div class="line">	position: relative;</div><div class="line">	border: 1px solid #000;</div><div class="line">&#125;</div><div class="line">.box &#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 100px;</div><div class="line">	background: #333;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法一：父标签-table-cell-法"><a href="#方法一：父标签-table-cell-法" class="headerlink" title="方法一：父标签 table-cell 法"></a>方法一：父标签 table-cell 法</h2><p>看题目就知道是利用父标签的 <code>display: table-cell</code>,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。<br>那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性<code>vertical-align: middle;</code> 来使得内部元素垂直居中了，然后再给子标签 <code>margin:0 auto;</code> 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*css*/</div><div class="line">.styl1 &#123;</div><div class="line">	width: 1000px;</div><div class="line">	display: table-cell;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl1 .box &#123;</div><div class="line">	margin: 0 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html代码只要用我们上面的样式即可，之后的class名只要修改 <code>styl1</code> 为对应的样式名即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* html */</div><div class="line">&lt;div class=&quot;styl styl1&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="方法二：常规-position-及子元素偏移方法"><a href="#方法二：常规-position-及子元素偏移方法" class="headerlink" title="方法二：常规 position 及子元素偏移方法"></a>方法二：常规 position 及子元素偏移方法</h2><p>父标签设置 <code>position:relative</code>,子标签设置 <code>position:absolute</code>,同时设置 <code>left:50%</code>,<code>top:50%</code>,这个时候子标签的左上角已经垂直水平居中，再设置<code>margin</code>的负值为子元素宽高的50%即可将中心点对齐。<br>此方法缺点，需要动态调整 margin 偏移量为子标签宽高度的一半这个值，无法自动匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl2 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	margin: -50px 0 0 -100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法三：CSS3新属性-transform-的-translate-方法"><a href="#方法三：CSS3新属性-transform-的-translate-方法" class="headerlink" title="方法三：CSS3新属性 transform 的 translate 方法"></a>方法三：CSS3新属性 transform 的 translate 方法</h2><p>首先 <code>transform</code> 是css3的新属性，该属性是让我们对元素进行旋转、缩放、<strong>移动</strong>或倾斜。那么再看属性值 <code>translate</code> 是定义2D转换，就是平面的x,y喽。知道这些，那么我们在 方法二的基础上将偏移量通过 <code>transform</code> 来设置即可。<br>此属性支持IE9以上属性，而且需要兼容不同浏览器写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.styl3 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	transform: translate(-50%, -50%);</div><div class="line">	-webkit-transform: translate(-50%, -50%);</div><div class="line">	-moz-transform: translate(-50%, -50%);</div><div class="line">	-ms-transform: translate(-50%, -50%)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法四：margin-auto-方法"><a href="#方法四：margin-auto-方法" class="headerlink" title="方法四：margin:auto 方法"></a>方法四：margin:auto 方法</h2><p>此方法依然是在方法二的基础上修改，将子元素的left、top、right、bottom都设置为0，然后再 <code>margin:auto</code>,即可实现子元素的水平垂直居中。<br>此方法好处是自适应父标签的宽高，也就是说，无论父标签宽高怎么变都水平垂直居中哦。<br>此方法支持IE8+以及其他浏览器。是不是很神奇，具体原因查看 <strong><a href="http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" target="_blank" rel="external">margin:auto实现绝对定位元素的水平垂直居中</a></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.styl4 .box &#123;</div><div class="line">	position: absolute;</div><div class="line">	margin: auto;</div><div class="line">	left: 0;</div><div class="line">	top: 0;</div><div class="line">	bottom: 0;</div><div class="line">	right: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法五：flex-布局方法"><a href="#方法五：flex-布局方法" class="headerlink" title="方法五：flex 布局方法"></a>方法五：flex 布局方法</h2><p>flex意为弹性布局，不同于盒模型布局，子元素实现垂直居中就比较容易了，具体教程可以参看 <strong><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰的flex布局教程</a></strong>，这里只说怎么实现。<br>在此我们只要将父标签设置为 <code>display: flex</code>,并进行相应的主轴 <code>justify-content: center</code> 和交叉轴上的 <code>align-items: center</code> 对齐方式就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.styl5 &#123;</div><div class="line">	justify-content: center;</div><div class="line">	align-items: center;</div><div class="line">	display: -webkit-flex;</div><div class="line">	display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>html结构同上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;styl styl5&quot;&gt;</div><div class="line">	&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h2 id="方法六：伪元素-inline-block-vertical-align-方法"><a href="#方法六：伪元素-inline-block-vertical-align-方法" class="headerlink" title="方法六：伪元素 inline-block/vertical-align 方法"></a>方法六：伪元素 inline-block/vertical-align 方法</h2><p>这个方法主要利用父标签的 <code>::before</code> 伪元素的 <code>inline-block</code> <code>vertical-align</code>来实现，比较巧妙，但这个方法要求子元素的属性必须是 <code>display: inline-block</code>, 好处依然是父子元素都可以自适应宽高并保持水平垂直居中。css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.styl6 &#123;</div><div class="line">	text-align: center;</div><div class="line">&#125;</div><div class="line">.styl6:before &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	display: inline-block;</div><div class="line">	height: 100%;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div><div class="line">.styl6 .box &#123;</div><div class="line">	display: inline-block;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好，至此总结了div内部元素水平垂直居中的方法。</p>
<hr>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/the-holy-grail.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/the-holy-grail.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结当前知道的对div嵌套标签水平垂直居中方法，如果还有新的方法，请不吝赐教哦。好，下面开始列举代码咯。&lt;br&gt;首先给需要实现水平垂直居中的两个div设置统一的样式，&lt;a href=&quot;/demos/the-holy-grail.html&quot;&gt;&lt;strong&gt;查看demo&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;.styl &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 100%;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 300px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #ccc;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	margin: 30px auto;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	position: relative;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	border: 1px solid #000;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;.box &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	width: 200px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	height: 100px;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	background: #333;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;方法一：父标签-table-cell-法&quot;&gt;&lt;a href=&quot;#方法一：父标签-table-cell-法&quot; class=&quot;headerlink&quot; title=&quot;方法一：父标签 table-cell 法&quot;&gt;&lt;/a&gt;方法一：父标签 table-cell 法&lt;/h2&gt;&lt;p&gt;看题目就知道是利用父标签的 &lt;code&gt;display: table-cell&lt;/code&gt;,该属性指让标签元素以表格单元格的形式呈现，类似于td标签。目前IE8+以及其他现代浏览器都是支持此属性的。&lt;br&gt;那么既然父标签已经是类似表格单元了，那么就可以利用表格单元的属性&lt;code&gt;vertical-align: middle;&lt;/code&gt; 来使得内部元素垂直居中了，然后再给子标签 &lt;code&gt;margin:0 auto;&lt;/code&gt; 即可，需要说明的是，这里的父标签需要设置宽度，不能自适应宽度&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="html" scheme="http://www.imeetyou.net/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>CSS中margin边界叠加问题及解决方案</title>
    <link href="http://www.imeetyou.net/posts/frontend/2017/css-margin-margin.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2017/css-margin-margin.html</id>
    <published>2017-03-02T01:25:34.000Z</published>
    <updated>2017-03-22T08:13:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>边界叠加简介</strong></p>
<p>边界叠加是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。<br>简单地说，当两个垂直边界相遇时，它们将形成一个边界。<br>这个边界的高度等于两个发生叠加的边界的高度中的较大者。</p>
<h2 id="元素的顶边界与前面元素的底边界发生叠加-示例一"><a href="#元素的顶边界与前面元素的底边界发生叠加-示例一" class="headerlink" title="元素的顶边界与前面元素的底边界发生叠加 示例一"></a>元素的顶边界与前面元素的底边界发生叠加 <a href="/demos/margin-margin.html">示例一</a></h2><p>也就是说当一个元素出现在另一个元素上面时，第一个元素的底边界与第二个元素的顶边界发生叠加。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="子元素的顶边界与父元素的顶边界发生叠加-示例二"><a href="#子元素的顶边界与父元素的顶边界发生叠加-示例二" class="headerlink" title="子元素的顶边界与父元素的顶边界发生叠加 示例二"></a>子元素的顶边界与父元素的顶边界发生叠加 <a href="/demos/margin-margin.html">示例二</a></h2><p>当一个元素包含在另一个元素中时（假设没有填充或边框将边界分隔开），它们的顶和/或底边界也发生叠加,<br>如果给父元素设置边框border或padding，此叠加不会发生。</p>
<hr>
<h2 id="元素的顶边界与底边界发生叠加-示例三"><a href="#元素的顶边界与底边界发生叠加-示例三" class="headerlink" title="元素的顶边界与底边界发生叠加 示例三"></a>元素的顶边界与底边界发生叠加 <a href="/demos/margin-margin.html">示例三</a></h2><p>尽管初看上去有点儿奇怪，但是边界甚至可以与本身发生叠加。假设有一个空元素，它有边界，但是没有边框或高度及内间距。<br>在这种情况下，顶边界与底边界就碰到了一起，它们会发生叠加，如果这个边界碰到另一个元素的边界，它还会发生叠加</p>
<hr>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>边界叠加的大多数问题可以通过添加透明边框或1px的补白来修复。其它补充解决方案：</p>
<p>1.外层 <code>padding</code></p>
<p>2.透明边框 <code>border:1px solid transparent;</code></p>
<p>3.绝对定位 <code>postion:absolute;</code></p>
<p>4.外层DIV <code>overflow:hidden;</code></p>
<p>5.内层DIV　加 <code>float:left; display:inline;</code></p>
<hr>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/margin-margin.html" target="_blank" rel="external">http://zyj1022.github.io/posts/frontend/2017/margin-margin.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;边界叠加简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;边界叠加是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。&lt;br&gt;简单地说，当两个垂直边界相遇时，它们将形成一个边界。&lt;br&gt;这个边界的高度等于两个发生叠加的边界的高度中的较大者。&lt;/p&gt;
&lt;h2 id=&quot;元素的顶边界与前面元素的底边界发生叠加-示例一&quot;&gt;&lt;a href=&quot;#元素的顶边界与前面元素的底边界发生叠加-示例一&quot; class=&quot;headerlink&quot; title=&quot;元素的顶边界与前面元素的底边界发生叠加 示例一&quot;&gt;&lt;/a&gt;元素的顶边界与前面元素的底边界发生叠加 &lt;a href=&quot;/demos/margin-margin.html&quot;&gt;示例一&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;也就是说当一个元素出现在另一个元素上面时，第一个元素的底边界与第二个元素的顶边界发生叠加。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="css" scheme="http://www.imeetyou.net/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>如何自定义Atom主题</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/atom-custom-theme.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/atom-custom-theme.html</id>
    <published>2016-12-08T04:42:32.000Z</published>
    <updated>2016-12-08T06:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Atom有段时间，一直使用别人的主题，想着自己也制作一款主题，便再 <a href="https://atom.io/docs/v1.2.4/hacking-atom-creating-a-theme" target="_blank" rel="external">官网</a> 上研究一番：</p>
<p>aotm主题，分为两种，一种是界面主题，一种是语法主题，下面就一一试试。</p>
<h1 id="创建界面主题"><a href="#创建界面主题" class="headerlink" title="创建界面主题"></a>创建界面主题</h1><p>首先，去下载一个主题，一直使用的是这个 <a href="https://atom.io/themes/one-dark-ui" target="_blank" rel="external">one-dark-ui</a>,下载到本机，并修改文件及主题名称，我修改的 <code>codyer-theme-ui</code>,然后，执行链接命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.atom/packages</div><div class="line">apm link /Users/username/Desktop/codyer-theme-ui</div></pre></td></tr></table></figure>
<p>之后，打开设置，选择 themes，就可以看到了。</p>
<a id="more"></a>
<h2 id="即时重启"><a href="#即时重启" class="headerlink" title="即时重启"></a>即时重启</h2><p>在你修改你的主题之后，按下 <code>cmd-alt-ctrl-L</code> 来重启不是十分理想。在dev模式的Atom窗口下，Atom支持样式的即时更新。</p>
<p>要想开启dev模式的窗口：</p>
<p>通过选择 View &gt; Developer &gt; Open in Dev Mode 菜单，或者按下 <code>cmd-shift-o</code> 快捷键来直接在dev模式窗口中打开你的主题。<br>修改你的主题并保存它。你的修改应该会马上应用。<br>如果你想要在任何时候都重新加载全部的样式，你可以使用 <code>cmd-ctrl-shift-r</code> 快捷键。</p>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>Atom基于Chrome浏览器，并且支持Chrome开发者工具。你可以选择View &gt; Toggle Developer Tools菜单，或者使用cmd-alt-i快捷键来打开它。</p>
<p>开发者工具允许你查看各个元素，以及他们的CSS属性。</p>
<h2 id="Atom-样式指南"><a href="#Atom-样式指南" class="headerlink" title="Atom 样式指南"></a>Atom 样式指南</h2><p>如果你在创建一个界面主题，你可能想要一种方式来查看你的主题如何影响系统中的组件。样式指南是一个页面，里面渲染了所有Atom支持的组件。</p>
<p>打开命令面板（cmd-shift-P）寻找“styleguide”，或者使用cmd-ctrl-shift-g快捷键来打开样式指南。</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/atom-styleguide.png" alt="atom-styleguide"></p>
<p>这里列出了所有style，直观多了。通过这里，我知道了如果我想改变边栏选中时的颜色，只要修改background-color-selected 的颜色值就可以了。于是回到 ui-variables.less 中，找到这个变量，改成想要的颜色(#93ffeb)即可。重新加载主题就能看到效果了。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><ul>
<li>@text-color</li>
<li>@text-color-subtle</li>
<li>@text-color-highlight</li>
<li>@text-color-selected</li>
<li>@text-color-info - 蓝色</li>
<li>@text-color-success- 绿色</li>
<li>@text-color-warning - 橙色或者黄色</li>
<li>@text-color-error - 红色</li>
</ul>
<h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><ul>
<li>@background-color-info - 蓝色</li>
<li>@background-color-success - 绿色</li>
<li>@background-color-warning - 橙色或者黄色</li>
<li>@background-color-error - 红色</li>
<li>@background-color-highlight</li>
<li>@background-color-selected</li>
<li>@app-background-color - 所有编辑器组件下面的应用背景</li>
</ul>
<p>###组件颜色</p>
<ul>
<li>@base-background-color -</li>
<li>@base-border-color -</li>
<li>@pane-item-background-color -</li>
<li>@pane-item-border-color -</li>
<li>@input-background-color -</li>
<li>@input-border-color -</li>
<li>@tool-panel-background-color -</li>
<li>@tool-panel-border-color -</li>
<li>@inset-panel-background-color -</li>
<li>@inset-panel-border-color -</li>
<li>@panel-heading-background-color -</li>
<li>@panel-heading-border-color -</li>
<li>@overlay-background-color -</li>
<li>@overlay-border-color -</li>
<li>@button-background-color -</li>
<li>@button-background-color-hover -</li>
<li>@button-background-color-selected -</li>
<li>@button-border-color -</li>
<li>@tab-bar-background-color -</li>
<li>@tab-bar-border-color -</li>
<li>@tab-background-color -</li>
<li>@tab-background-color-active -</li>
<li>@tab-border-color -</li>
<li>@tree-view-background-color -</li>
<li>@tree-view-border-color -</li>
<li>@ui-site-color-1 -</li>
<li>@ui-site-color-2 -</li>
<li>@ui-site-color-3 -</li>
<li>@ui-site-color-4 -</li>
<li>@ui-site-color-5 -</li>
</ul>
<h3 id="组件尺寸"><a href="#组件尺寸" class="headerlink" title="组件尺寸"></a>组件尺寸</h3><ul>
<li>@disclosure-arrow-size -</li>
<li>@component-padding -</li>
<li>@component-icon-padding -</li>
<li>@component-icon-size -</li>
<li>@component-line-height -</li>
<li>@component-border-radius -</li>
<li>@tab-height -</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li>@font-size -</li>
<li>@font-family -</li>
</ul>
<h1 id="创建语法主题"><a href="#创建语法主题" class="headerlink" title="创建语法主题"></a>创建语法主题</h1><p>同时按 <code>cmd+shift+p</code>，输入 <code>generate syntax theme</code> 并回车，为主题命名，选择一个保存的位置就可以了。注意名字一定要以-syntax结尾。</p>
<p>保存好后，就可以在设置-Themes的Syntax主题列表中看到刚建好的主题了。选择它。Syntax部分比较简单，不需要手动建立链接，目录结构也少了许多。</p>
<p>目录结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">codyer-theme-Syntax/</div><div class="line">	  └── styles/</div><div class="line">	      ├── base.less </div><div class="line">	      ├── colors.less  </div><div class="line">	      └── syntax-variables.less</div></pre></td></tr></table></figure>
<p>在 <code>colors.less</code> 修改自己喜好的配色即可。</p>
<h2 id="发布语法主题"><a href="#发布语法主题" class="headerlink" title="发布语法主题"></a>发布语法主题</h2><ul>
<li>首先把制造好的主题上传至github。</li>
<li>进入主题目录 执行 <code>apm publish minor</code> 之后输入github的用户名及密码，会要求输入 atom token，然后上传成功，就可以在 atom编辑器里下载到你自己的主题了。</li>
</ul>
<h1 id="我的自定义主题"><a href="#我的自定义主题" class="headerlink" title="我的自定义主题"></a>我的自定义主题</h1><p>主题名称 <a href="https://atom.io/themes/codyer-theme-syntax" target="_blank" rel="external">codyer-theme-syntax</a></p>
<p><img src="http://og8z552x2.bkt.clouddn.com/atom-js-style.png" alt="codyer-theme-html"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Atom有段时间，一直使用别人的主题，想着自己也制作一款主题，便再 &lt;a href=&quot;https://atom.io/docs/v1.2.4/hacking-atom-creating-a-theme&quot;&gt;官网&lt;/a&gt; 上研究一番：&lt;/p&gt;
&lt;p&gt;aotm主题，分为两种，一种是界面主题，一种是语法主题，下面就一一试试。&lt;/p&gt;
&lt;h1 id=&quot;创建界面主题&quot;&gt;&lt;a href=&quot;#创建界面主题&quot; class=&quot;headerlink&quot; title=&quot;创建界面主题&quot;&gt;&lt;/a&gt;创建界面主题&lt;/h1&gt;&lt;p&gt;首先，去下载一个主题，一直使用的是这个 &lt;a href=&quot;https://atom.io/themes/one-dark-ui&quot;&gt;one-dark-ui&lt;/a&gt;,下载到本机，并修改文件及主题名称，我修改的 &lt;code&gt;codyer-theme-ui&lt;/code&gt;,然后，执行链接命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd ~/.atom/packages&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;apm link /Users/username/Desktop/codyer-theme-ui&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，打开设置，选择 themes，就可以看到了。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="atom" scheme="http://www.imeetyou.net/tags/atom/"/>
    
      <category term="theme" scheme="http://www.imeetyou.net/tags/theme/"/>
    
      <category term="syntax" scheme="http://www.imeetyou.net/tags/syntax/"/>
    
  </entry>
  
  <entry>
    <title>重装node导致Hexo不能正常使用解决办法</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/hexo-node-err.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/hexo-node-err.html</id>
    <published>2016-11-22T02:40:15.000Z</published>
    <updated>2016-11-22T02:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。最近重装了node，导致在编译博客的时候，会出现很多依赖的错误。比如：</p>
<p>在使用hexo过程中，使用node 6.0以上版本，会出现fs版本问题。</p>
<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ATAL Error: Module version mismatch. Expected 48, got 14.</div><div class="line">Template render error: Error: Module version mismatch. Expected 48, got 14.</div></pre></td></tr></table></figure>
<p>错误提示模块的版本不匹配，可能是因为重装了node，很多模块更新或者确实，所以我们重新安装配置下Hexo,解决方法：执行以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo --no-optional</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p>安装Hexo时，执行“npm install -g hexo-cli“出现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">npm ERR! tar.unpack untar error /Users/Macx/.npm/hexo-cli/0.1.8/package.tgz</div><div class="line">npm ERR! Darwin 14.4.0</div><div class="line">npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;hexo-cli&quot; &quot;-g&quot;</div><div class="line">npm ERR! node v4.2.1</div><div class="line">npm ERR! npm v2.14.7</div><div class="line">npm ERR! path /usr/local/lib/node_modules/hexo-cli</div><div class="line">npm ERR! code EACCES</div><div class="line">npm ERR! errno -13</div><div class="line">npm ERR! syscall mkdir</div><div class="line"></div><div class="line">npm ERR! Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo-cli&apos;</div><div class="line">npm ERR! at Error (native)</div><div class="line">npm ERR! &#123; [Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo-cli&apos;]</div><div class="line">npm ERR! errno: -13,</div><div class="line">npm ERR! code: &apos;EACCES&apos;,</div><div class="line">npm ERR! syscall: &apos;mkdir&apos;,</div><div class="line">npm ERR! path: &apos;/usr/local/lib/node_modules/hexo-cli&apos;,</div><div class="line">npm ERR! fstream_type: &apos;Directory&apos;,</div><div class="line">npm ERR! fstream_path: &apos;/usr/local/lib/node_modules/hexo-cli&apos;,</div><div class="line">npm ERR! fstream_class: &apos;DirWriter&apos;,</div><div class="line">npm ERR! fstream_stack: </div><div class="line">npm ERR! [ &apos;/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25&apos;,</div><div class="line">npm ERR! &apos;/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53&apos;,</div><div class="line">npm ERR! &apos;FSReqWrap.oncomplete (fs.js:82:15)&apos; ] &#125;</div><div class="line">npm ERR! </div><div class="line">npm ERR! Please try running this command again as root/Administrator.</div><div class="line"></div><div class="line">npm ERR! Please include the following file with any support request:</div><div class="line">npm ERR! /Users/Macx/Desktop/GitHub/npm-debug.log</div></pre></td></tr></table></figure>
<p>分析下错误，异常可能因为权限问题，所以我们执行一些安装命令是需要申请root执行权限。</p>
<p>解决方法：执行以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install --unsafe-perm --verbose -g hexo</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。最近重装了node，导致在编译博客的时候，会出现很多依赖的错误。比如：&lt;/p&gt;
&lt;p&gt;在使用hexo过程中，使用node 6.0以上版本，会出现fs版本问题。&lt;/p&gt;
&lt;h1 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一&quot;&gt;&lt;/a&gt;问题一&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ATAL Error: Module version mismatch. Expected 48, got 14.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Template render error: Error: Module version mismatch. Expected 48, got 14.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;错误提示模块的版本不匹配，可能是因为重装了node，很多模块更新或者确实，所以我们重新安装配置下Hexo,解决方法：执行以下代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install hexo --no-optional&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="hexo" scheme="http://www.imeetyou.net/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>前端速查表Flex-Bootstrap4-es6</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/Flex-Bootstrap4-es6.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/Flex-Bootstrap4-es6.html</id>
    <published>2016-11-17T00:53:24.000Z</published>
    <updated>2016-11-17T01:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flexbox-属性速查表"><a href="#Flexbox-属性速查表" class="headerlink" title="Flexbox 属性速查表"></a>Flexbox 属性速查表</h1><p>Flex属性用多了自然记住,基本概念不再赘述不过还是简单罗列一下：</p>
<h2 id="容器的属性有以下6个"><a href="#容器的属性有以下6个" class="headerlink" title="容器的属性有以下6个"></a>容器的属性有以下6个</h2><ul>
<li>flex-direction属性决定主轴的方向（即项目的排列方向）<br><code>flex-direction: row | row-reverse | column | column-reverse;</code><ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>  <code>flex-wrap: nowrap | wrap | wrap-reverse;</code></p>
<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
</li>
<li><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br>  <code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;</code></p>
</li>
<li><p>justify-content属性定义了项目在主轴上的对齐方式。<br>  <code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
</li>
<li><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<p>  <code>align-items: flex-start | flex-end | center | baseline | stretch;</code></p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</li>
<li><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>  <code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
</li>
</ul>
<h2 id="项目的属性6个"><a href="#项目的属性6个" class="headerlink" title="项目的属性6个"></a>项目的属性6个</h2><ul>
<li><code>order: &lt;integer&gt;;</code>  数值越小，排列越靠前，默认为0。</li>
<li><code>flex-grow: &lt;number&gt;;</code>  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</li>
<li><code>flex-shrink: &lt;number&gt;;</code>  定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</li>
<li><code>flex-basis: &lt;length&gt; | auto;</code>  定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小</li>
<li><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code> flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>
<li><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code> align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<p>属性不熟悉的可以查看阮氏教程 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p>下面还有问答形式的图示，方便快速查看</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/flexboxsheet.png" alt="flexboxsheet"></p>
<p>图片原文链接 <a href="http://jonibologna.com/flexbox-cheatsheet/" target="_blank" rel="external">http://jonibologna.com/flexbox-cheatsheet/</a></p>
<h1 id="Flexbox-视觉指南"><a href="#Flexbox-视觉指南" class="headerlink" title="Flexbox 视觉指南"></a><a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/" target="_blank" rel="external">Flexbox 视觉指南</a></h1><p>这个特色就是有实时代码演示，当用户设置属性，DEMO 可以实时更新效果，这样用户更好更容易地理解 Flexbox 某个属性的作用。</p>
<h1 id="Bootstrap-4-Cheat-Sheet"><a href="#Bootstrap-4-Cheat-Sheet" class="headerlink" title="Bootstrap 4 Cheat Sheet"></a><a href="https://hackerthemes.com/bootstrap-cheatsheet/" target="_blank" rel="external">Bootstrap 4 Cheat Sheet</a></h1><p>Bootstrap 4 有新的很多组件样式，熟记它不太可能，在官网找又太麻烦，那么这个Bootstrap 4是你最好的选择，流布布局分类，支持一件复制代码，超好用，小编正在用了。</p>
<h1 id="es6-cheatsheet"><a href="#es6-cheatsheet" class="headerlink" title="es6-cheatsheet"></a><a href="https://github.com/DrkSephy/es6-cheatsheet/blob/master/README_zhCn.md" target="_blank" rel="external">es6-cheatsheet</a></h1><p>这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你 完成日复一日的开发工作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Flexbox-属性速查表&quot;&gt;&lt;a href=&quot;#Flexbox-属性速查表&quot; class=&quot;headerlink&quot; title=&quot;Flexbox 属性速查表&quot;&gt;&lt;/a&gt;Flexbox 属性速查表&lt;/h1&gt;&lt;p&gt;Flex属性用多了自然记住,基本概念不再赘述不过还是简单罗列一下：&lt;/p&gt;
&lt;h2 id=&quot;容器的属性有以下6个&quot;&gt;&lt;a href=&quot;#容器的属性有以下6个&quot; class=&quot;headerlink&quot; title=&quot;容器的属性有以下6个&quot;&gt;&lt;/a&gt;容器的属性有以下6个&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;flex-direction属性决定主轴的方向（即项目的排列方向）&lt;br&gt;&lt;code&gt;flex-direction: row | row-reverse | column | column-reverse;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;row（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;row-reverse：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;column：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;column-reverse：主轴为垂直方向，起点在下沿。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="flex" scheme="http://www.imeetyou.net/tags/flex/"/>
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
  </entry>
  
  <entry>
    <title>如何在React Native中的使用自定义iconfont</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/react-native-iconfont.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/react-native-iconfont.html</id>
    <published>2016-11-15T08:46:11.000Z</published>
    <updated>2016-11-15T09:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native中的iconfont"><a href="#React-Native中的iconfont" class="headerlink" title="React Native中的iconfont"></a>React Native中的iconfont</h1><p>关于在React Native中使用iconfont，网上已有很多非常好的解决方案，用的最多的就是 <a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="external">react-native-vector-icons</a>, 这个库支持很多常用的iconfont,比如FontAwesome, Ionicons, MaterialIcons等等。</p>
<p>但是这个库依赖了不少iOS和Android的原生代码，这让一个前端开发脸上浮现了一个大大的懵逼。 而且自带的字体文件都偏大，做起精简来简直想哭，更别说加入自定义的iconfont了。</p>
<a id="more"></a>
<h1 id="如何生成自定义的iconfont文件"><a href="#如何生成自定义的iconfont文件" class="headerlink" title="如何生成自定义的iconfont文件"></a>如何生成自定义的iconfont文件</h1><p>这里我一般通过 <a href="https://icomoon.io/" target="_blank" rel="external">icomoon</a> 来实现,将设计好的图标字体一般为 <code>.svg</code> 文件,导入到icomoon 里，</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/icomoon.png" alt="icomoon"></p>
<p>选择我们需要的字体图标，然后 <code>Generate Font</code>, 之后 下载 demo 包 内含我们需要的 fonts 文件</p>
<h1 id="IconFont的使用原理"><a href="#IconFont的使用原理" class="headerlink" title="IconFont的使用原理"></a>IconFont的使用原理</h1><p>其实IconFont就是一些文字，通过在web上的使用，我们可以大概猜出使用方法：</p>
<ul>
<li>1.指定字体集</li>
<li>2.把对应的16进制码当成文字写到文本中</li>
</ul>
<p>在React Native中同样如此，我们可以通过 <a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="external">react-native-vector-icons</a> 的源代码来验证我们的想法。</p>
<p>打开 <code>react-native-vector-icons/FontAweson.js</code> 文件(<a href="https://github.com/oblador/react-native-vector-icons/blob/master/FontAwesome.js" target="_blank" rel="external">线上地址</a>)可以看到一个大大的json对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var createIconSet = require(&apos;./lib/create-icon-set&apos;);</div><div class="line">var glyphMap = &#123;</div><div class="line">  &quot;glass&quot;: 61440,</div><div class="line">  &quot;music&quot;: 61441,</div><div class="line">  &quot;search&quot;: 61442,</div><div class="line">  .</div><div class="line">  . // 此处省略500+行</div><div class="line">  .</div><div class="line">&#125;;</div><div class="line">var FontAwesome = createIconSet(glyphMap, &apos;FontAwesome&apos;, &apos;FontAwesome.ttf&apos;);</div><div class="line">module.exports = FontAwesome;</div><div class="line">module.exports.glyphMap = glyphMap;</div></pre></td></tr></table></figure>
<p>看到这些亲切的数字了吗，61440，这不就是传说中的16进制的FXXX的十进制吗？</p>
<p>16进制有了，写到哪里呢，继续看createIconSet方法。</p>
<p>其中的Icon组件的render方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">render: function() &#123;</div><div class="line">  var &#123; name, size, color, style, ...props &#125; = this.props;</div><div class="line">  var glyph = glyphMap[name] || &apos;?&apos;;</div><div class="line">  if(typeof glyph === &apos;number&apos;) &#123;</div><div class="line">    glyph = String.fromCharCode(glyph);</div><div class="line">  &#125;</div><div class="line">  size = size || DEFAULT_ICON_SIZE;</div><div class="line">  var styleDefaults:Object = &#123;</div><div class="line">    fontSize: size,</div><div class="line">    fontWeight: &apos;normal&apos;,</div><div class="line">    fontStyle: &apos;normal&apos;,</div><div class="line">    color,</div><div class="line">  &#125;;</div><div class="line">  props.style = [styleDefaults, style];</div><div class="line">  props.ref = (component) =&gt; this._root = component;</div><div class="line">  styleDefaults.fontFamily = fontReference;</div><div class="line">  console.log(this.props.children)</div><div class="line">  return (&lt;Text &#123;...props&#125;&gt;&#123;glyph&#125;&#123;this.props.children&#125;&lt;/Text&gt;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，最重要的四句话<em>(我本来写的是两句话，结果越看越多)</em>：</p>
<p><code>var glyph = glyphMap[name] || &#39;?&#39;;</code> 把刚才的<code>6xxxx</code>找到；</p>
<p><code>glyph = String.fromCharCode(glyph);</code>转成Unicode编码字符串；</p>
<p><code>styleDefaults.fontFamily = fontReference;</code>指定字符集；</p>
<p><code>return (&lt;Text {...props}&gt;{glyph}{this.props.children}&lt;/Text&gt;);</code> 把Unicode字符写到<code>Text</code>组件中。</p>
<p>基本和我们的猜想一样，哇哈哈哈。</p>
<h1 id="Font的基本知识"><a href="#Font的基本知识" class="headerlink" title="Font的基本知识"></a>Font的基本知识</h1><p>由上可知，我们主要需要这个Icon所对应的Unicode码，那这个Unicode码又是神马呢？</p>
<p>实际上，一个字体通常由数个表(table)构成，字体的信息存储在表中。一个最基本的字体文件一定会包含以下表：</p>
<ul>
<li>cmap: Char­ac­ter to glyph map­ping</li>
<li>head: Font header</li>
<li>hhea: Hor­i­zon­tal header</li>
<li>hmtx: Hor­i­zon­tal met­rics</li>
<li>maxp: Max­i­mum pro­file</li>
<li>name: Nam­ing table</li>
<li>OS/​2: OS/​2 and Win­dows spe­cific met­rics</li>
<li>post: Post­Script in­for­ma­tion</li>
</ul>
<p>而使用TrueType曲线绘制的字体则会包含如下表：</p>
<ul>
<li>cvt: Con­trol Value Table</li>
<li>fpgm: Font pro­gram</li>
<li>glyf: Glyph data</li>
<li>loca: In­dex to lo­ca­tion</li>
<li>prep: CVT Pro­gram</li>
<li>gasp: Grid​-​fit­ting/​Scan​-​con­ver­sion (op­tional table)</li>
</ul>
<p>上面列了很多，最重要的其实是第一个表看这高大上的说明Char­ac­ter to glyph map­ping。</p>
<p>如果把字体文件转成类xml格式，这个表类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;cmap&gt; </div><div class="line">    &lt;cmap_format_4 platformID=&quot;3&quot; platEncID=&quot;1&quot; language=&quot;0&quot;&gt;</div><div class="line">          &lt;map code=&quot;0xf600&quot; name=&quot;uniF600&quot;/&gt;</div><div class="line">          &lt;map code=&quot;0xf601&quot; name=&quot;uniF601&quot;/&gt;</div><div class="line">          &lt;map code=&quot;0xf602&quot; name=&quot;uniF602&quot;/&gt;</div><div class="line">          &lt;map code=&quot;0xf603&quot; name=&quot;uniF603&quot;/&gt;</div><div class="line">    &lt;/cmap_format_4&gt;</div><div class="line">&lt;/cmap&gt;</div></pre></td></tr></table></figure>
<p>这里的0xf600不就是我们想要的吗，而后面的name就类似与每个字符的命名。</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/font-baidu.png" alt="font-baidu"></p>
<p>这里最好给每个icon定一个易于理解的名字，可以使用 <a href="http://font.baidu.com/editor" target="_blank" rel="external">http://font.baidu.com/editor</a></p>
<h1 id="如何使用自定义的IconFont"><a href="#如何使用自定义的IconFont" class="headerlink" title="如何使用自定义的IconFont"></a>如何使用自定义的IconFont</h1><p>有了上面的摸索，要支持自己的IconFont并不难。只需要把字符对应表给整出来就可以了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var map = &#123;&quot;arrow&quot;:&quot;62976&quot;,&quot;checked&quot;:&quot;62977&quot;,&quot;checked-s&quot;:&quot;62978&quot;,&quot;tag-svip&quot;:&quot;62995&quot;&#125;;</div><div class="line">module.exports = (name)=&gt;String.fromCharCode(map[name]);</div></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import icon from &quot;./fontConf&quot;;</div><div class="line">export default class  IconExample extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">                &lt;Text style=&#123;&#123;fontFamily: &apos;FontIconQui&apos;,fontSize:30&#125;&#125;&gt;</div><div class="line">                    arrow-icon:&#123;icon(&apos;arrow&apos;)&#125;</div><div class="line">                &lt;/Text&gt;</div><div class="line">                &lt;Text style=&#123;&#123;fontFamily: &apos;FontIconQui&apos;,fontSize:30, color:&quot;#ff4444&quot;&#125;&#125;&gt;</div><div class="line">                    vip-icon:&#123;icon(&apos;tag-svip&apos;)&#125;</div><div class="line">                &lt;/Text&gt;</div><div class="line">                &lt;Text style=&#123;&#123;fontFamily: &apos;FontIconQui&apos;,fontSize:30, color:&quot;#ff4444&quot;&#125;&#125;&gt;</div><div class="line">                    tag-svip:&#123;icon(&apos;tag-svip&apos;)&#125;</div><div class="line">                &lt;/Text&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在工程中，需要引入字体文件：</p>
<ul>
<li>Android： 把字体文件拷贝到<code>[project root]/android/app/src/main/assets/fonts/</code></li>
<li>iOS: 把字体文件拖到对应的Xcode工程里面，勾选 <code>Add to targets</code> 和 <code>Create groups</code>，修改<code>Info.plist</code> 文件，添加属性 <code>Fonts provided by application</code>，在这个属性下添加相应字体文件名的<code>item</code>，如下图：</li>
</ul>
<p><img src="http://og8z552x2.bkt.clouddn.com/xcode.png" alt="font-baidu"></p>
<p>iOS上添加字体文件具体的流程可以参考 <a href="https://github.com/oblador/react-native-vector-icons#option-manually" target="_blank" rel="external">https://github.com/oblador/react-native-vector-icons#option-manually</a>。 </p>
<h1 id="如何提取字符对应表"><a href="#如何提取字符对应表" class="headerlink" title="如何提取字符对应表"></a>如何提取字符对应表</h1><p>打开 <a href="http://font.baidu.com/editor/" target="_blank" rel="external">百度字体编辑器</a>,导入我们的之前的自定义字体文件</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/baidueditor.png" alt="font-baidu"></p>
<p>如下将上图中的 <code>E90C</code>、<code>E90D</code> 转换为十进制 <code>59660</code>、<code>59661</code> 就是我们想要的字符。</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/hexconvert.png" alt="hexconvert.png"></p>
<p>在线转换进制 <a href="http://tool.oschina.net/hexconvert/" target="_blank" rel="external">http://tool.oschina.net/hexconvert/</a></p>
<p>然后新建 <code>iconfont.js</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const map = &#123;</div><div class="line">    &quot;angle-left&quot;: &quot;59648&quot;,</div><div class="line">    &quot;angle-right&quot;: &quot;59649&quot;,</div><div class="line">    &quot;ok&quot;: &quot;59650&quot;,</div><div class="line">    &quot;alarm&quot;: &quot;59651&quot;,</div><div class="line">    &quot;edit&quot;: &quot;59652&quot;,</div><div class="line">    &quot;eye-close&quot;: &quot;59653&quot;,</div><div class="line">    &quot;eye-open&quot;: &quot;59654&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = (name) =&gt; String.fromCharCode(map[name]);</div><div class="line">module.exports.map = map;</div></pre></td></tr></table></figure>
<p>在 React-native 中使用的时候非常简单,首先导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import icon from &apos;iconfont&apos;;</div></pre></td></tr></table></figure>
<p>然后在需要使用的地方,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.icon&#125;&gt;&#123;icon(&apos;edit&apos;)&#125;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>看看是不是在界面中已经出现了你想要的图标，至于大小颜色，反正是字体嘛，用样式去控制咯～。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React-Native中的iconfont&quot;&gt;&lt;a href=&quot;#React-Native中的iconfont&quot; class=&quot;headerlink&quot; title=&quot;React Native中的iconfont&quot;&gt;&lt;/a&gt;React Native中的iconfont&lt;/h1&gt;&lt;p&gt;关于在React Native中使用iconfont，网上已有很多非常好的解决方案，用的最多的就是 &lt;a href=&quot;https://github.com/oblador/react-native-vector-icons&quot;&gt;react-native-vector-icons&lt;/a&gt;, 这个库支持很多常用的iconfont,比如FontAwesome, Ionicons, MaterialIcons等等。&lt;/p&gt;
&lt;p&gt;但是这个库依赖了不少iOS和Android的原生代码，这让一个前端开发脸上浮现了一个大大的懵逼。 而且自带的字体文件都偏大，做起精简来简直想哭，更别说加入自定义的iconfont了。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="react-native" scheme="http://www.imeetyou.net/tags/react-native/"/>
    
      <category term="iconfont" scheme="http://www.imeetyou.net/tags/iconfont/"/>
    
  </entry>
  
  <entry>
    <title>mac开机黑屏解决方法</title>
    <link href="http://www.imeetyou.net/posts/life/2016/mac-os-option.html"/>
    <id>http://www.imeetyou.net/posts/life/2016/mac-os-option.html</id>
    <published>2016-11-13T07:34:23.000Z</published>
    <updated>2016-11-14T01:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>真真是奔溃的不要不要的，mac重现安装了最新 Sierra 照样开机黑屏，毫无反应啊，<br>传说中的PARM大法也不好使了，无奈约了官网，下周六去检测。不过还是将折腾小记一番，<br>红烧清炖各种方法都试过了。</p>
<h1 id="mac开机黑屏解决方法"><a href="#mac开机黑屏解决方法" class="headerlink" title="mac开机黑屏解决方法"></a>mac开机黑屏解决方法</h1><p>通常来说开机速度慢或者开机黑屏</p>
<p>关闭电脑，开机，同时按住 <code>command+option+R+P</code> 这个时候就会听到‘当‘一声，继续按着<br>再听一次，（网上说有让听四次，我都试过了，一次、两次、三次、四次，其实无所谓，有一声足够），这个时候松开，就可以看到 苹果 下面是个进度条，不出意外的话，可以正常开机了。</p>
<p>PS：我的是出了意外的，具体症状就是，开机即使如上操作，进度条走到一多半，关机了～～～<br>这什么情况，没折，只好继续想办法。你说再重装系统啊，那就试试看</p>
<a id="more"></a>
<h1 id="开机option-command-r都没反应"><a href="#开机option-command-r都没反应" class="headerlink" title="开机option command+r都没反应"></a>开机option command+r都没反应</h1><p>如题，mac 就这尿性了，按啥都不好使了，</p>
<ul>
<li>开机按 option 出现不了让选择启动方式的界面</li>
<li>command+r 这个试过也没折</li>
</ul>
<p>哇呀呀～ 这是要拆八块的节奏吗。无奈继续想折，神奇的有个方法</p>
<ul>
<li>关机，开机，按住option+command+r+p</li>
<li>按住option+command+r+p键开机，开机后不要松开这4个键</li>
<li>mac mini会一直重启，当重启到第10次（这个次数我是试了10次，其实不用10次，两次就可以，我又试过了)的时候</li>
<li>松开P键也就是继续按住option+command+r这三个键，久违的小地球就出现了</li>
</ul>
<p>你以为这样就可以了吗？还不行～！！！我选择wifi，输入密码，想等待奇迹，可是真奇迹，<br>出现进度条走了一点点，就奔溃了。</p>
<h1 id="重载系统-出现apple-com-cn-support-2104f"><a href="#重载系统-出现apple-com-cn-support-2104f" class="headerlink" title="重载系统  出现apple.com.cn/support -2104f"></a>重载系统  出现apple.com.cn/support -2104f</h1><p>如题，又出故障了，真是折腾啊，还不行，如上各种操作试了不下三遍，无奈呼叫苹果客服吧。<br>下周六去天才吧。</p>
<h1 id="互联网资料整理"><a href="#互联网资料整理" class="headerlink" title="互联网资料整理"></a>互联网资料整理</h1><p>您可以按住COMMMAND+r进入选择语言，实用工具界面，在磁盘工具里面抹掉第一个主磁盘(选择抹掉,右下角抹掉),之后选择屏幕左上角小苹果旁边的”磁盘工具”,点击<br>“退出磁盘工具”,然后﻿选择“重装OSX系统”，即可重装。如果不行，就需要互联网恢复<br>osx关于恢复功能</p>
<ul>
<li><ol>
<li>关闭电脑，同时按住 command+option+R，然后开机，直到看到屏幕上出现一个地球才松开键盘上的键；</li>
</ol>
</li>
<li><ol>
<li>如果尚未联网，  地球下面会出现下拉菜单让您选择网络 ，   联网之后开始读取进度条；</li>
</ol>
</li>
<li><ol>
<li>进度条走完后电脑会重启，进入 “OS X 实用工具”界面； </li>
</ol>
</li>
<li><ol>
<li>选择“磁盘工具”，然后点按“继续”；</li>
</ol>
</li>
</ul>
<p>选择左边第一块总磁盘，  选择右边的 “分区”—当前选择“一个分区”    下面有个选项</p>
<ul>
<li><ol>
<li>并确保已选择“GUID 分区表”。</li>
</ol>
</li>
<li><ol>
<li>确保分区的格式为“Mac OS 扩展（日志式）”。</li>
</ol>
</li>
<li><ol>
<li>点按“应用”</li>
</ol>
</li>
<li><ol>
<li>退出后请点击第二行的重新安装；</li>
</ol>
</li>
<li><ol>
<li>然后根据提示步步进行下去，系统将会开始安装。</li>
</ol>
</li>
</ul>
<h1 id="互联网恢复方法："><a href="#互联网恢复方法：" class="headerlink" title="互联网恢复方法："></a>互联网恢复方法：</h1><ul>
<li><ol>
<li>关闭电脑，同时按住 command option R，然后开机，直到看到屏幕上出现一个地球才松开键盘上的键；</li>
</ol>
</li>
<li><ol>
<li>如果尚未联网，  地球下面会出现下拉菜单让您选择网络 ，   联网之后开始读取进度条；</li>
</ol>
</li>
<li><ol>
<li>进度条走完后电脑会重启，进入 “OS X 实用工具”界面； </li>
</ol>
</li>
<li><ol>
<li>选择“磁盘工具”，然后点按“继续”； </li>
</ol>
</li>
<li><ol>
<li>从左侧的列表中选择您的启动磁盘，然后点按“抹掉”标签；</li>
</ol>
</li>
<li><ol>
<li>从“格式”弹出式菜单中，选取“Mac OS 扩展（日志式）”，输入磁盘的名称，然后点按“抹掉”；</li>
</ol>
</li>
<li><ol>
<li>在磁盘已被抹掉后，请选取“磁盘工具”&gt;“退出磁盘工具”；</li>
</ol>
</li>
<li><ol>
<li>退出后请点击第二行的重新安装；</li>
</ol>
</li>
<li><ol>
<li>然后根据提示步步进行下去，系统将会开始安装。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真真是奔溃的不要不要的，mac重现安装了最新 Sierra 照样开机黑屏，毫无反应啊，&lt;br&gt;传说中的PARM大法也不好使了，无奈约了官网，下周六去检测。不过还是将折腾小记一番，&lt;br&gt;红烧清炖各种方法都试过了。&lt;/p&gt;
&lt;h1 id=&quot;mac开机黑屏解决方法&quot;&gt;&lt;a href=&quot;#mac开机黑屏解决方法&quot; class=&quot;headerlink&quot; title=&quot;mac开机黑屏解决方法&quot;&gt;&lt;/a&gt;mac开机黑屏解决方法&lt;/h1&gt;&lt;p&gt;通常来说开机速度慢或者开机黑屏&lt;/p&gt;
&lt;p&gt;关闭电脑，开机，同时按住 &lt;code&gt;command+option+R+P&lt;/code&gt; 这个时候就会听到‘当‘一声，继续按着&lt;br&gt;再听一次，（网上说有让听四次，我都试过了，一次、两次、三次、四次，其实无所谓，有一声足够），这个时候松开，就可以看到 苹果 下面是个进度条，不出意外的话，可以正常开机了。&lt;/p&gt;
&lt;p&gt;PS：我的是出了意外的，具体症状就是，开机即使如上操作，进度条走到一多半，关机了～～～&lt;br&gt;这什么情况，没折，只好继续想办法。你说再重装系统啊，那就试试看&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.imeetyou.net/categories/life/"/>
    
    
      <category term="mac" scheme="http://www.imeetyou.net/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>简单制作 macOS Sierra 正式版U盘USB启动安装盘方法教程</title>
    <link href="http://www.imeetyou.net/posts/life/2016/macos-usb-install-drive.html"/>
    <id>http://www.imeetyou.net/posts/life/2016/macos-usb-install-drive.html</id>
    <published>2016-11-12T05:38:23.000Z</published>
    <updated>2016-11-12T05:54:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近家里的Macmin重现折腾了一遍，换了一块ssd，系统要重现安装一次，需要制作U盘启动盘，<br>在此做个记录教程，方便以后查看。</p>
<h1 id="使用命令行创建制作-macOS-Sierra-正式版-USB-安装盘"><a href="#使用命令行创建制作-macOS-Sierra-正式版-USB-安装盘" class="headerlink" title="使用命令行创建制作 macOS Sierra 正式版 USB 安装盘"></a>使用命令行创建制作 macOS Sierra 正式版 USB 安装盘</h1><p>苹果官方系统内置的命令，优点是稳妥而且没有兼容性问题，只是需要通过命令行操作，对新手来说可能看似有点复杂，但其实步骤还是非常简单的</p>
<ul>
<li>首先，准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料。</li>
<li>下载好 macOS Sierra 正式版的安装程序</li>
<li>打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。)</li>
</ul>
<a id="more"></a>
<p><img src="http://og8z552x2.bkt.clouddn.com/disk_ulitily_2x.jpg" alt="disk_ulitily_2x"></p>
<ul>
<li>打开 “应用程序→实用工具→终端”，将下面的一段命令复制并粘贴进去：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction</div></pre></td></tr></table></figure>
<ul>
<li>回车并执行该命令，这时会提示让你输入管理员密码，便会开始制作过程了：</li>
</ul>
<p><img src="http://og8z552x2.bkt.clouddn.com/terminal_2x.jpg" alt="terminal_2x"></p>
<ul>
<li>如上图，这时系统已经在制作中了，请耐心等待直到屏幕最后出现 Done. 字样即表示大功告成了！然后，就带着U盘出去浪吧……</li>
</ul>
<h1 id="通过-U-盘安装-macOS-Sierra-格式化重装-抹盘全新安装系统-方法"><a href="#通过-U-盘安装-macOS-Sierra-格式化重装-抹盘全新安装系统-方法" class="headerlink" title="通过 U 盘安装 macOS Sierra / 格式化重装 (抹盘全新安装系统) 方法"></a>通过 U 盘安装 macOS Sierra / 格式化重装 (抹盘全新安装系统) 方法</h1><p>当你制作好 macOS Sierra 的安装盘 U 盘之后，你就可以利用它来给 Mac 电脑格式化重装 (抹盘安装)了。操作的方法非常简单：</p>
<ul>
<li>当然还是要想办法备份好 Mac 里所有的重要数据了。</li>
<li>插上制作好的安装U盘，如果系统能识别出来即可，这时我们先关机了。</li>
<li>按下电源键开机，当听到“噹”的一声时，按住 Option 键不放，直到出现启动菜单选项：</li>
</ul>
<p><img src="http://og8z552x2.bkt.clouddn.com/mac_option_boot_2x.jpg" alt="mac_option_boot"></p>
<ul>
<li><p>这时选择安装U盘 (黄色图标) 并回车，就可以开始安装了，在过程中你可以通过“磁盘工具”对 Mac 的磁盘式化或者重新分区等操作。</p>
</li>
<li><p>之后就是一步一步的安装直到完成了。</p>
</li>
</ul>
<p>更详细的或可以查看这里 <a href="http://www.iplaysoft.com/macos-usb-install-drive.html" target="_blank" rel="external">异次元</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近家里的Macmin重现折腾了一遍，换了一块ssd，系统要重现安装一次，需要制作U盘启动盘，&lt;br&gt;在此做个记录教程，方便以后查看。&lt;/p&gt;
&lt;h1 id=&quot;使用命令行创建制作-macOS-Sierra-正式版-USB-安装盘&quot;&gt;&lt;a href=&quot;#使用命令行创建制作-macOS-Sierra-正式版-USB-安装盘&quot; class=&quot;headerlink&quot; title=&quot;使用命令行创建制作 macOS Sierra 正式版 USB 安装盘&quot;&gt;&lt;/a&gt;使用命令行创建制作 macOS Sierra 正式版 USB 安装盘&lt;/h1&gt;&lt;p&gt;苹果官方系统内置的命令，优点是稳妥而且没有兼容性问题，只是需要通过命令行操作，对新手来说可能看似有点复杂，但其实步骤还是非常简单的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，准备一个 8GB 或更大容量的 U盘，并备份好里面的所有资料。&lt;/li&gt;
&lt;li&gt;下载好 macOS Sierra 正式版的安装程序&lt;/li&gt;
&lt;li&gt;打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.imeetyou.net/categories/life/"/>
    
    
      <category term="mac" scheme="http://www.imeetyou.net/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>React Native 中组件的生命周期</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/react-native-lifecycle.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/react-native-lifecycle.html</id>
    <published>2016-11-08T04:23:46.000Z</published>
    <updated>2016-11-09T03:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>就像 Android 开发中的 View 一样，React Native（RN） 中的组件也有生命周期（Lifecycle）。所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN 组件的生命周期整理如下图：</p>
<p><img src="http://og8z552x2.bkt.clouddn.com/component-lifecycle.jpg" alt="Lifecycle"></p>
<p>如图，可以把组件生命周期大致分为三个阶段：</p>
<ul>
<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>
<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>
<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>
</ul>
<a id="more"></a>
<h1 id="生命周期回调函数"><a href="#生命周期回调函数" class="headerlink" title="生命周期回调函数"></a>生命周期回调函数</h1><p>下面来详细介绍生命周期中的各回调函数。</p>
<h2 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h2><p>在组件创建之前，会先调用 <code>getDefaultProps()</code>，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 <code>getInitialState()</code>，来初始化组件的状态。</p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><p>然后，准备加载组件，会调用 componentWillMount()，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentWillMount()</div></pre></td></tr></table></figure>
<p>这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>在组件第一次绘制之后，会调用 <code>componentDidMount()</code>，通知组件已经加载完成。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentDidMount()</div></pre></td></tr></table></figure>
<p>这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 <code>componentDidMount()</code>，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 <code>setTimeout</code> 或者 <code>setInterval</code>，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。</p>
<h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><p>如果组件收到新的属性（props），就会调用 <code>componentWillReceiveProps()</code>，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentWillReceiveProps(</div><div class="line">  object nextProps</div><div class="line">)</div></pre></td></tr></table></figure>
<p>输入参数 <code>nextProps</code> 是即将被设置的属性，旧的属性还是可以通过 <code>this.props</code> 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 <code>this.setState()</code> 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 <code>render()</code> 调用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps: function(nextProps) &#123;</div><div class="line">  this.setState(&#123;</div><div class="line">    likesIncreasing: nextProps.likeCount &gt; this.props.likeCount</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>当组件接收到新的属性和状态改变的话，都会触发调用 <code>shouldComponentUpdate(...)</code>，函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boolean shouldComponentUpdate(</div><div class="line">  object nextProps, object nextState</div><div class="line">)</div></pre></td></tr></table></figure>
<p>输入参数 nextProps 和上面的 <code>componentWillReceiveProps</code> 函数一样，nextState 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 true 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>
<p>默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><p>如果组件状态或者属性改变，并且上面的 <code>shouldComponentUpdate(...)</code> 返回为 true，就会开始准更新组件，并调用 <code>componentWillUpdate()</code>，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentWillUpdate(</div><div class="line">  object nextProps, object nextState</div><div class="line">)</div></pre></td></tr></table></figure>
<p>输入参数与 <code>shouldComponentUpdate</code> 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 <code>nextProps</code> 和 <code>nextState</code> 分别设置到 <code>this.props</code> 和 <code>this.state</code> 中。紧接着这个函数，就会调用 <code>render()</code> 来更新界面了。</p>
<p>##componentDidUpdate</p>
<p>调用了 <code>render()</code> 更新完成界面之后，会调用 <code>componentDidUpdate()</code> 来得到通知，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentDidUpdate(</div><div class="line">  object prevProps, object prevState</div><div class="line">)</div></pre></td></tr></table></figure>
<p>因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 <code>prevProps</code> 和 <code>prevState</code>。</p>
<p>##componentWillUnmount</p>
<p>当组件要被从界面上移除的时候，就会调用 <code>componentWillUnmount()</code>，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentWillUnmount()</div></pre></td></tr></table></figure>
<p>在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，RN 的组件的完整的生命都介绍完了，在回头来看一下前面的图，就比较清晰了，把生命周期的回调函数总结成如下表格：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th style="text-align:center">调用次数</th>
<th style="text-align:right">能否setSate()</th>
</tr>
</thead>
<tbody>
<tr>
<td>getDefaultProps</td>
<td style="text-align:center">1(全局调用一次)</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>getInitialState</td>
<td style="text-align:center">1</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>componentWillMount</td>
<td style="text-align:center">1</td>
<td style="text-align:right">是</td>
</tr>
<tr>
<td>render</td>
<td style="text-align:center">&gt;=1</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>componentDidMount</td>
<td style="text-align:center">1</td>
<td style="text-align:right">是</td>
</tr>
<tr>
<td>componentWillReceiveProps</td>
<td style="text-align:center">&gt;=0</td>
<td style="text-align:right">是</td>
</tr>
<tr>
<td>shouldComponentUpdate</td>
<td style="text-align:center">&gt;=0</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>componentWillUpdate</td>
<td style="text-align:center">&gt;=0</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td style="text-align:center">&gt;=0</td>
<td style="text-align:right">否</td>
</tr>
<tr>
<td>componentWillUnmount</td>
<td style="text-align:center">1</td>
<td style="text-align:right">否</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;就像 Android 开发中的 View 一样，React Native（RN） 中的组件也有生命周期（Lifecycle）。所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN 组件的生命周期整理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://og8z552x2.bkt.clouddn.com/component-lifecycle.jpg&quot; alt=&quot;Lifecycle&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图，可以把组件生命周期大致分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；&lt;/li&gt;
&lt;li&gt;第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；&lt;/li&gt;
&lt;li&gt;第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="mac" scheme="http://www.imeetyou.net/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>mac格式化U盘方法（解决win下只有200MB的问题）</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/mac-u-format.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/mac-u-format.html</id>
    <published>2016-11-07T01:44:34.000Z</published>
    <updated>2016-11-09T02:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>有些朋友会发现在Mac上格式化的U盘放到windows的电脑上就只剩下200MB了，这是因为你在格式化时选择了guid分区，而win上只能识别一个分区，所以就只显示了200MB的那一个，接下来，我具体说一下方法~</p>
<ul>
<li>将U盘插入Mac电脑，然后打开磁盘工具</li>
<li>注意这一步，1号栏选exfat，因为他传输文件没有4GB的限制。2栏选主引导分布选项，这样的话就不会给你分两个区了，然后点抹掉，意思就是格式化。</li>
</ul>
<a id="more"></a>
<p><img src="http://og8z552x2.bkt.clouddn.com/mac-u.jpg" alt="mac-u"></p>
<ul>
<li>再插到win电脑上看一下，是不是成功了，就这么简单！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些朋友会发现在Mac上格式化的U盘放到windows的电脑上就只剩下200MB了，这是因为你在格式化时选择了guid分区，而win上只能识别一个分区，所以就只显示了200MB的那一个，接下来，我具体说一下方法~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将U盘插入Mac电脑，然后打开磁盘工具&lt;/li&gt;
&lt;li&gt;注意这一步，1号栏选exfat，因为他传输文件没有4GB的限制。2栏选主引导分布选项，这样的话就不会给你分两个区了，然后点抹掉，意思就是格式化。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="mac" scheme="http://www.imeetyou.net/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Angular2 英雄练级攻略</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/angular2-hero.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/angular2-hero.html</id>
    <published>2016-10-11T09:44:34.000Z</published>
    <updated>2016-10-11T09:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Angular2 英雄练级攻略</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular2 英雄练级攻略&lt;/p&gt;

    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="frontend" scheme="http://www.imeetyou.net/tags/frontend/"/>
    
      <category term="angular2" scheme="http://www.imeetyou.net/tags/angular2/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/hellow-hexo.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/hellow-hexo.html</id>
    <published>2016-02-16T06:31:54.000Z</published>
    <updated>2016-10-11T09:42:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新安装了Hexo，作为一个新的开始，做工作及学习记录。<br>hexo 的 主题很好，做点好玩的皮肤吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新安装了Hexo，作为一个新的开始，做工作及学习记录。&lt;br&gt;hexo 的 主题很好，做点好玩的皮肤吧。&lt;/p&gt;

    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="hexo" scheme="http://www.imeetyou.net/tags/hexo/"/>
    
      <category term="github" scheme="http://www.imeetyou.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.imeetyou.net/posts/frontend/2016/hello-world.html"/>
    <id>http://www.imeetyou.net/posts/frontend/2016/hello-world.html</id>
    <published>2016-02-01T04:31:54.000Z</published>
    <updated>2016-10-11T09:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
    
    </summary>
    
      <category term="frontend" scheme="http://www.imeetyou.net/categories/frontend/"/>
    
    
      <category term="hexo" scheme="http://www.imeetyou.net/tags/hexo/"/>
    
      <category term="github" scheme="http://www.imeetyou.net/tags/github/"/>
    
  </entry>
  
</feed>
